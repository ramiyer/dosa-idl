// Code generated by thriftrw v1.29.2. DO NOT EDIT.
// @generated

package dosa

import (
	bytes "bytes"
	base64 "encoding/base64"
	json "encoding/json"
	errors "errors"
	fmt "fmt"
	multierr "go.uber.org/multierr"
	stream "go.uber.org/thriftrw/protocol/stream"
	thriftreflect "go.uber.org/thriftrw/thriftreflect"
	wire "go.uber.org/thriftrw/wire"
	zapcore "go.uber.org/zap/zapcore"
	math "math"
	strconv "strconv"
	strings "strings"
)

type BadRequestError struct {
	Err       string  `json:"err,required"`
	Message   *string `json:"message,omitempty"`
	ErrorCode *int32  `json:"errorCode,omitempty"`
}

// ToWire translates a BadRequestError struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *BadRequestError) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Err), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Message != nil {
		w, err = wire.NewValueString(*(v.Message)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.ErrorCode != nil {
		w, err = wire.NewValueI32(*(v.ErrorCode)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a BadRequestError struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a BadRequestError struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v BadRequestError
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *BadRequestError) FromWire(w wire.Value) error {
	var err error

	errIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Err, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				errIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Message = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ErrorCode = &x
				if err != nil {
					return err
				}

			}
		}
	}

	if !errIsSet {
		return errors.New("field Err of BadRequestError is required")
	}

	return nil
}

// Encode serializes a BadRequestError struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a BadRequestError struct could not be encoded.
func (v *BadRequestError) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
		return err
	}
	if err := sw.WriteString(v.Err); err != nil {
		return err
	}
	if err := sw.WriteFieldEnd(); err != nil {
		return err
	}

	if v.Message != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Message)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ErrorCode != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.ErrorCode)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a BadRequestError struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a BadRequestError struct could not be generated from the wire
// representation.
func (v *BadRequestError) Decode(sr stream.Reader) error {

	errIsSet := false

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TBinary:
			v.Err, err = sr.ReadString()
			if err != nil {
				return err
			}
			errIsSet = true
		case fh.ID == 2 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Message = &x
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.ErrorCode = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	if !errIsSet {
		return errors.New("field Err of BadRequestError is required")
	}

	return nil
}

// String returns a readable string representation of a BadRequestError
// struct.
func (v *BadRequestError) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	fields[i] = fmt.Sprintf("Err: %v", v.Err)
	i++
	if v.Message != nil {
		fields[i] = fmt.Sprintf("Message: %v", *(v.Message))
		i++
	}
	if v.ErrorCode != nil {
		fields[i] = fmt.Sprintf("ErrorCode: %v", *(v.ErrorCode))
		i++
	}

	return fmt.Sprintf("BadRequestError{%v}", strings.Join(fields[:i], ", "))
}

// ErrorName is the name of this type as defined in the Thrift
// file.
func (*BadRequestError) ErrorName() string {
	return "BadRequestError"
}

func _String_EqualsPtr(lhs, rhs *string) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I32_EqualsPtr(lhs, rhs *int32) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this BadRequestError match the
// provided BadRequestError.
//
// This function performs a deep comparison.
func (v *BadRequestError) Equals(rhs *BadRequestError) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Err == rhs.Err) {
		return false
	}
	if !_String_EqualsPtr(v.Message, rhs.Message) {
		return false
	}
	if !_I32_EqualsPtr(v.ErrorCode, rhs.ErrorCode) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of BadRequestError.
func (v *BadRequestError) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("err", v.Err)
	if v.Message != nil {
		enc.AddString("message", *v.Message)
	}
	if v.ErrorCode != nil {
		enc.AddInt32("errorCode", *v.ErrorCode)
	}
	return err
}

// GetErr returns the value of Err if it is set or its
// zero value if it is unset.
func (v *BadRequestError) GetErr() (o string) {
	if v != nil {
		o = v.Err
	}
	return
}

// GetMessage returns the value of Message if it is set or its
// zero value if it is unset.
func (v *BadRequestError) GetMessage() (o string) {
	if v != nil && v.Message != nil {
		return *v.Message
	}

	return
}

// IsSetMessage returns true if Message is not nil.
func (v *BadRequestError) IsSetMessage() bool {
	return v != nil && v.Message != nil
}

// GetErrorCode returns the value of ErrorCode if it is set or its
// zero value if it is unset.
func (v *BadRequestError) GetErrorCode() (o int32) {
	if v != nil && v.ErrorCode != nil {
		return *v.ErrorCode
	}

	return
}

// IsSetErrorCode returns true if ErrorCode is not nil.
func (v *BadRequestError) IsSetErrorCode() bool {
	return v != nil && v.ErrorCode != nil
}

func (v *BadRequestError) Error() string {
	return v.String()
}

type BadSchemaError struct {
	Reasons map[string]string `json:"reasons,required"`
}

type _Map_String_String_MapItemList map[string]string

func (m _Map_String_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueString(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_String_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) Close() {}

// ToWire translates a BadSchemaError struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *BadSchemaError) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Reasons == nil {
		return w, errors.New("field Reasons of BadSchemaError is required")
	}
	w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Reasons)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_String_String_Read(m wire.MapItemList) (map[string]string, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string]string, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetString(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a BadSchemaError struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a BadSchemaError struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v BadSchemaError
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *BadSchemaError) FromWire(w wire.Value) error {
	var err error

	reasonsIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.Reasons, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
				reasonsIsSet = true
			}
		}
	}

	if !reasonsIsSet {
		return errors.New("field Reasons of BadSchemaError is required")
	}

	return nil
}

func _Map_String_String_Encode(val map[string]string, sw stream.Writer) error {

	mh := stream.MapHeader{
		KeyType:   wire.TBinary,
		ValueType: wire.TBinary,
		Length:    len(val),
	}
	if err := sw.WriteMapBegin(mh); err != nil {
		return err
	}

	for k, v := range val {
		if err := sw.WriteString(k); err != nil {
			return err
		}
		if err := sw.WriteString(v); err != nil {
			return err
		}
	}

	return sw.WriteMapEnd()
}

// Encode serializes a BadSchemaError struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a BadSchemaError struct could not be encoded.
func (v *BadSchemaError) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Reasons == nil {
		return errors.New("field Reasons of BadSchemaError is required")
	}
	if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TMap}); err != nil {
		return err
	}
	if err := _Map_String_String_Encode(v.Reasons, sw); err != nil {
		return err
	}
	if err := sw.WriteFieldEnd(); err != nil {
		return err
	}

	return sw.WriteStructEnd()
}

func _Map_String_String_Decode(sr stream.Reader) (map[string]string, error) {
	mh, err := sr.ReadMapBegin()
	if err != nil {
		return nil, err
	}

	if mh.KeyType != wire.TBinary || mh.ValueType != wire.TBinary {
		for i := 0; i < mh.Length; i++ {
			if err := sr.Skip(mh.KeyType); err != nil {
				return nil, err
			}

			if err := sr.Skip(mh.ValueType); err != nil {
				return nil, err
			}
		}
		return nil, sr.ReadMapEnd()
	}

	o := make(map[string]string, mh.Length)
	for i := 0; i < mh.Length; i++ {
		k, err := sr.ReadString()
		if err != nil {
			return nil, err
		}

		v, err := sr.ReadString()
		if err != nil {
			return nil, err
		}

		o[k] = v
	}

	if err = sr.ReadMapEnd(); err != nil {
		return nil, err
	}
	return o, err
}

// Decode deserializes a BadSchemaError struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a BadSchemaError struct could not be generated from the wire
// representation.
func (v *BadSchemaError) Decode(sr stream.Reader) error {

	reasonsIsSet := false

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TMap:
			v.Reasons, err = _Map_String_String_Decode(sr)
			if err != nil {
				return err
			}
			reasonsIsSet = true
		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	if !reasonsIsSet {
		return errors.New("field Reasons of BadSchemaError is required")
	}

	return nil
}

// String returns a readable string representation of a BadSchemaError
// struct.
func (v *BadSchemaError) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Reasons: %v", v.Reasons)
	i++

	return fmt.Sprintf("BadSchemaError{%v}", strings.Join(fields[:i], ", "))
}

// ErrorName is the name of this type as defined in the Thrift
// file.
func (*BadSchemaError) ErrorName() string {
	return "BadSchemaError"
}

func _Map_String_String_Equals(lhs, rhs map[string]string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this BadSchemaError match the
// provided BadSchemaError.
//
// This function performs a deep comparison.
func (v *BadSchemaError) Equals(rhs *BadSchemaError) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Map_String_String_Equals(v.Reasons, rhs.Reasons) {
		return false
	}

	return true
}

type _Map_String_String_Zapper map[string]string

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_String_Zapper.
func (m _Map_String_String_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		enc.AddString((string)(k), v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of BadSchemaError.
func (v *BadSchemaError) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddObject("reasons", (_Map_String_String_Zapper)(v.Reasons)))
	return err
}

// GetReasons returns the value of Reasons if it is set or its
// zero value if it is unset.
func (v *BadSchemaError) GetReasons() (o map[string]string) {
	if v != nil {
		o = v.Reasons
	}
	return
}

// IsSetReasons returns true if Reasons is not nil.
func (v *BadSchemaError) IsSetReasons() bool {
	return v != nil && v.Reasons != nil
}

func (v *BadSchemaError) Error() string {
	return v.String()
}

type CanUpsertSchemaRequest struct {
	Scope      *string             `json:"scope,omitempty"`
	NamePrefix *string             `json:"namePrefix,omitempty"`
	EntityDefs []*EntityDefinition `json:"entityDefs,omitempty"`
}

type _List_EntityDefinition_ValueList []*EntityDefinition

func (v _List_EntityDefinition_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid list '[]*EntityDefinition', index [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_EntityDefinition_ValueList) Size() int {
	return len(v)
}

func (_List_EntityDefinition_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_EntityDefinition_ValueList) Close() {}

// ToWire translates a CanUpsertSchemaRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *CanUpsertSchemaRequest) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Scope != nil {
		w, err = wire.NewValueString(*(v.Scope)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.NamePrefix != nil {
		w, err = wire.NewValueString(*(v.NamePrefix)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.EntityDefs != nil {
		w, err = wire.NewValueList(_List_EntityDefinition_ValueList(v.EntityDefs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _EntityDefinition_Read(w wire.Value) (*EntityDefinition, error) {
	var v EntityDefinition
	err := v.FromWire(w)
	return &v, err
}

func _List_EntityDefinition_Read(l wire.ValueList) ([]*EntityDefinition, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*EntityDefinition, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _EntityDefinition_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a CanUpsertSchemaRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a CanUpsertSchemaRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v CanUpsertSchemaRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *CanUpsertSchemaRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Scope = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.NamePrefix = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.EntityDefs, err = _List_EntityDefinition_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

func _List_EntityDefinition_Encode(val []*EntityDefinition, sw stream.Writer) error {

	lh := stream.ListHeader{
		Type:   wire.TStruct,
		Length: len(val),
	}
	if err := sw.WriteListBegin(lh); err != nil {
		return err
	}

	for i, v := range val {
		if v == nil {
			return fmt.Errorf("invalid list '[]*EntityDefinition', index [%v]: value is nil", i)
		}
		if err := v.Encode(sw); err != nil {
			return err
		}
	}
	return sw.WriteListEnd()
}

// Encode serializes a CanUpsertSchemaRequest struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a CanUpsertSchemaRequest struct could not be encoded.
func (v *CanUpsertSchemaRequest) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Scope != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Scope)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.NamePrefix != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.NamePrefix)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.EntityDefs != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_EntityDefinition_Encode(v.EntityDefs, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _EntityDefinition_Decode(sr stream.Reader) (*EntityDefinition, error) {
	var v EntityDefinition
	err := v.Decode(sr)
	return &v, err
}

func _List_EntityDefinition_Decode(sr stream.Reader) ([]*EntityDefinition, error) {
	lh, err := sr.ReadListBegin()
	if err != nil {
		return nil, err
	}

	if lh.Type != wire.TStruct {
		for i := 0; i < lh.Length; i++ {
			if err := sr.Skip(lh.Type); err != nil {
				return nil, err
			}
		}
		return nil, sr.ReadListEnd()
	}

	o := make([]*EntityDefinition, 0, lh.Length)
	for i := 0; i < lh.Length; i++ {
		v, err := _EntityDefinition_Decode(sr)
		if err != nil {
			return nil, err
		}
		o = append(o, v)
	}

	if err = sr.ReadListEnd(); err != nil {
		return nil, err
	}
	return o, err
}

// Decode deserializes a CanUpsertSchemaRequest struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a CanUpsertSchemaRequest struct could not be generated from the wire
// representation.
func (v *CanUpsertSchemaRequest) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Scope = &x
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.NamePrefix = &x
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TList:
			v.EntityDefs, err = _List_EntityDefinition_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a CanUpsertSchemaRequest
// struct.
func (v *CanUpsertSchemaRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Scope != nil {
		fields[i] = fmt.Sprintf("Scope: %v", *(v.Scope))
		i++
	}
	if v.NamePrefix != nil {
		fields[i] = fmt.Sprintf("NamePrefix: %v", *(v.NamePrefix))
		i++
	}
	if v.EntityDefs != nil {
		fields[i] = fmt.Sprintf("EntityDefs: %v", v.EntityDefs)
		i++
	}

	return fmt.Sprintf("CanUpsertSchemaRequest{%v}", strings.Join(fields[:i], ", "))
}

func _List_EntityDefinition_Equals(lhs, rhs []*EntityDefinition) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this CanUpsertSchemaRequest match the
// provided CanUpsertSchemaRequest.
//
// This function performs a deep comparison.
func (v *CanUpsertSchemaRequest) Equals(rhs *CanUpsertSchemaRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Scope, rhs.Scope) {
		return false
	}
	if !_String_EqualsPtr(v.NamePrefix, rhs.NamePrefix) {
		return false
	}
	if !((v.EntityDefs == nil && rhs.EntityDefs == nil) || (v.EntityDefs != nil && rhs.EntityDefs != nil && _List_EntityDefinition_Equals(v.EntityDefs, rhs.EntityDefs))) {
		return false
	}

	return true
}

type _List_EntityDefinition_Zapper []*EntityDefinition

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_EntityDefinition_Zapper.
func (l _List_EntityDefinition_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of CanUpsertSchemaRequest.
func (v *CanUpsertSchemaRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Scope != nil {
		enc.AddString("scope", *v.Scope)
	}
	if v.NamePrefix != nil {
		enc.AddString("namePrefix", *v.NamePrefix)
	}
	if v.EntityDefs != nil {
		err = multierr.Append(err, enc.AddArray("entityDefs", (_List_EntityDefinition_Zapper)(v.EntityDefs)))
	}
	return err
}

// GetScope returns the value of Scope if it is set or its
// zero value if it is unset.
func (v *CanUpsertSchemaRequest) GetScope() (o string) {
	if v != nil && v.Scope != nil {
		return *v.Scope
	}

	return
}

// IsSetScope returns true if Scope is not nil.
func (v *CanUpsertSchemaRequest) IsSetScope() bool {
	return v != nil && v.Scope != nil
}

// GetNamePrefix returns the value of NamePrefix if it is set or its
// zero value if it is unset.
func (v *CanUpsertSchemaRequest) GetNamePrefix() (o string) {
	if v != nil && v.NamePrefix != nil {
		return *v.NamePrefix
	}

	return
}

// IsSetNamePrefix returns true if NamePrefix is not nil.
func (v *CanUpsertSchemaRequest) IsSetNamePrefix() bool {
	return v != nil && v.NamePrefix != nil
}

// GetEntityDefs returns the value of EntityDefs if it is set or its
// zero value if it is unset.
func (v *CanUpsertSchemaRequest) GetEntityDefs() (o []*EntityDefinition) {
	if v != nil && v.EntityDefs != nil {
		return v.EntityDefs
	}

	return
}

// IsSetEntityDefs returns true if EntityDefs is not nil.
func (v *CanUpsertSchemaRequest) IsSetEntityDefs() bool {
	return v != nil && v.EntityDefs != nil
}

type CanUpsertSchemaResponse struct {
	Version *int32 `json:"version,omitempty"`
}

// ToWire translates a CanUpsertSchemaResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *CanUpsertSchemaResponse) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Version != nil {
		w, err = wire.NewValueI32(*(v.Version)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a CanUpsertSchemaResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a CanUpsertSchemaResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v CanUpsertSchemaResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *CanUpsertSchemaResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Version = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a CanUpsertSchemaResponse struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a CanUpsertSchemaResponse struct could not be encoded.
func (v *CanUpsertSchemaResponse) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Version != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.Version)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a CanUpsertSchemaResponse struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a CanUpsertSchemaResponse struct could not be generated from the wire
// representation.
func (v *CanUpsertSchemaResponse) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.Version = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a CanUpsertSchemaResponse
// struct.
func (v *CanUpsertSchemaResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Version != nil {
		fields[i] = fmt.Sprintf("Version: %v", *(v.Version))
		i++
	}

	return fmt.Sprintf("CanUpsertSchemaResponse{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this CanUpsertSchemaResponse match the
// provided CanUpsertSchemaResponse.
//
// This function performs a deep comparison.
func (v *CanUpsertSchemaResponse) Equals(rhs *CanUpsertSchemaResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.Version, rhs.Version) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of CanUpsertSchemaResponse.
func (v *CanUpsertSchemaResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Version != nil {
		enc.AddInt32("version", *v.Version)
	}
	return err
}

// GetVersion returns the value of Version if it is set or its
// zero value if it is unset.
func (v *CanUpsertSchemaResponse) GetVersion() (o int32) {
	if v != nil && v.Version != nil {
		return *v.Version
	}

	return
}

// IsSetVersion returns true if Version is not nil.
func (v *CanUpsertSchemaResponse) IsSetVersion() bool {
	return v != nil && v.Version != nil
}

type CheckSchemaRequest struct {
	Scope      *string             `json:"scope,omitempty"`
	NamePrefix *string             `json:"namePrefix,omitempty"`
	EntityDefs []*EntityDefinition `json:"entityDefs,omitempty"`
}

// ToWire translates a CheckSchemaRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *CheckSchemaRequest) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Scope != nil {
		w, err = wire.NewValueString(*(v.Scope)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.NamePrefix != nil {
		w, err = wire.NewValueString(*(v.NamePrefix)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.EntityDefs != nil {
		w, err = wire.NewValueList(_List_EntityDefinition_ValueList(v.EntityDefs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a CheckSchemaRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a CheckSchemaRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v CheckSchemaRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *CheckSchemaRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Scope = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.NamePrefix = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.EntityDefs, err = _List_EntityDefinition_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a CheckSchemaRequest struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a CheckSchemaRequest struct could not be encoded.
func (v *CheckSchemaRequest) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Scope != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Scope)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.NamePrefix != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.NamePrefix)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.EntityDefs != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_EntityDefinition_Encode(v.EntityDefs, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a CheckSchemaRequest struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a CheckSchemaRequest struct could not be generated from the wire
// representation.
func (v *CheckSchemaRequest) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Scope = &x
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.NamePrefix = &x
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TList:
			v.EntityDefs, err = _List_EntityDefinition_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a CheckSchemaRequest
// struct.
func (v *CheckSchemaRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Scope != nil {
		fields[i] = fmt.Sprintf("Scope: %v", *(v.Scope))
		i++
	}
	if v.NamePrefix != nil {
		fields[i] = fmt.Sprintf("NamePrefix: %v", *(v.NamePrefix))
		i++
	}
	if v.EntityDefs != nil {
		fields[i] = fmt.Sprintf("EntityDefs: %v", v.EntityDefs)
		i++
	}

	return fmt.Sprintf("CheckSchemaRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this CheckSchemaRequest match the
// provided CheckSchemaRequest.
//
// This function performs a deep comparison.
func (v *CheckSchemaRequest) Equals(rhs *CheckSchemaRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Scope, rhs.Scope) {
		return false
	}
	if !_String_EqualsPtr(v.NamePrefix, rhs.NamePrefix) {
		return false
	}
	if !((v.EntityDefs == nil && rhs.EntityDefs == nil) || (v.EntityDefs != nil && rhs.EntityDefs != nil && _List_EntityDefinition_Equals(v.EntityDefs, rhs.EntityDefs))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of CheckSchemaRequest.
func (v *CheckSchemaRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Scope != nil {
		enc.AddString("scope", *v.Scope)
	}
	if v.NamePrefix != nil {
		enc.AddString("namePrefix", *v.NamePrefix)
	}
	if v.EntityDefs != nil {
		err = multierr.Append(err, enc.AddArray("entityDefs", (_List_EntityDefinition_Zapper)(v.EntityDefs)))
	}
	return err
}

// GetScope returns the value of Scope if it is set or its
// zero value if it is unset.
func (v *CheckSchemaRequest) GetScope() (o string) {
	if v != nil && v.Scope != nil {
		return *v.Scope
	}

	return
}

// IsSetScope returns true if Scope is not nil.
func (v *CheckSchemaRequest) IsSetScope() bool {
	return v != nil && v.Scope != nil
}

// GetNamePrefix returns the value of NamePrefix if it is set or its
// zero value if it is unset.
func (v *CheckSchemaRequest) GetNamePrefix() (o string) {
	if v != nil && v.NamePrefix != nil {
		return *v.NamePrefix
	}

	return
}

// IsSetNamePrefix returns true if NamePrefix is not nil.
func (v *CheckSchemaRequest) IsSetNamePrefix() bool {
	return v != nil && v.NamePrefix != nil
}

// GetEntityDefs returns the value of EntityDefs if it is set or its
// zero value if it is unset.
func (v *CheckSchemaRequest) GetEntityDefs() (o []*EntityDefinition) {
	if v != nil && v.EntityDefs != nil {
		return v.EntityDefs
	}

	return
}

// IsSetEntityDefs returns true if EntityDefs is not nil.
func (v *CheckSchemaRequest) IsSetEntityDefs() bool {
	return v != nil && v.EntityDefs != nil
}

type CheckSchemaResponse struct {
	Version *int32 `json:"version,omitempty"`
}

// ToWire translates a CheckSchemaResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *CheckSchemaResponse) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Version != nil {
		w, err = wire.NewValueI32(*(v.Version)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a CheckSchemaResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a CheckSchemaResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v CheckSchemaResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *CheckSchemaResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Version = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a CheckSchemaResponse struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a CheckSchemaResponse struct could not be encoded.
func (v *CheckSchemaResponse) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Version != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.Version)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a CheckSchemaResponse struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a CheckSchemaResponse struct could not be generated from the wire
// representation.
func (v *CheckSchemaResponse) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.Version = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a CheckSchemaResponse
// struct.
func (v *CheckSchemaResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Version != nil {
		fields[i] = fmt.Sprintf("Version: %v", *(v.Version))
		i++
	}

	return fmt.Sprintf("CheckSchemaResponse{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this CheckSchemaResponse match the
// provided CheckSchemaResponse.
//
// This function performs a deep comparison.
func (v *CheckSchemaResponse) Equals(rhs *CheckSchemaResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.Version, rhs.Version) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of CheckSchemaResponse.
func (v *CheckSchemaResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Version != nil {
		enc.AddInt32("version", *v.Version)
	}
	return err
}

// GetVersion returns the value of Version if it is set or its
// zero value if it is unset.
func (v *CheckSchemaResponse) GetVersion() (o int32) {
	if v != nil && v.Version != nil {
		return *v.Version
	}

	return
}

// IsSetVersion returns true if Version is not nil.
func (v *CheckSchemaResponse) IsSetVersion() bool {
	return v != nil && v.Version != nil
}

type CheckSchemaStatusRequest struct {
	Scope      *string `json:"scope,omitempty"`
	NamePrefix *string `json:"namePrefix,omitempty"`
	Version    *int32  `json:"version,omitempty"`
}

// ToWire translates a CheckSchemaStatusRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *CheckSchemaStatusRequest) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Scope != nil {
		w, err = wire.NewValueString(*(v.Scope)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.NamePrefix != nil {
		w, err = wire.NewValueString(*(v.NamePrefix)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Version != nil {
		w, err = wire.NewValueI32(*(v.Version)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a CheckSchemaStatusRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a CheckSchemaStatusRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v CheckSchemaStatusRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *CheckSchemaStatusRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Scope = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.NamePrefix = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Version = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a CheckSchemaStatusRequest struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a CheckSchemaStatusRequest struct could not be encoded.
func (v *CheckSchemaStatusRequest) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Scope != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Scope)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.NamePrefix != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.NamePrefix)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Version != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.Version)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a CheckSchemaStatusRequest struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a CheckSchemaStatusRequest struct could not be generated from the wire
// representation.
func (v *CheckSchemaStatusRequest) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Scope = &x
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.NamePrefix = &x
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.Version = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a CheckSchemaStatusRequest
// struct.
func (v *CheckSchemaStatusRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Scope != nil {
		fields[i] = fmt.Sprintf("Scope: %v", *(v.Scope))
		i++
	}
	if v.NamePrefix != nil {
		fields[i] = fmt.Sprintf("NamePrefix: %v", *(v.NamePrefix))
		i++
	}
	if v.Version != nil {
		fields[i] = fmt.Sprintf("Version: %v", *(v.Version))
		i++
	}

	return fmt.Sprintf("CheckSchemaStatusRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this CheckSchemaStatusRequest match the
// provided CheckSchemaStatusRequest.
//
// This function performs a deep comparison.
func (v *CheckSchemaStatusRequest) Equals(rhs *CheckSchemaStatusRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Scope, rhs.Scope) {
		return false
	}
	if !_String_EqualsPtr(v.NamePrefix, rhs.NamePrefix) {
		return false
	}
	if !_I32_EqualsPtr(v.Version, rhs.Version) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of CheckSchemaStatusRequest.
func (v *CheckSchemaStatusRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Scope != nil {
		enc.AddString("scope", *v.Scope)
	}
	if v.NamePrefix != nil {
		enc.AddString("namePrefix", *v.NamePrefix)
	}
	if v.Version != nil {
		enc.AddInt32("version", *v.Version)
	}
	return err
}

// GetScope returns the value of Scope if it is set or its
// zero value if it is unset.
func (v *CheckSchemaStatusRequest) GetScope() (o string) {
	if v != nil && v.Scope != nil {
		return *v.Scope
	}

	return
}

// IsSetScope returns true if Scope is not nil.
func (v *CheckSchemaStatusRequest) IsSetScope() bool {
	return v != nil && v.Scope != nil
}

// GetNamePrefix returns the value of NamePrefix if it is set or its
// zero value if it is unset.
func (v *CheckSchemaStatusRequest) GetNamePrefix() (o string) {
	if v != nil && v.NamePrefix != nil {
		return *v.NamePrefix
	}

	return
}

// IsSetNamePrefix returns true if NamePrefix is not nil.
func (v *CheckSchemaStatusRequest) IsSetNamePrefix() bool {
	return v != nil && v.NamePrefix != nil
}

// GetVersion returns the value of Version if it is set or its
// zero value if it is unset.
func (v *CheckSchemaStatusRequest) GetVersion() (o int32) {
	if v != nil && v.Version != nil {
		return *v.Version
	}

	return
}

// IsSetVersion returns true if Version is not nil.
func (v *CheckSchemaStatusRequest) IsSetVersion() bool {
	return v != nil && v.Version != nil
}

type CheckSchemaStatusResponse struct {
	Version *int32  `json:"version,omitempty"`
	Status  *string `json:"status,omitempty"`
}

// ToWire translates a CheckSchemaStatusResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *CheckSchemaStatusResponse) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Version != nil {
		w, err = wire.NewValueI32(*(v.Version)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Status != nil {
		w, err = wire.NewValueString(*(v.Status)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a CheckSchemaStatusResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a CheckSchemaStatusResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v CheckSchemaStatusResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *CheckSchemaStatusResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Version = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Status = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a CheckSchemaStatusResponse struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a CheckSchemaStatusResponse struct could not be encoded.
func (v *CheckSchemaStatusResponse) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Version != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.Version)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Status != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Status)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a CheckSchemaStatusResponse struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a CheckSchemaStatusResponse struct could not be generated from the wire
// representation.
func (v *CheckSchemaStatusResponse) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.Version = &x
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Status = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a CheckSchemaStatusResponse
// struct.
func (v *CheckSchemaStatusResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Version != nil {
		fields[i] = fmt.Sprintf("Version: %v", *(v.Version))
		i++
	}
	if v.Status != nil {
		fields[i] = fmt.Sprintf("Status: %v", *(v.Status))
		i++
	}

	return fmt.Sprintf("CheckSchemaStatusResponse{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this CheckSchemaStatusResponse match the
// provided CheckSchemaStatusResponse.
//
// This function performs a deep comparison.
func (v *CheckSchemaStatusResponse) Equals(rhs *CheckSchemaStatusResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.Version, rhs.Version) {
		return false
	}
	if !_String_EqualsPtr(v.Status, rhs.Status) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of CheckSchemaStatusResponse.
func (v *CheckSchemaStatusResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Version != nil {
		enc.AddInt32("version", *v.Version)
	}
	if v.Status != nil {
		enc.AddString("status", *v.Status)
	}
	return err
}

// GetVersion returns the value of Version if it is set or its
// zero value if it is unset.
func (v *CheckSchemaStatusResponse) GetVersion() (o int32) {
	if v != nil && v.Version != nil {
		return *v.Version
	}

	return
}

// IsSetVersion returns true if Version is not nil.
func (v *CheckSchemaStatusResponse) IsSetVersion() bool {
	return v != nil && v.Version != nil
}

// GetStatus returns the value of Status if it is set or its
// zero value if it is unset.
func (v *CheckSchemaStatusResponse) GetStatus() (o string) {
	if v != nil && v.Status != nil {
		return *v.Status
	}

	return
}

// IsSetStatus returns true if Status is not nil.
func (v *CheckSchemaStatusResponse) IsSetStatus() bool {
	return v != nil && v.Status != nil
}

type ClusteringKey struct {
	Name *string `json:"name,omitempty"`
	Asc  *bool   `json:"asc,omitempty"`
}

// ToWire translates a ClusteringKey struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ClusteringKey) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Asc != nil {
		w, err = wire.NewValueBool(*(v.Asc)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ClusteringKey struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ClusteringKey struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ClusteringKey
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ClusteringKey) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.Asc = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a ClusteringKey struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a ClusteringKey struct could not be encoded.
func (v *ClusteringKey) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Name != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Name)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Asc != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBool}); err != nil {
			return err
		}
		if err := sw.WriteBool(*(v.Asc)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a ClusteringKey struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a ClusteringKey struct could not be generated from the wire
// representation.
func (v *ClusteringKey) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Name = &x
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TBool:
			var x bool
			x, err = sr.ReadBool()
			v.Asc = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a ClusteringKey
// struct.
func (v *ClusteringKey) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Asc != nil {
		fields[i] = fmt.Sprintf("Asc: %v", *(v.Asc))
		i++
	}

	return fmt.Sprintf("ClusteringKey{%v}", strings.Join(fields[:i], ", "))
}

func _Bool_EqualsPtr(lhs, rhs *bool) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this ClusteringKey match the
// provided ClusteringKey.
//
// This function performs a deep comparison.
func (v *ClusteringKey) Equals(rhs *ClusteringKey) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !_Bool_EqualsPtr(v.Asc, rhs.Asc) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ClusteringKey.
func (v *ClusteringKey) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.Asc != nil {
		enc.AddBool("asc", *v.Asc)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *ClusteringKey) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *ClusteringKey) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetAsc returns the value of Asc if it is set or its
// zero value if it is unset.
func (v *ClusteringKey) GetAsc() (o bool) {
	if v != nil && v.Asc != nil {
		return *v.Asc
	}

	return
}

// IsSetAsc returns true if Asc is not nil.
func (v *ClusteringKey) IsSetAsc() bool {
	return v != nil && v.Asc != nil
}

type Condition struct {
	Op    *Operator `json:"op,omitempty"`
	Field *Field    `json:"field,omitempty"`
}

// ToWire translates a Condition struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Condition) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Op != nil {
		w, err = v.Op.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Field != nil {
		w, err = v.Field.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Operator_Read(w wire.Value) (Operator, error) {
	var v Operator
	err := v.FromWire(w)
	return v, err
}

func _Field_Read(w wire.Value) (*Field, error) {
	var v Field
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Condition struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Condition struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Condition
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Condition) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x Operator
				x, err = _Operator_Read(field.Value)
				v.Op = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Field, err = _Field_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Condition struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Condition struct could not be encoded.
func (v *Condition) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Op != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TI32}); err != nil {
			return err
		}
		if err := v.Op.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Field != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Field.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _Operator_Decode(sr stream.Reader) (Operator, error) {
	var v Operator
	err := v.Decode(sr)
	return v, err
}

func _Field_Decode(sr stream.Reader) (*Field, error) {
	var v Field
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Condition struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Condition struct could not be generated from the wire
// representation.
func (v *Condition) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TI32:
			var x Operator
			x, err = _Operator_Decode(sr)
			v.Op = &x
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.Field, err = _Field_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Condition
// struct.
func (v *Condition) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Op != nil {
		fields[i] = fmt.Sprintf("Op: %v", *(v.Op))
		i++
	}
	if v.Field != nil {
		fields[i] = fmt.Sprintf("Field: %v", v.Field)
		i++
	}

	return fmt.Sprintf("Condition{%v}", strings.Join(fields[:i], ", "))
}

func _Operator_EqualsPtr(lhs, rhs *Operator) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this Condition match the
// provided Condition.
//
// This function performs a deep comparison.
func (v *Condition) Equals(rhs *Condition) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Operator_EqualsPtr(v.Op, rhs.Op) {
		return false
	}
	if !((v.Field == nil && rhs.Field == nil) || (v.Field != nil && rhs.Field != nil && v.Field.Equals(rhs.Field))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Condition.
func (v *Condition) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Op != nil {
		err = multierr.Append(err, enc.AddObject("op", *v.Op))
	}
	if v.Field != nil {
		err = multierr.Append(err, enc.AddObject("field", v.Field))
	}
	return err
}

// GetOp returns the value of Op if it is set or its
// zero value if it is unset.
func (v *Condition) GetOp() (o Operator) {
	if v != nil && v.Op != nil {
		return *v.Op
	}

	return
}

// IsSetOp returns true if Op is not nil.
func (v *Condition) IsSetOp() bool {
	return v != nil && v.Op != nil
}

// GetField returns the value of Field if it is set or its
// zero value if it is unset.
func (v *Condition) GetField() (o *Field) {
	if v != nil && v.Field != nil {
		return v.Field
	}

	return
}

// IsSetField returns true if Field is not nil.
func (v *Condition) IsSetField() bool {
	return v != nil && v.Field != nil
}

type CreateRequest struct {
	Ref          *SchemaRef    `json:"ref,omitempty"`
	EntityValues FieldValueMap `json:"entityValues,omitempty"`
	TTL          *int64        `json:"ttl,omitempty"`
	Timestamp    *int64        `json:"timestamp,omitempty"`
}

// ToWire translates a CreateRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *CreateRequest) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Ref != nil {
		w, err = v.Ref.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.EntityValues != nil {
		w, err = v.EntityValues.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.TTL != nil {
		w, err = wire.NewValueI64(*(v.TTL)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Timestamp != nil {
		w, err = wire.NewValueI64(*(v.Timestamp)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _SchemaRef_Read(w wire.Value) (*SchemaRef, error) {
	var v SchemaRef
	err := v.FromWire(w)
	return &v, err
}

func _FieldValueMap_Read(w wire.Value) (FieldValueMap, error) {
	var x FieldValueMap
	err := x.FromWire(w)
	return x, err
}

// FromWire deserializes a CreateRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a CreateRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v CreateRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *CreateRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Ref, err = _SchemaRef_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TMap {
				v.EntityValues, err = _FieldValueMap_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.TTL = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Timestamp = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a CreateRequest struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a CreateRequest struct could not be encoded.
func (v *CreateRequest) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Ref != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Ref.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.EntityValues != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TMap}); err != nil {
			return err
		}
		if err := v.EntityValues.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TTL != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.TTL)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Timestamp != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 4, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.Timestamp)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _SchemaRef_Decode(sr stream.Reader) (*SchemaRef, error) {
	var v SchemaRef
	err := v.Decode(sr)
	return &v, err
}

func _FieldValueMap_Decode(sr stream.Reader) (FieldValueMap, error) {
	var x FieldValueMap
	err := x.Decode(sr)
	return x, err
}

// Decode deserializes a CreateRequest struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a CreateRequest struct could not be generated from the wire
// representation.
func (v *CreateRequest) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Ref, err = _SchemaRef_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TMap:
			v.EntityValues, err = _FieldValueMap_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.TTL = &x
			if err != nil {
				return err
			}

		case fh.ID == 4 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.Timestamp = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a CreateRequest
// struct.
func (v *CreateRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Ref != nil {
		fields[i] = fmt.Sprintf("Ref: %v", v.Ref)
		i++
	}
	if v.EntityValues != nil {
		fields[i] = fmt.Sprintf("EntityValues: %v", v.EntityValues)
		i++
	}
	if v.TTL != nil {
		fields[i] = fmt.Sprintf("TTL: %v", *(v.TTL))
		i++
	}
	if v.Timestamp != nil {
		fields[i] = fmt.Sprintf("Timestamp: %v", *(v.Timestamp))
		i++
	}

	return fmt.Sprintf("CreateRequest{%v}", strings.Join(fields[:i], ", "))
}

func _I64_EqualsPtr(lhs, rhs *int64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this CreateRequest match the
// provided CreateRequest.
//
// This function performs a deep comparison.
func (v *CreateRequest) Equals(rhs *CreateRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Ref == nil && rhs.Ref == nil) || (v.Ref != nil && rhs.Ref != nil && v.Ref.Equals(rhs.Ref))) {
		return false
	}
	if !((v.EntityValues == nil && rhs.EntityValues == nil) || (v.EntityValues != nil && rhs.EntityValues != nil && v.EntityValues.Equals(rhs.EntityValues))) {
		return false
	}
	if !_I64_EqualsPtr(v.TTL, rhs.TTL) {
		return false
	}
	if !_I64_EqualsPtr(v.Timestamp, rhs.Timestamp) {
		return false
	}

	return true
}

type _Map_String_Value_Zapper map[string]*Value

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_Value_Zapper.
func (m _Map_String_Value_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AddObject((string)(k), v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of CreateRequest.
func (v *CreateRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Ref != nil {
		err = multierr.Append(err, enc.AddObject("ref", v.Ref))
	}
	if v.EntityValues != nil {
		err = multierr.Append(err, enc.AddObject("entityValues", (_Map_String_Value_Zapper)(v.EntityValues)))
	}
	if v.TTL != nil {
		enc.AddInt64("ttl", *v.TTL)
	}
	if v.Timestamp != nil {
		enc.AddInt64("timestamp", *v.Timestamp)
	}
	return err
}

// GetRef returns the value of Ref if it is set or its
// zero value if it is unset.
func (v *CreateRequest) GetRef() (o *SchemaRef) {
	if v != nil && v.Ref != nil {
		return v.Ref
	}

	return
}

// IsSetRef returns true if Ref is not nil.
func (v *CreateRequest) IsSetRef() bool {
	return v != nil && v.Ref != nil
}

// GetEntityValues returns the value of EntityValues if it is set or its
// zero value if it is unset.
func (v *CreateRequest) GetEntityValues() (o FieldValueMap) {
	if v != nil && v.EntityValues != nil {
		return v.EntityValues
	}

	return
}

// IsSetEntityValues returns true if EntityValues is not nil.
func (v *CreateRequest) IsSetEntityValues() bool {
	return v != nil && v.EntityValues != nil
}

// GetTTL returns the value of TTL if it is set or its
// zero value if it is unset.
func (v *CreateRequest) GetTTL() (o int64) {
	if v != nil && v.TTL != nil {
		return *v.TTL
	}

	return
}

// IsSetTTL returns true if TTL is not nil.
func (v *CreateRequest) IsSetTTL() bool {
	return v != nil && v.TTL != nil
}

// GetTimestamp returns the value of Timestamp if it is set or its
// zero value if it is unset.
func (v *CreateRequest) GetTimestamp() (o int64) {
	if v != nil && v.Timestamp != nil {
		return *v.Timestamp
	}

	return
}

// IsSetTimestamp returns true if Timestamp is not nil.
func (v *CreateRequest) IsSetTimestamp() bool {
	return v != nil && v.Timestamp != nil
}

type CreateScopeRequest struct {
	Name      *string `json:"name,omitempty"`
	Requester *string `json:"requester,omitempty"`
	Metadata  *string `json:"metadata,omitempty"`
}

// ToWire translates a CreateScopeRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *CreateScopeRequest) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Requester != nil {
		w, err = wire.NewValueString(*(v.Requester)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Metadata != nil {
		w, err = wire.NewValueString(*(v.Metadata)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a CreateScopeRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a CreateScopeRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v CreateScopeRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *CreateScopeRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Requester = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Metadata = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a CreateScopeRequest struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a CreateScopeRequest struct could not be encoded.
func (v *CreateScopeRequest) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Name != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Name)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Requester != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Requester)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Metadata != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Metadata)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a CreateScopeRequest struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a CreateScopeRequest struct could not be generated from the wire
// representation.
func (v *CreateScopeRequest) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Name = &x
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Requester = &x
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Metadata = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a CreateScopeRequest
// struct.
func (v *CreateScopeRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Requester != nil {
		fields[i] = fmt.Sprintf("Requester: %v", *(v.Requester))
		i++
	}
	if v.Metadata != nil {
		fields[i] = fmt.Sprintf("Metadata: %v", *(v.Metadata))
		i++
	}

	return fmt.Sprintf("CreateScopeRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this CreateScopeRequest match the
// provided CreateScopeRequest.
//
// This function performs a deep comparison.
func (v *CreateScopeRequest) Equals(rhs *CreateScopeRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !_String_EqualsPtr(v.Requester, rhs.Requester) {
		return false
	}
	if !_String_EqualsPtr(v.Metadata, rhs.Metadata) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of CreateScopeRequest.
func (v *CreateScopeRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.Requester != nil {
		enc.AddString("requester", *v.Requester)
	}
	if v.Metadata != nil {
		enc.AddString("metadata", *v.Metadata)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *CreateScopeRequest) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *CreateScopeRequest) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetRequester returns the value of Requester if it is set or its
// zero value if it is unset.
func (v *CreateScopeRequest) GetRequester() (o string) {
	if v != nil && v.Requester != nil {
		return *v.Requester
	}

	return
}

// IsSetRequester returns true if Requester is not nil.
func (v *CreateScopeRequest) IsSetRequester() bool {
	return v != nil && v.Requester != nil
}

// GetMetadata returns the value of Metadata if it is set or its
// zero value if it is unset.
func (v *CreateScopeRequest) GetMetadata() (o string) {
	if v != nil && v.Metadata != nil {
		return *v.Metadata
	}

	return
}

// IsSetMetadata returns true if Metadata is not nil.
func (v *CreateScopeRequest) IsSetMetadata() bool {
	return v != nil && v.Metadata != nil
}

type DropScopeRequest struct {
	Name      *string `json:"name,omitempty"`
	Requester *string `json:"requester,omitempty"`
}

// ToWire translates a DropScopeRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *DropScopeRequest) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Requester != nil {
		w, err = wire.NewValueString(*(v.Requester)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a DropScopeRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a DropScopeRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v DropScopeRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *DropScopeRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Requester = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a DropScopeRequest struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a DropScopeRequest struct could not be encoded.
func (v *DropScopeRequest) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Name != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Name)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Requester != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Requester)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a DropScopeRequest struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a DropScopeRequest struct could not be generated from the wire
// representation.
func (v *DropScopeRequest) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Name = &x
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Requester = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a DropScopeRequest
// struct.
func (v *DropScopeRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Requester != nil {
		fields[i] = fmt.Sprintf("Requester: %v", *(v.Requester))
		i++
	}

	return fmt.Sprintf("DropScopeRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this DropScopeRequest match the
// provided DropScopeRequest.
//
// This function performs a deep comparison.
func (v *DropScopeRequest) Equals(rhs *DropScopeRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !_String_EqualsPtr(v.Requester, rhs.Requester) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of DropScopeRequest.
func (v *DropScopeRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.Requester != nil {
		enc.AddString("requester", *v.Requester)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *DropScopeRequest) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *DropScopeRequest) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetRequester returns the value of Requester if it is set or its
// zero value if it is unset.
func (v *DropScopeRequest) GetRequester() (o string) {
	if v != nil && v.Requester != nil {
		return *v.Requester
	}

	return
}

// IsSetRequester returns true if Requester is not nil.
func (v *DropScopeRequest) IsSetRequester() bool {
	return v != nil && v.Requester != nil
}

type ETLState int32

const (
	ETLStateOff       ETLState = 1
	ETLStateOn        ETLState = 2
	ETLStateReserved0 ETLState = 3
	ETLStateReserved1 ETLState = 4
)

// ETLState_Values returns all recognized values of ETLState.
func ETLState_Values() []ETLState {
	return []ETLState{
		ETLStateOff,
		ETLStateOn,
		ETLStateReserved0,
		ETLStateReserved1,
	}
}

// UnmarshalText tries to decode ETLState from a byte slice
// containing its name.
//
//   var v ETLState
//   err := v.UnmarshalText([]byte("OFF"))
func (v *ETLState) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "OFF":
		*v = ETLStateOff
		return nil
	case "ON":
		*v = ETLStateOn
		return nil
	case "RESERVED0":
		*v = ETLStateReserved0
		return nil
	case "RESERVED1":
		*v = ETLStateReserved1
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "ETLState", err)
		}
		*v = ETLState(val)
		return nil
	}
}

// MarshalText encodes ETLState to text.
//
// If the enum value is recognized, its name is returned.
// Otherwise, its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v ETLState) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 1:
		return []byte("OFF"), nil
	case 2:
		return []byte("ON"), nil
	case 3:
		return []byte("RESERVED0"), nil
	case 4:
		return []byte("RESERVED1"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ETLState.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v ETLState) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 1:
		enc.AddString("name", "OFF")
	case 2:
		enc.AddString("name", "ON")
	case 3:
		enc.AddString("name", "RESERVED0")
	case 4:
		enc.AddString("name", "RESERVED1")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v ETLState) Ptr() *ETLState {
	return &v
}

// Encode encodes ETLState directly to bytes.
//
//   sWriter := BinaryStreamer.Writer(writer)
//
//   var v ETLState
//   return v.Encode(sWriter)
func (v ETLState) Encode(sw stream.Writer) error {
	return sw.WriteInt32(int32(v))
}

// ToWire translates ETLState into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v ETLState) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes ETLState from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return ETLState(0), err
//   }
//
//   var v ETLState
//   if err := v.FromWire(x); err != nil {
//     return ETLState(0), err
//   }
//   return v, nil
func (v *ETLState) FromWire(w wire.Value) error {
	*v = (ETLState)(w.GetI32())
	return nil
}

// Decode reads off the encoded ETLState directly off of the wire.
//
//   sReader := BinaryStreamer.Reader(reader)
//
//   var v ETLState
//   if err := v.Decode(sReader); err != nil {
//     return ETLState(0), err
//   }
//   return v, nil
func (v *ETLState) Decode(sr stream.Reader) error {
	i, err := sr.ReadInt32()
	if err != nil {
		return err
	}
	*v = (ETLState)(i)
	return nil
}

// String returns a readable string representation of ETLState.
func (v ETLState) String() string {
	w := int32(v)
	switch w {
	case 1:
		return "OFF"
	case 2:
		return "ON"
	case 3:
		return "RESERVED0"
	case 4:
		return "RESERVED1"
	}
	return fmt.Sprintf("ETLState(%d)", w)
}

// Equals returns true if this ETLState value matches the provided
// value.
func (v ETLState) Equals(rhs ETLState) bool {
	return v == rhs
}

// MarshalJSON serializes ETLState into JSON.
//
// If the enum value is recognized, its name is returned.
// Otherwise, its integer value is returned.
//
// This implements json.Marshaler.
func (v ETLState) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 1:
		return ([]byte)("\"OFF\""), nil
	case 2:
		return ([]byte)("\"ON\""), nil
	case 3:
		return ([]byte)("\"RESERVED0\""), nil
	case 4:
		return ([]byte)("\"RESERVED1\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode ETLState from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *ETLState) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "ETLState")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "ETLState")
		}
		*v = (ETLState)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "ETLState")
	}
}

type ElemType int32

const (
	ElemTypeBool      ElemType = 0
	ElemTypeBlob      ElemType = 1
	ElemTypeString    ElemType = 2
	ElemTypeInt32     ElemType = 3
	ElemTypeInt64     ElemType = 4
	ElemTypeDouble    ElemType = 5
	ElemTypeTimestamp ElemType = 6
	ElemTypeUUID      ElemType = 7
	ElemTypeReserved0 ElemType = 8
	ElemTypeReserved1 ElemType = 9
	ElemTypeReserved2 ElemType = 10
	ElemTypeReserved3 ElemType = 11
)

// ElemType_Values returns all recognized values of ElemType.
func ElemType_Values() []ElemType {
	return []ElemType{
		ElemTypeBool,
		ElemTypeBlob,
		ElemTypeString,
		ElemTypeInt32,
		ElemTypeInt64,
		ElemTypeDouble,
		ElemTypeTimestamp,
		ElemTypeUUID,
		ElemTypeReserved0,
		ElemTypeReserved1,
		ElemTypeReserved2,
		ElemTypeReserved3,
	}
}

// UnmarshalText tries to decode ElemType from a byte slice
// containing its name.
//
//   var v ElemType
//   err := v.UnmarshalText([]byte("BOOL"))
func (v *ElemType) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "BOOL":
		*v = ElemTypeBool
		return nil
	case "BLOB":
		*v = ElemTypeBlob
		return nil
	case "STRING":
		*v = ElemTypeString
		return nil
	case "INT32":
		*v = ElemTypeInt32
		return nil
	case "INT64":
		*v = ElemTypeInt64
		return nil
	case "DOUBLE":
		*v = ElemTypeDouble
		return nil
	case "TIMESTAMP":
		*v = ElemTypeTimestamp
		return nil
	case "UUID":
		*v = ElemTypeUUID
		return nil
	case "RESERVED0":
		*v = ElemTypeReserved0
		return nil
	case "RESERVED1":
		*v = ElemTypeReserved1
		return nil
	case "RESERVED2":
		*v = ElemTypeReserved2
		return nil
	case "RESERVED3":
		*v = ElemTypeReserved3
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "ElemType", err)
		}
		*v = ElemType(val)
		return nil
	}
}

// MarshalText encodes ElemType to text.
//
// If the enum value is recognized, its name is returned.
// Otherwise, its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v ElemType) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("BOOL"), nil
	case 1:
		return []byte("BLOB"), nil
	case 2:
		return []byte("STRING"), nil
	case 3:
		return []byte("INT32"), nil
	case 4:
		return []byte("INT64"), nil
	case 5:
		return []byte("DOUBLE"), nil
	case 6:
		return []byte("TIMESTAMP"), nil
	case 7:
		return []byte("UUID"), nil
	case 8:
		return []byte("RESERVED0"), nil
	case 9:
		return []byte("RESERVED1"), nil
	case 10:
		return []byte("RESERVED2"), nil
	case 11:
		return []byte("RESERVED3"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ElemType.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v ElemType) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "BOOL")
	case 1:
		enc.AddString("name", "BLOB")
	case 2:
		enc.AddString("name", "STRING")
	case 3:
		enc.AddString("name", "INT32")
	case 4:
		enc.AddString("name", "INT64")
	case 5:
		enc.AddString("name", "DOUBLE")
	case 6:
		enc.AddString("name", "TIMESTAMP")
	case 7:
		enc.AddString("name", "UUID")
	case 8:
		enc.AddString("name", "RESERVED0")
	case 9:
		enc.AddString("name", "RESERVED1")
	case 10:
		enc.AddString("name", "RESERVED2")
	case 11:
		enc.AddString("name", "RESERVED3")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v ElemType) Ptr() *ElemType {
	return &v
}

// Encode encodes ElemType directly to bytes.
//
//   sWriter := BinaryStreamer.Writer(writer)
//
//   var v ElemType
//   return v.Encode(sWriter)
func (v ElemType) Encode(sw stream.Writer) error {
	return sw.WriteInt32(int32(v))
}

// ToWire translates ElemType into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v ElemType) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes ElemType from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return ElemType(0), err
//   }
//
//   var v ElemType
//   if err := v.FromWire(x); err != nil {
//     return ElemType(0), err
//   }
//   return v, nil
func (v *ElemType) FromWire(w wire.Value) error {
	*v = (ElemType)(w.GetI32())
	return nil
}

// Decode reads off the encoded ElemType directly off of the wire.
//
//   sReader := BinaryStreamer.Reader(reader)
//
//   var v ElemType
//   if err := v.Decode(sReader); err != nil {
//     return ElemType(0), err
//   }
//   return v, nil
func (v *ElemType) Decode(sr stream.Reader) error {
	i, err := sr.ReadInt32()
	if err != nil {
		return err
	}
	*v = (ElemType)(i)
	return nil
}

// String returns a readable string representation of ElemType.
func (v ElemType) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "BOOL"
	case 1:
		return "BLOB"
	case 2:
		return "STRING"
	case 3:
		return "INT32"
	case 4:
		return "INT64"
	case 5:
		return "DOUBLE"
	case 6:
		return "TIMESTAMP"
	case 7:
		return "UUID"
	case 8:
		return "RESERVED0"
	case 9:
		return "RESERVED1"
	case 10:
		return "RESERVED2"
	case 11:
		return "RESERVED3"
	}
	return fmt.Sprintf("ElemType(%d)", w)
}

// Equals returns true if this ElemType value matches the provided
// value.
func (v ElemType) Equals(rhs ElemType) bool {
	return v == rhs
}

// MarshalJSON serializes ElemType into JSON.
//
// If the enum value is recognized, its name is returned.
// Otherwise, its integer value is returned.
//
// This implements json.Marshaler.
func (v ElemType) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"BOOL\""), nil
	case 1:
		return ([]byte)("\"BLOB\""), nil
	case 2:
		return ([]byte)("\"STRING\""), nil
	case 3:
		return ([]byte)("\"INT32\""), nil
	case 4:
		return ([]byte)("\"INT64\""), nil
	case 5:
		return ([]byte)("\"DOUBLE\""), nil
	case 6:
		return ([]byte)("\"TIMESTAMP\""), nil
	case 7:
		return ([]byte)("\"UUID\""), nil
	case 8:
		return ([]byte)("\"RESERVED0\""), nil
	case 9:
		return ([]byte)("\"RESERVED1\""), nil
	case 10:
		return ([]byte)("\"RESERVED2\""), nil
	case 11:
		return ([]byte)("\"RESERVED3\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode ElemType from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *ElemType) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "ElemType")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "ElemType")
		}
		*v = (ElemType)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "ElemType")
	}
}

type EntityDefinition struct {
	Name        *string                     `json:"name,omitempty"`
	FieldDescs  map[string]*FieldDesc       `json:"fieldDescs,omitempty"`
	PrimaryKey  *PrimaryKey                 `json:"primaryKey,omitempty"`
	Indexes     map[string]*IndexDefinition `json:"Indexes,omitempty"`
	Etl         *ETLState                   `json:"etl,omitempty"`
	ColumnOrder []string                    `json:"columnOrder,omitempty"`
}

type _Map_String_FieldDesc_MapItemList map[string]*FieldDesc

func (m _Map_String_FieldDesc_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid map 'map[string]*FieldDesc', key [%v]: value is nil", k)
		}
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_FieldDesc_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_FieldDesc_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_FieldDesc_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_String_FieldDesc_MapItemList) Close() {}

type _Map_String_IndexDefinition_MapItemList map[string]*IndexDefinition

func (m _Map_String_IndexDefinition_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid map 'map[string]*IndexDefinition', key [%v]: value is nil", k)
		}
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_IndexDefinition_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_IndexDefinition_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_IndexDefinition_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_String_IndexDefinition_MapItemList) Close() {}

type _List_String_ValueList []string

func (v _List_String_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_String_ValueList) Size() int {
	return len(v)
}

func (_List_String_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_List_String_ValueList) Close() {}

// ToWire translates a EntityDefinition struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *EntityDefinition) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.FieldDescs != nil {
		w, err = wire.NewValueMap(_Map_String_FieldDesc_MapItemList(v.FieldDescs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.PrimaryKey != nil {
		w, err = v.PrimaryKey.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Indexes != nil {
		w, err = wire.NewValueMap(_Map_String_IndexDefinition_MapItemList(v.Indexes)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Etl != nil {
		w, err = v.Etl.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.ColumnOrder != nil {
		w, err = wire.NewValueList(_List_String_ValueList(v.ColumnOrder)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _FieldDesc_Read(w wire.Value) (*FieldDesc, error) {
	var v FieldDesc
	err := v.FromWire(w)
	return &v, err
}

func _Map_String_FieldDesc_Read(m wire.MapItemList) (map[string]*FieldDesc, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make(map[string]*FieldDesc, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := _FieldDesc_Read(x.Value)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _PrimaryKey_Read(w wire.Value) (*PrimaryKey, error) {
	var v PrimaryKey
	err := v.FromWire(w)
	return &v, err
}

func _IndexDefinition_Read(w wire.Value) (*IndexDefinition, error) {
	var v IndexDefinition
	err := v.FromWire(w)
	return &v, err
}

func _Map_String_IndexDefinition_Read(m wire.MapItemList) (map[string]*IndexDefinition, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make(map[string]*IndexDefinition, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := _IndexDefinition_Read(x.Value)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _ETLState_Read(w wire.Value) (ETLState, error) {
	var v ETLState
	err := v.FromWire(w)
	return v, err
}

func _List_String_Read(l wire.ValueList) ([]string, error) {
	if l.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make([]string, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a EntityDefinition struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a EntityDefinition struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v EntityDefinition
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *EntityDefinition) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TMap {
				v.FieldDescs, err = _Map_String_FieldDesc_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.PrimaryKey, err = _PrimaryKey_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TMap {
				v.Indexes, err = _Map_String_IndexDefinition_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TI32 {
				var x ETLState
				x, err = _ETLState_Read(field.Value)
				v.Etl = &x
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TList {
				v.ColumnOrder, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

func _Map_String_FieldDesc_Encode(val map[string]*FieldDesc, sw stream.Writer) error {

	mh := stream.MapHeader{
		KeyType:   wire.TBinary,
		ValueType: wire.TStruct,
		Length:    len(val),
	}
	if err := sw.WriteMapBegin(mh); err != nil {
		return err
	}

	for k, v := range val {
		if v == nil {
			return fmt.Errorf("invalid map 'map[string]*FieldDesc', key [%v]: value is nil", k)
		}
		if err := sw.WriteString(k); err != nil {
			return err
		}
		if err := v.Encode(sw); err != nil {
			return err
		}
	}

	return sw.WriteMapEnd()
}

func _Map_String_IndexDefinition_Encode(val map[string]*IndexDefinition, sw stream.Writer) error {

	mh := stream.MapHeader{
		KeyType:   wire.TBinary,
		ValueType: wire.TStruct,
		Length:    len(val),
	}
	if err := sw.WriteMapBegin(mh); err != nil {
		return err
	}

	for k, v := range val {
		if v == nil {
			return fmt.Errorf("invalid map 'map[string]*IndexDefinition', key [%v]: value is nil", k)
		}
		if err := sw.WriteString(k); err != nil {
			return err
		}
		if err := v.Encode(sw); err != nil {
			return err
		}
	}

	return sw.WriteMapEnd()
}

func _List_String_Encode(val []string, sw stream.Writer) error {

	lh := stream.ListHeader{
		Type:   wire.TBinary,
		Length: len(val),
	}
	if err := sw.WriteListBegin(lh); err != nil {
		return err
	}

	for _, v := range val {
		if err := sw.WriteString(v); err != nil {
			return err
		}
	}
	return sw.WriteListEnd()
}

// Encode serializes a EntityDefinition struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a EntityDefinition struct could not be encoded.
func (v *EntityDefinition) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Name != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Name)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.FieldDescs != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TMap}); err != nil {
			return err
		}
		if err := _Map_String_FieldDesc_Encode(v.FieldDescs, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.PrimaryKey != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.PrimaryKey.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Indexes != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 4, Type: wire.TMap}); err != nil {
			return err
		}
		if err := _Map_String_IndexDefinition_Encode(v.Indexes, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Etl != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 5, Type: wire.TI32}); err != nil {
			return err
		}
		if err := v.Etl.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ColumnOrder != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 6, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_String_Encode(v.ColumnOrder, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _FieldDesc_Decode(sr stream.Reader) (*FieldDesc, error) {
	var v FieldDesc
	err := v.Decode(sr)
	return &v, err
}

func _Map_String_FieldDesc_Decode(sr stream.Reader) (map[string]*FieldDesc, error) {
	mh, err := sr.ReadMapBegin()
	if err != nil {
		return nil, err
	}

	if mh.KeyType != wire.TBinary || mh.ValueType != wire.TStruct {
		for i := 0; i < mh.Length; i++ {
			if err := sr.Skip(mh.KeyType); err != nil {
				return nil, err
			}

			if err := sr.Skip(mh.ValueType); err != nil {
				return nil, err
			}
		}
		return nil, sr.ReadMapEnd()
	}

	o := make(map[string]*FieldDesc, mh.Length)
	for i := 0; i < mh.Length; i++ {
		k, err := sr.ReadString()
		if err != nil {
			return nil, err
		}

		v, err := _FieldDesc_Decode(sr)
		if err != nil {
			return nil, err
		}

		o[k] = v
	}

	if err = sr.ReadMapEnd(); err != nil {
		return nil, err
	}
	return o, err
}

func _PrimaryKey_Decode(sr stream.Reader) (*PrimaryKey, error) {
	var v PrimaryKey
	err := v.Decode(sr)
	return &v, err
}

func _IndexDefinition_Decode(sr stream.Reader) (*IndexDefinition, error) {
	var v IndexDefinition
	err := v.Decode(sr)
	return &v, err
}

func _Map_String_IndexDefinition_Decode(sr stream.Reader) (map[string]*IndexDefinition, error) {
	mh, err := sr.ReadMapBegin()
	if err != nil {
		return nil, err
	}

	if mh.KeyType != wire.TBinary || mh.ValueType != wire.TStruct {
		for i := 0; i < mh.Length; i++ {
			if err := sr.Skip(mh.KeyType); err != nil {
				return nil, err
			}

			if err := sr.Skip(mh.ValueType); err != nil {
				return nil, err
			}
		}
		return nil, sr.ReadMapEnd()
	}

	o := make(map[string]*IndexDefinition, mh.Length)
	for i := 0; i < mh.Length; i++ {
		k, err := sr.ReadString()
		if err != nil {
			return nil, err
		}

		v, err := _IndexDefinition_Decode(sr)
		if err != nil {
			return nil, err
		}

		o[k] = v
	}

	if err = sr.ReadMapEnd(); err != nil {
		return nil, err
	}
	return o, err
}

func _ETLState_Decode(sr stream.Reader) (ETLState, error) {
	var v ETLState
	err := v.Decode(sr)
	return v, err
}

func _List_String_Decode(sr stream.Reader) ([]string, error) {
	lh, err := sr.ReadListBegin()
	if err != nil {
		return nil, err
	}

	if lh.Type != wire.TBinary {
		for i := 0; i < lh.Length; i++ {
			if err := sr.Skip(lh.Type); err != nil {
				return nil, err
			}
		}
		return nil, sr.ReadListEnd()
	}

	o := make([]string, 0, lh.Length)
	for i := 0; i < lh.Length; i++ {
		v, err := sr.ReadString()
		if err != nil {
			return nil, err
		}
		o = append(o, v)
	}

	if err = sr.ReadListEnd(); err != nil {
		return nil, err
	}
	return o, err
}

// Decode deserializes a EntityDefinition struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a EntityDefinition struct could not be generated from the wire
// representation.
func (v *EntityDefinition) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Name = &x
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TMap:
			v.FieldDescs, err = _Map_String_FieldDesc_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TStruct:
			v.PrimaryKey, err = _PrimaryKey_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 4 && fh.Type == wire.TMap:
			v.Indexes, err = _Map_String_IndexDefinition_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 5 && fh.Type == wire.TI32:
			var x ETLState
			x, err = _ETLState_Decode(sr)
			v.Etl = &x
			if err != nil {
				return err
			}

		case fh.ID == 6 && fh.Type == wire.TList:
			v.ColumnOrder, err = _List_String_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a EntityDefinition
// struct.
func (v *EntityDefinition) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.FieldDescs != nil {
		fields[i] = fmt.Sprintf("FieldDescs: %v", v.FieldDescs)
		i++
	}
	if v.PrimaryKey != nil {
		fields[i] = fmt.Sprintf("PrimaryKey: %v", v.PrimaryKey)
		i++
	}
	if v.Indexes != nil {
		fields[i] = fmt.Sprintf("Indexes: %v", v.Indexes)
		i++
	}
	if v.Etl != nil {
		fields[i] = fmt.Sprintf("Etl: %v", *(v.Etl))
		i++
	}
	if v.ColumnOrder != nil {
		fields[i] = fmt.Sprintf("ColumnOrder: %v", v.ColumnOrder)
		i++
	}

	return fmt.Sprintf("EntityDefinition{%v}", strings.Join(fields[:i], ", "))
}

func _Map_String_FieldDesc_Equals(lhs, rhs map[string]*FieldDesc) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

func _Map_String_IndexDefinition_Equals(lhs, rhs map[string]*IndexDefinition) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

func _ETLState_EqualsPtr(lhs, rhs *ETLState) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

func _List_String_Equals(lhs, rhs []string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this EntityDefinition match the
// provided EntityDefinition.
//
// This function performs a deep comparison.
func (v *EntityDefinition) Equals(rhs *EntityDefinition) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !((v.FieldDescs == nil && rhs.FieldDescs == nil) || (v.FieldDescs != nil && rhs.FieldDescs != nil && _Map_String_FieldDesc_Equals(v.FieldDescs, rhs.FieldDescs))) {
		return false
	}
	if !((v.PrimaryKey == nil && rhs.PrimaryKey == nil) || (v.PrimaryKey != nil && rhs.PrimaryKey != nil && v.PrimaryKey.Equals(rhs.PrimaryKey))) {
		return false
	}
	if !((v.Indexes == nil && rhs.Indexes == nil) || (v.Indexes != nil && rhs.Indexes != nil && _Map_String_IndexDefinition_Equals(v.Indexes, rhs.Indexes))) {
		return false
	}
	if !_ETLState_EqualsPtr(v.Etl, rhs.Etl) {
		return false
	}
	if !((v.ColumnOrder == nil && rhs.ColumnOrder == nil) || (v.ColumnOrder != nil && rhs.ColumnOrder != nil && _List_String_Equals(v.ColumnOrder, rhs.ColumnOrder))) {
		return false
	}

	return true
}

type _Map_String_FieldDesc_Zapper map[string]*FieldDesc

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_FieldDesc_Zapper.
func (m _Map_String_FieldDesc_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AddObject((string)(k), v))
	}
	return err
}

type _Map_String_IndexDefinition_Zapper map[string]*IndexDefinition

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_IndexDefinition_Zapper.
func (m _Map_String_IndexDefinition_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AddObject((string)(k), v))
	}
	return err
}

type _List_String_Zapper []string

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_String_Zapper.
func (l _List_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		enc.AppendString(v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of EntityDefinition.
func (v *EntityDefinition) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.FieldDescs != nil {
		err = multierr.Append(err, enc.AddObject("fieldDescs", (_Map_String_FieldDesc_Zapper)(v.FieldDescs)))
	}
	if v.PrimaryKey != nil {
		err = multierr.Append(err, enc.AddObject("primaryKey", v.PrimaryKey))
	}
	if v.Indexes != nil {
		err = multierr.Append(err, enc.AddObject("Indexes", (_Map_String_IndexDefinition_Zapper)(v.Indexes)))
	}
	if v.Etl != nil {
		err = multierr.Append(err, enc.AddObject("etl", *v.Etl))
	}
	if v.ColumnOrder != nil {
		err = multierr.Append(err, enc.AddArray("columnOrder", (_List_String_Zapper)(v.ColumnOrder)))
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *EntityDefinition) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *EntityDefinition) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetFieldDescs returns the value of FieldDescs if it is set or its
// zero value if it is unset.
func (v *EntityDefinition) GetFieldDescs() (o map[string]*FieldDesc) {
	if v != nil && v.FieldDescs != nil {
		return v.FieldDescs
	}

	return
}

// IsSetFieldDescs returns true if FieldDescs is not nil.
func (v *EntityDefinition) IsSetFieldDescs() bool {
	return v != nil && v.FieldDescs != nil
}

// GetPrimaryKey returns the value of PrimaryKey if it is set or its
// zero value if it is unset.
func (v *EntityDefinition) GetPrimaryKey() (o *PrimaryKey) {
	if v != nil && v.PrimaryKey != nil {
		return v.PrimaryKey
	}

	return
}

// IsSetPrimaryKey returns true if PrimaryKey is not nil.
func (v *EntityDefinition) IsSetPrimaryKey() bool {
	return v != nil && v.PrimaryKey != nil
}

// GetIndexes returns the value of Indexes if it is set or its
// zero value if it is unset.
func (v *EntityDefinition) GetIndexes() (o map[string]*IndexDefinition) {
	if v != nil && v.Indexes != nil {
		return v.Indexes
	}

	return
}

// IsSetIndexes returns true if Indexes is not nil.
func (v *EntityDefinition) IsSetIndexes() bool {
	return v != nil && v.Indexes != nil
}

// GetEtl returns the value of Etl if it is set or its
// zero value if it is unset.
func (v *EntityDefinition) GetEtl() (o ETLState) {
	if v != nil && v.Etl != nil {
		return *v.Etl
	}

	return
}

// IsSetEtl returns true if Etl is not nil.
func (v *EntityDefinition) IsSetEtl() bool {
	return v != nil && v.Etl != nil
}

// GetColumnOrder returns the value of ColumnOrder if it is set or its
// zero value if it is unset.
func (v *EntityDefinition) GetColumnOrder() (o []string) {
	if v != nil && v.ColumnOrder != nil {
		return v.ColumnOrder
	}

	return
}

// IsSetColumnOrder returns true if ColumnOrder is not nil.
func (v *EntityDefinition) IsSetColumnOrder() bool {
	return v != nil && v.ColumnOrder != nil
}

type EntityOrError struct {
	EntityValues FieldValueMap `json:"entityValues,omitempty"`
	Error        *Error        `json:"error,omitempty"`
}

// ToWire translates a EntityOrError struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *EntityOrError) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.EntityValues != nil {
		w, err = v.EntityValues.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Error != nil {
		w, err = v.Error.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("EntityOrError should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Error_Read(w wire.Value) (*Error, error) {
	var v Error
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a EntityOrError struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a EntityOrError struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v EntityOrError
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *EntityOrError) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.EntityValues, err = _FieldValueMap_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Error, err = _Error_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.EntityValues != nil {
		count++
	}
	if v.Error != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("EntityOrError should have exactly one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a EntityOrError struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a EntityOrError struct could not be encoded.
func (v *EntityOrError) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.EntityValues != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TMap}); err != nil {
			return err
		}
		if err := v.EntityValues.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Error != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Error.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.EntityValues != nil {
		count++
	}
	if v.Error != nil {
		count++
	}

	if count != 1 {
		return fmt.Errorf("EntityOrError should have exactly one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

func _Error_Decode(sr stream.Reader) (*Error, error) {
	var v Error
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a EntityOrError struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a EntityOrError struct could not be generated from the wire
// representation.
func (v *EntityOrError) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TMap:
			v.EntityValues, err = _FieldValueMap_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.Error, err = _Error_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.EntityValues != nil {
		count++
	}
	if v.Error != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("EntityOrError should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a EntityOrError
// struct.
func (v *EntityOrError) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.EntityValues != nil {
		fields[i] = fmt.Sprintf("EntityValues: %v", v.EntityValues)
		i++
	}
	if v.Error != nil {
		fields[i] = fmt.Sprintf("Error: %v", v.Error)
		i++
	}

	return fmt.Sprintf("EntityOrError{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this EntityOrError match the
// provided EntityOrError.
//
// This function performs a deep comparison.
func (v *EntityOrError) Equals(rhs *EntityOrError) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.EntityValues == nil && rhs.EntityValues == nil) || (v.EntityValues != nil && rhs.EntityValues != nil && v.EntityValues.Equals(rhs.EntityValues))) {
		return false
	}
	if !((v.Error == nil && rhs.Error == nil) || (v.Error != nil && rhs.Error != nil && v.Error.Equals(rhs.Error))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of EntityOrError.
func (v *EntityOrError) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.EntityValues != nil {
		err = multierr.Append(err, enc.AddObject("entityValues", (_Map_String_Value_Zapper)(v.EntityValues)))
	}
	if v.Error != nil {
		err = multierr.Append(err, enc.AddObject("error", v.Error))
	}
	return err
}

// GetEntityValues returns the value of EntityValues if it is set or its
// zero value if it is unset.
func (v *EntityOrError) GetEntityValues() (o FieldValueMap) {
	if v != nil && v.EntityValues != nil {
		return v.EntityValues
	}

	return
}

// IsSetEntityValues returns true if EntityValues is not nil.
func (v *EntityOrError) IsSetEntityValues() bool {
	return v != nil && v.EntityValues != nil
}

// GetError returns the value of Error if it is set or its
// zero value if it is unset.
func (v *EntityOrError) GetError() (o *Error) {
	if v != nil && v.Error != nil {
		return v.Error
	}

	return
}

// IsSetError returns true if Error is not nil.
func (v *EntityOrError) IsSetError() bool {
	return v != nil && v.Error != nil
}

type Error struct {
	ErrCode     *int32  `json:"errCode,omitempty"`
	Msg         *string `json:"msg,omitempty"`
	ShouldRetry *bool   `json:"shouldRetry,omitempty"`
}

// ToWire translates a Error struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Error) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ErrCode != nil {
		w, err = wire.NewValueI32(*(v.ErrCode)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Msg != nil {
		w, err = wire.NewValueString(*(v.Msg)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.ShouldRetry != nil {
		w, err = wire.NewValueBool(*(v.ShouldRetry)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Error struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Error struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Error
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Error) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ErrCode = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Msg = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.ShouldRetry = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Error struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Error struct could not be encoded.
func (v *Error) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.ErrCode != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.ErrCode)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Msg != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Msg)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ShouldRetry != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TBool}); err != nil {
			return err
		}
		if err := sw.WriteBool(*(v.ShouldRetry)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a Error struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Error struct could not be generated from the wire
// representation.
func (v *Error) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.ErrCode = &x
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Msg = &x
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TBool:
			var x bool
			x, err = sr.ReadBool()
			v.ShouldRetry = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Error
// struct.
func (v *Error) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.ErrCode != nil {
		fields[i] = fmt.Sprintf("ErrCode: %v", *(v.ErrCode))
		i++
	}
	if v.Msg != nil {
		fields[i] = fmt.Sprintf("Msg: %v", *(v.Msg))
		i++
	}
	if v.ShouldRetry != nil {
		fields[i] = fmt.Sprintf("ShouldRetry: %v", *(v.ShouldRetry))
		i++
	}

	return fmt.Sprintf("Error{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Error match the
// provided Error.
//
// This function performs a deep comparison.
func (v *Error) Equals(rhs *Error) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.ErrCode, rhs.ErrCode) {
		return false
	}
	if !_String_EqualsPtr(v.Msg, rhs.Msg) {
		return false
	}
	if !_Bool_EqualsPtr(v.ShouldRetry, rhs.ShouldRetry) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Error.
func (v *Error) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ErrCode != nil {
		enc.AddInt32("errCode", *v.ErrCode)
	}
	if v.Msg != nil {
		enc.AddString("msg", *v.Msg)
	}
	if v.ShouldRetry != nil {
		enc.AddBool("shouldRetry", *v.ShouldRetry)
	}
	return err
}

// GetErrCode returns the value of ErrCode if it is set or its
// zero value if it is unset.
func (v *Error) GetErrCode() (o int32) {
	if v != nil && v.ErrCode != nil {
		return *v.ErrCode
	}

	return
}

// IsSetErrCode returns true if ErrCode is not nil.
func (v *Error) IsSetErrCode() bool {
	return v != nil && v.ErrCode != nil
}

// GetMsg returns the value of Msg if it is set or its
// zero value if it is unset.
func (v *Error) GetMsg() (o string) {
	if v != nil && v.Msg != nil {
		return *v.Msg
	}

	return
}

// IsSetMsg returns true if Msg is not nil.
func (v *Error) IsSetMsg() bool {
	return v != nil && v.Msg != nil
}

// GetShouldRetry returns the value of ShouldRetry if it is set or its
// zero value if it is unset.
func (v *Error) GetShouldRetry() (o bool) {
	if v != nil && v.ShouldRetry != nil {
		return *v.ShouldRetry
	}

	return
}

// IsSetShouldRetry returns true if ShouldRetry is not nil.
func (v *Error) IsSetShouldRetry() bool {
	return v != nil && v.ShouldRetry != nil
}

type Field struct {
	Name  *string `json:"name,omitempty"`
	Value *Value  `json:"value,omitempty"`
}

// ToWire translates a Field struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Field) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Value != nil {
		w, err = v.Value.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Value_Read(w wire.Value) (*Value, error) {
	var v Value
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Field struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Field struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Field
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Field) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Value, err = _Value_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Field struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Field struct could not be encoded.
func (v *Field) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Name != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Name)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Value != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Value.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _Value_Decode(sr stream.Reader) (*Value, error) {
	var v Value
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Field struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Field struct could not be generated from the wire
// representation.
func (v *Field) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Name = &x
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.Value, err = _Value_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Field
// struct.
func (v *Field) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Value != nil {
		fields[i] = fmt.Sprintf("Value: %v", v.Value)
		i++
	}

	return fmt.Sprintf("Field{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Field match the
// provided Field.
//
// This function performs a deep comparison.
func (v *Field) Equals(rhs *Field) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !((v.Value == nil && rhs.Value == nil) || (v.Value != nil && rhs.Value != nil && v.Value.Equals(rhs.Value))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Field.
func (v *Field) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.Value != nil {
		err = multierr.Append(err, enc.AddObject("value", v.Value))
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *Field) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *Field) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetValue returns the value of Value if it is set or its
// zero value if it is unset.
func (v *Field) GetValue() (o *Value) {
	if v != nil && v.Value != nil {
		return v.Value
	}

	return
}

// IsSetValue returns true if Value is not nil.
func (v *Field) IsSetValue() bool {
	return v != nil && v.Value != nil
}

type FieldDesc struct {
	Type *ElemType   `json:"type,omitempty"`
	Tags []*FieldTag `json:"tags,omitempty"`
}

type _Set_FieldTag_sliceType_ValueList []*FieldTag

func (v _Set_FieldTag_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set '*FieldTag': contains nil value")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_FieldTag_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_FieldTag_sliceType_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_FieldTag_sliceType_ValueList) Close() {}

// ToWire translates a FieldDesc struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *FieldDesc) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Type != nil {
		w, err = v.Type.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Tags != nil {
		w, err = wire.NewValueSet(_Set_FieldTag_sliceType_ValueList(v.Tags)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ElemType_Read(w wire.Value) (ElemType, error) {
	var v ElemType
	err := v.FromWire(w)
	return v, err
}

func _FieldTag_Read(w wire.Value) (*FieldTag, error) {
	var v FieldTag
	err := v.FromWire(w)
	return &v, err
}

func _Set_FieldTag_sliceType_Read(s wire.ValueList) ([]*FieldTag, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*FieldTag, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _FieldTag_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

// FromWire deserializes a FieldDesc struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a FieldDesc struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v FieldDesc
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *FieldDesc) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x ElemType
				x, err = _ElemType_Read(field.Value)
				v.Type = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TSet {
				v.Tags, err = _Set_FieldTag_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

func _Set_FieldTag_sliceType_Encode(val []*FieldTag, sw stream.Writer) error {

	sh := stream.SetHeader{
		Type:   wire.TStruct,
		Length: len(val),
	}

	if err := sw.WriteSetBegin(sh); err != nil {
		return err
	}

	for _, v := range val {
		if v == nil {
			return fmt.Errorf("invalid set '*FieldTag': contains nil value")
		}

		if err := v.Encode(sw); err != nil {
			return err
		}
	}
	return sw.WriteSetEnd()
}

// Encode serializes a FieldDesc struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a FieldDesc struct could not be encoded.
func (v *FieldDesc) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Type != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TI32}); err != nil {
			return err
		}
		if err := v.Type.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Tags != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TSet}); err != nil {
			return err
		}
		if err := _Set_FieldTag_sliceType_Encode(v.Tags, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _ElemType_Decode(sr stream.Reader) (ElemType, error) {
	var v ElemType
	err := v.Decode(sr)
	return v, err
}

func _FieldTag_Decode(sr stream.Reader) (*FieldTag, error) {
	var v FieldTag
	err := v.Decode(sr)
	return &v, err
}

func _Set_FieldTag_sliceType_Decode(sr stream.Reader) ([]*FieldTag, error) {
	sh, err := sr.ReadSetBegin()
	if err != nil {
		return nil, err
	}

	if sh.Type != wire.TStruct {
		for i := 0; i < sh.Length; i++ {
			if err := sr.Skip(sh.Type); err != nil {
				return nil, err
			}
		}
		return nil, sr.ReadSetEnd()
	}

	o := make([]*FieldTag, 0, sh.Length)
	for i := 0; i < sh.Length; i++ {
		v, err := _FieldTag_Decode(sr)
		if err != nil {
			return nil, err
		}

		o = append(o, v)
	}

	if err = sr.ReadSetEnd(); err != nil {
		return nil, err
	}
	return o, err
}

// Decode deserializes a FieldDesc struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a FieldDesc struct could not be generated from the wire
// representation.
func (v *FieldDesc) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TI32:
			var x ElemType
			x, err = _ElemType_Decode(sr)
			v.Type = &x
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TSet:
			v.Tags, err = _Set_FieldTag_sliceType_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a FieldDesc
// struct.
func (v *FieldDesc) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Type != nil {
		fields[i] = fmt.Sprintf("Type: %v", *(v.Type))
		i++
	}
	if v.Tags != nil {
		fields[i] = fmt.Sprintf("Tags: %v", v.Tags)
		i++
	}

	return fmt.Sprintf("FieldDesc{%v}", strings.Join(fields[:i], ", "))
}

func _ElemType_EqualsPtr(lhs, rhs *ElemType) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

func _Set_FieldTag_sliceType_Equals(lhs, rhs []*FieldTag) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this FieldDesc match the
// provided FieldDesc.
//
// This function performs a deep comparison.
func (v *FieldDesc) Equals(rhs *FieldDesc) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_ElemType_EqualsPtr(v.Type, rhs.Type) {
		return false
	}
	if !((v.Tags == nil && rhs.Tags == nil) || (v.Tags != nil && rhs.Tags != nil && _Set_FieldTag_sliceType_Equals(v.Tags, rhs.Tags))) {
		return false
	}

	return true
}

type _Set_FieldTag_sliceType_Zapper []*FieldTag

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_FieldTag_sliceType_Zapper.
func (s _Set_FieldTag_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of FieldDesc.
func (v *FieldDesc) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Type != nil {
		err = multierr.Append(err, enc.AddObject("type", *v.Type))
	}
	if v.Tags != nil {
		err = multierr.Append(err, enc.AddArray("tags", (_Set_FieldTag_sliceType_Zapper)(v.Tags)))
	}
	return err
}

// GetType returns the value of Type if it is set or its
// zero value if it is unset.
func (v *FieldDesc) GetType() (o ElemType) {
	if v != nil && v.Type != nil {
		return *v.Type
	}

	return
}

// IsSetType returns true if Type is not nil.
func (v *FieldDesc) IsSetType() bool {
	return v != nil && v.Type != nil
}

// GetTags returns the value of Tags if it is set or its
// zero value if it is unset.
func (v *FieldDesc) GetTags() (o []*FieldTag) {
	if v != nil && v.Tags != nil {
		return v.Tags
	}

	return
}

// IsSetTags returns true if Tags is not nil.
func (v *FieldDesc) IsSetTags() bool {
	return v != nil && v.Tags != nil
}

type FieldTag struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// ToWire translates a FieldTag struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *FieldTag) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Value != nil {
		w, err = wire.NewValueString(*(v.Value)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a FieldTag struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a FieldTag struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v FieldTag
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *FieldTag) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Value = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a FieldTag struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a FieldTag struct could not be encoded.
func (v *FieldTag) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Name != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Name)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Value != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Value)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a FieldTag struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a FieldTag struct could not be generated from the wire
// representation.
func (v *FieldTag) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Name = &x
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Value = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a FieldTag
// struct.
func (v *FieldTag) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Value != nil {
		fields[i] = fmt.Sprintf("Value: %v", *(v.Value))
		i++
	}

	return fmt.Sprintf("FieldTag{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this FieldTag match the
// provided FieldTag.
//
// This function performs a deep comparison.
func (v *FieldTag) Equals(rhs *FieldTag) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !_String_EqualsPtr(v.Value, rhs.Value) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of FieldTag.
func (v *FieldTag) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.Value != nil {
		enc.AddString("value", *v.Value)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *FieldTag) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *FieldTag) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetValue returns the value of Value if it is set or its
// zero value if it is unset.
func (v *FieldTag) GetValue() (o string) {
	if v != nil && v.Value != nil {
		return *v.Value
	}

	return
}

// IsSetValue returns true if Value is not nil.
func (v *FieldTag) IsSetValue() bool {
	return v != nil && v.Value != nil
}

type _Map_String_Value_MapItemList map[string]*Value

func (m _Map_String_Value_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid map 'map[string]*Value', key [%v]: value is nil", k)
		}
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_Value_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_Value_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_Value_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_String_Value_MapItemList) Close() {}

func _Map_String_Value_Encode(val map[string]*Value, sw stream.Writer) error {

	mh := stream.MapHeader{
		KeyType:   wire.TBinary,
		ValueType: wire.TStruct,
		Length:    len(val),
	}
	if err := sw.WriteMapBegin(mh); err != nil {
		return err
	}

	for k, v := range val {
		if v == nil {
			return fmt.Errorf("invalid map 'map[string]*Value', key [%v]: value is nil", k)
		}
		if err := sw.WriteString(k); err != nil {
			return err
		}
		if err := v.Encode(sw); err != nil {
			return err
		}
	}

	return sw.WriteMapEnd()
}

func _Map_String_Value_Read(m wire.MapItemList) (map[string]*Value, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make(map[string]*Value, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := _Value_Read(x.Value)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Map_String_Value_Decode(sr stream.Reader) (map[string]*Value, error) {
	mh, err := sr.ReadMapBegin()
	if err != nil {
		return nil, err
	}

	if mh.KeyType != wire.TBinary || mh.ValueType != wire.TStruct {
		for i := 0; i < mh.Length; i++ {
			if err := sr.Skip(mh.KeyType); err != nil {
				return nil, err
			}

			if err := sr.Skip(mh.ValueType); err != nil {
				return nil, err
			}
		}
		return nil, sr.ReadMapEnd()
	}

	o := make(map[string]*Value, mh.Length)
	for i := 0; i < mh.Length; i++ {
		k, err := sr.ReadString()
		if err != nil {
			return nil, err
		}

		v, err := _Value_Decode(sr)
		if err != nil {
			return nil, err
		}

		o[k] = v
	}

	if err = sr.ReadMapEnd(); err != nil {
		return nil, err
	}
	return o, err
}

func _Map_String_Value_Equals(lhs, rhs map[string]*Value) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

type FieldValueMap map[string]*Value

// ToWire translates FieldValueMap into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v FieldValueMap) ToWire() (wire.Value, error) {
	x := (map[string]*Value)(v)
	return wire.NewValueMap(_Map_String_Value_MapItemList(x)), error(nil)
}

// String returns a readable string representation of FieldValueMap.
func (v FieldValueMap) String() string {
	x := (map[string]*Value)(v)
	return fmt.Sprint(x)
}

func (v FieldValueMap) Encode(sw stream.Writer) error {
	x := (map[string]*Value)(v)
	return _Map_String_Value_Encode(x, sw)
}

// FromWire deserializes FieldValueMap from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *FieldValueMap) FromWire(w wire.Value) error {
	x, err := _Map_String_Value_Read(w.GetMap())
	*v = (FieldValueMap)(x)
	return err
}

// Decode deserializes FieldValueMap directly off the wire.
func (v *FieldValueMap) Decode(sr stream.Reader) error {
	x, err := _Map_String_Value_Decode(sr)
	*v = (FieldValueMap)(x)
	return err
}

// Equals returns true if this FieldValueMap is equal to the provided
// FieldValueMap.
func (lhs FieldValueMap) Equals(rhs FieldValueMap) bool {
	return _Map_String_Value_Equals((map[string]*Value)(lhs), (map[string]*Value)(rhs))
}

func (v FieldValueMap) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	return ((_Map_String_Value_Zapper)((map[string]*Value)(v))).MarshalLogObject(enc)
}

type IndexDefinition struct {
	Key     *PrimaryKey `json:"key,omitempty"`
	Columns []string    `json:"columns,omitempty"`
	Defunct *bool       `json:"defunct,omitempty"`
}

// ToWire translates a IndexDefinition struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *IndexDefinition) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Key != nil {
		w, err = v.Key.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Columns != nil {
		w, err = wire.NewValueList(_List_String_ValueList(v.Columns)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Defunct != nil {
		w, err = wire.NewValueBool(*(v.Defunct)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a IndexDefinition struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a IndexDefinition struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v IndexDefinition
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *IndexDefinition) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Key, err = _PrimaryKey_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TList {
				v.Columns, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.Defunct = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a IndexDefinition struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a IndexDefinition struct could not be encoded.
func (v *IndexDefinition) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Key != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Key.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Columns != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_String_Encode(v.Columns, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Defunct != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TBool}); err != nil {
			return err
		}
		if err := sw.WriteBool(*(v.Defunct)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a IndexDefinition struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a IndexDefinition struct could not be generated from the wire
// representation.
func (v *IndexDefinition) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Key, err = _PrimaryKey_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TList:
			v.Columns, err = _List_String_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TBool:
			var x bool
			x, err = sr.ReadBool()
			v.Defunct = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a IndexDefinition
// struct.
func (v *IndexDefinition) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Key != nil {
		fields[i] = fmt.Sprintf("Key: %v", v.Key)
		i++
	}
	if v.Columns != nil {
		fields[i] = fmt.Sprintf("Columns: %v", v.Columns)
		i++
	}
	if v.Defunct != nil {
		fields[i] = fmt.Sprintf("Defunct: %v", *(v.Defunct))
		i++
	}

	return fmt.Sprintf("IndexDefinition{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this IndexDefinition match the
// provided IndexDefinition.
//
// This function performs a deep comparison.
func (v *IndexDefinition) Equals(rhs *IndexDefinition) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Key == nil && rhs.Key == nil) || (v.Key != nil && rhs.Key != nil && v.Key.Equals(rhs.Key))) {
		return false
	}
	if !((v.Columns == nil && rhs.Columns == nil) || (v.Columns != nil && rhs.Columns != nil && _List_String_Equals(v.Columns, rhs.Columns))) {
		return false
	}
	if !_Bool_EqualsPtr(v.Defunct, rhs.Defunct) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of IndexDefinition.
func (v *IndexDefinition) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Key != nil {
		err = multierr.Append(err, enc.AddObject("key", v.Key))
	}
	if v.Columns != nil {
		err = multierr.Append(err, enc.AddArray("columns", (_List_String_Zapper)(v.Columns)))
	}
	if v.Defunct != nil {
		enc.AddBool("defunct", *v.Defunct)
	}
	return err
}

// GetKey returns the value of Key if it is set or its
// zero value if it is unset.
func (v *IndexDefinition) GetKey() (o *PrimaryKey) {
	if v != nil && v.Key != nil {
		return v.Key
	}

	return
}

// IsSetKey returns true if Key is not nil.
func (v *IndexDefinition) IsSetKey() bool {
	return v != nil && v.Key != nil
}

// GetColumns returns the value of Columns if it is set or its
// zero value if it is unset.
func (v *IndexDefinition) GetColumns() (o []string) {
	if v != nil && v.Columns != nil {
		return v.Columns
	}

	return
}

// IsSetColumns returns true if Columns is not nil.
func (v *IndexDefinition) IsSetColumns() bool {
	return v != nil && v.Columns != nil
}

// GetDefunct returns the value of Defunct if it is set or its
// zero value if it is unset.
func (v *IndexDefinition) GetDefunct() (o bool) {
	if v != nil && v.Defunct != nil {
		return *v.Defunct
	}

	return
}

// IsSetDefunct returns true if Defunct is not nil.
func (v *IndexDefinition) IsSetDefunct() bool {
	return v != nil && v.Defunct != nil
}

type InternalServerError struct {
	Err       string  `json:"err,required"`
	Message   *string `json:"message,omitempty"`
	ErrorCode *int32  `json:"errorCode,omitempty"`
}

// ToWire translates a InternalServerError struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *InternalServerError) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Err), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Message != nil {
		w, err = wire.NewValueString(*(v.Message)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.ErrorCode != nil {
		w, err = wire.NewValueI32(*(v.ErrorCode)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a InternalServerError struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a InternalServerError struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v InternalServerError
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *InternalServerError) FromWire(w wire.Value) error {
	var err error

	errIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Err, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				errIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Message = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ErrorCode = &x
				if err != nil {
					return err
				}

			}
		}
	}

	if !errIsSet {
		return errors.New("field Err of InternalServerError is required")
	}

	return nil
}

// Encode serializes a InternalServerError struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a InternalServerError struct could not be encoded.
func (v *InternalServerError) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
		return err
	}
	if err := sw.WriteString(v.Err); err != nil {
		return err
	}
	if err := sw.WriteFieldEnd(); err != nil {
		return err
	}

	if v.Message != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Message)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ErrorCode != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.ErrorCode)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a InternalServerError struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a InternalServerError struct could not be generated from the wire
// representation.
func (v *InternalServerError) Decode(sr stream.Reader) error {

	errIsSet := false

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TBinary:
			v.Err, err = sr.ReadString()
			if err != nil {
				return err
			}
			errIsSet = true
		case fh.ID == 2 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Message = &x
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.ErrorCode = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	if !errIsSet {
		return errors.New("field Err of InternalServerError is required")
	}

	return nil
}

// String returns a readable string representation of a InternalServerError
// struct.
func (v *InternalServerError) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	fields[i] = fmt.Sprintf("Err: %v", v.Err)
	i++
	if v.Message != nil {
		fields[i] = fmt.Sprintf("Message: %v", *(v.Message))
		i++
	}
	if v.ErrorCode != nil {
		fields[i] = fmt.Sprintf("ErrorCode: %v", *(v.ErrorCode))
		i++
	}

	return fmt.Sprintf("InternalServerError{%v}", strings.Join(fields[:i], ", "))
}

// ErrorName is the name of this type as defined in the Thrift
// file.
func (*InternalServerError) ErrorName() string {
	return "InternalServerError"
}

// Equals returns true if all the fields of this InternalServerError match the
// provided InternalServerError.
//
// This function performs a deep comparison.
func (v *InternalServerError) Equals(rhs *InternalServerError) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Err == rhs.Err) {
		return false
	}
	if !_String_EqualsPtr(v.Message, rhs.Message) {
		return false
	}
	if !_I32_EqualsPtr(v.ErrorCode, rhs.ErrorCode) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of InternalServerError.
func (v *InternalServerError) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("err", v.Err)
	if v.Message != nil {
		enc.AddString("message", *v.Message)
	}
	if v.ErrorCode != nil {
		enc.AddInt32("errorCode", *v.ErrorCode)
	}
	return err
}

// GetErr returns the value of Err if it is set or its
// zero value if it is unset.
func (v *InternalServerError) GetErr() (o string) {
	if v != nil {
		o = v.Err
	}
	return
}

// GetMessage returns the value of Message if it is set or its
// zero value if it is unset.
func (v *InternalServerError) GetMessage() (o string) {
	if v != nil && v.Message != nil {
		return *v.Message
	}

	return
}

// IsSetMessage returns true if Message is not nil.
func (v *InternalServerError) IsSetMessage() bool {
	return v != nil && v.Message != nil
}

// GetErrorCode returns the value of ErrorCode if it is set or its
// zero value if it is unset.
func (v *InternalServerError) GetErrorCode() (o int32) {
	if v != nil && v.ErrorCode != nil {
		return *v.ErrorCode
	}

	return
}

// IsSetErrorCode returns true if ErrorCode is not nil.
func (v *InternalServerError) IsSetErrorCode() bool {
	return v != nil && v.ErrorCode != nil
}

func (v *InternalServerError) Error() string {
	return v.String()
}

type MultiReadRequest struct {
	Ref          *SchemaRef          `json:"ref,omitempty"`
	KeyValues    []FieldValueMap     `json:"keyValues,omitempty"`
	FieldsToRead map[string]struct{} `json:"fieldsToRead,omitempty"`
}

type _List_FieldValueMap_ValueList []FieldValueMap

func (v _List_FieldValueMap_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid list '[]FieldValueMap', index [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_FieldValueMap_ValueList) Size() int {
	return len(v)
}

func (_List_FieldValueMap_ValueList) ValueType() wire.Type {
	return wire.TMap
}

func (_List_FieldValueMap_ValueList) Close() {}

type _Set_String_mapType_ValueList map[string]struct{}

func (v _Set_String_mapType_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_String_mapType_ValueList) Size() int {
	return len(v)
}

func (_Set_String_mapType_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Set_String_mapType_ValueList) Close() {}

// ToWire translates a MultiReadRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *MultiReadRequest) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Ref != nil {
		w, err = v.Ref.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.KeyValues != nil {
		w, err = wire.NewValueList(_List_FieldValueMap_ValueList(v.KeyValues)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.FieldsToRead != nil {
		w, err = wire.NewValueSet(_Set_String_mapType_ValueList(v.FieldsToRead)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_FieldValueMap_Read(l wire.ValueList) ([]FieldValueMap, error) {
	if l.ValueType() != wire.TMap {
		return nil, nil
	}

	o := make([]FieldValueMap, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _FieldValueMap_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _Set_String_mapType_Read(s wire.ValueList) (map[string]struct{}, error) {
	if s.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string]struct{}, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}

		o[i] = struct{}{}
		return nil
	})
	s.Close()
	return o, err
}

// FromWire deserializes a MultiReadRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a MultiReadRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v MultiReadRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *MultiReadRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Ref, err = _SchemaRef_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TList {
				v.KeyValues, err = _List_FieldValueMap_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TSet {
				v.FieldsToRead, err = _Set_String_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

func _List_FieldValueMap_Encode(val []FieldValueMap, sw stream.Writer) error {

	lh := stream.ListHeader{
		Type:   wire.TMap,
		Length: len(val),
	}
	if err := sw.WriteListBegin(lh); err != nil {
		return err
	}

	for i, v := range val {
		if v == nil {
			return fmt.Errorf("invalid list '[]FieldValueMap', index [%v]: value is nil", i)
		}
		if err := v.Encode(sw); err != nil {
			return err
		}
	}
	return sw.WriteListEnd()
}

func _Set_String_mapType_Encode(val map[string]struct{}, sw stream.Writer) error {

	sh := stream.SetHeader{
		Type:   wire.TBinary,
		Length: len(val),
	}

	if err := sw.WriteSetBegin(sh); err != nil {
		return err
	}

	for v, _ := range val {

		if err := sw.WriteString(v); err != nil {
			return err
		}
	}
	return sw.WriteSetEnd()
}

// Encode serializes a MultiReadRequest struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a MultiReadRequest struct could not be encoded.
func (v *MultiReadRequest) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Ref != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Ref.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.KeyValues != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_FieldValueMap_Encode(v.KeyValues, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.FieldsToRead != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TSet}); err != nil {
			return err
		}
		if err := _Set_String_mapType_Encode(v.FieldsToRead, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _List_FieldValueMap_Decode(sr stream.Reader) ([]FieldValueMap, error) {
	lh, err := sr.ReadListBegin()
	if err != nil {
		return nil, err
	}

	if lh.Type != wire.TMap {
		for i := 0; i < lh.Length; i++ {
			if err := sr.Skip(lh.Type); err != nil {
				return nil, err
			}
		}
		return nil, sr.ReadListEnd()
	}

	o := make([]FieldValueMap, 0, lh.Length)
	for i := 0; i < lh.Length; i++ {
		v, err := _FieldValueMap_Decode(sr)
		if err != nil {
			return nil, err
		}
		o = append(o, v)
	}

	if err = sr.ReadListEnd(); err != nil {
		return nil, err
	}
	return o, err
}

func _Set_String_mapType_Decode(sr stream.Reader) (map[string]struct{}, error) {
	sh, err := sr.ReadSetBegin()
	if err != nil {
		return nil, err
	}

	if sh.Type != wire.TBinary {
		for i := 0; i < sh.Length; i++ {
			if err := sr.Skip(sh.Type); err != nil {
				return nil, err
			}
		}
		return nil, sr.ReadSetEnd()
	}

	o := make(map[string]struct{}, sh.Length)
	for i := 0; i < sh.Length; i++ {
		v, err := sr.ReadString()
		if err != nil {
			return nil, err
		}

		o[v] = struct{}{}
	}

	if err = sr.ReadSetEnd(); err != nil {
		return nil, err
	}
	return o, err
}

// Decode deserializes a MultiReadRequest struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a MultiReadRequest struct could not be generated from the wire
// representation.
func (v *MultiReadRequest) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Ref, err = _SchemaRef_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TList:
			v.KeyValues, err = _List_FieldValueMap_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TSet:
			v.FieldsToRead, err = _Set_String_mapType_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a MultiReadRequest
// struct.
func (v *MultiReadRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Ref != nil {
		fields[i] = fmt.Sprintf("Ref: %v", v.Ref)
		i++
	}
	if v.KeyValues != nil {
		fields[i] = fmt.Sprintf("KeyValues: %v", v.KeyValues)
		i++
	}
	if v.FieldsToRead != nil {
		fields[i] = fmt.Sprintf("FieldsToRead: %v", v.FieldsToRead)
		i++
	}

	return fmt.Sprintf("MultiReadRequest{%v}", strings.Join(fields[:i], ", "))
}

func _List_FieldValueMap_Equals(lhs, rhs []FieldValueMap) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

func _Set_String_mapType_Equals(lhs, rhs map[string]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for x := range rhs {
		if _, ok := lhs[x]; !ok {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this MultiReadRequest match the
// provided MultiReadRequest.
//
// This function performs a deep comparison.
func (v *MultiReadRequest) Equals(rhs *MultiReadRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Ref == nil && rhs.Ref == nil) || (v.Ref != nil && rhs.Ref != nil && v.Ref.Equals(rhs.Ref))) {
		return false
	}
	if !((v.KeyValues == nil && rhs.KeyValues == nil) || (v.KeyValues != nil && rhs.KeyValues != nil && _List_FieldValueMap_Equals(v.KeyValues, rhs.KeyValues))) {
		return false
	}
	if !((v.FieldsToRead == nil && rhs.FieldsToRead == nil) || (v.FieldsToRead != nil && rhs.FieldsToRead != nil && _Set_String_mapType_Equals(v.FieldsToRead, rhs.FieldsToRead))) {
		return false
	}

	return true
}

type _List_FieldValueMap_Zapper []FieldValueMap

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_FieldValueMap_Zapper.
func (l _List_FieldValueMap_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject((_Map_String_Value_Zapper)(v)))
	}
	return err
}

type _Set_String_mapType_Zapper map[string]struct{}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_String_mapType_Zapper.
func (s _Set_String_mapType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for v := range s {
		enc.AppendString(v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of MultiReadRequest.
func (v *MultiReadRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Ref != nil {
		err = multierr.Append(err, enc.AddObject("ref", v.Ref))
	}
	if v.KeyValues != nil {
		err = multierr.Append(err, enc.AddArray("keyValues", (_List_FieldValueMap_Zapper)(v.KeyValues)))
	}
	if v.FieldsToRead != nil {
		err = multierr.Append(err, enc.AddArray("fieldsToRead", (_Set_String_mapType_Zapper)(v.FieldsToRead)))
	}
	return err
}

// GetRef returns the value of Ref if it is set or its
// zero value if it is unset.
func (v *MultiReadRequest) GetRef() (o *SchemaRef) {
	if v != nil && v.Ref != nil {
		return v.Ref
	}

	return
}

// IsSetRef returns true if Ref is not nil.
func (v *MultiReadRequest) IsSetRef() bool {
	return v != nil && v.Ref != nil
}

// GetKeyValues returns the value of KeyValues if it is set or its
// zero value if it is unset.
func (v *MultiReadRequest) GetKeyValues() (o []FieldValueMap) {
	if v != nil && v.KeyValues != nil {
		return v.KeyValues
	}

	return
}

// IsSetKeyValues returns true if KeyValues is not nil.
func (v *MultiReadRequest) IsSetKeyValues() bool {
	return v != nil && v.KeyValues != nil
}

// GetFieldsToRead returns the value of FieldsToRead if it is set or its
// zero value if it is unset.
func (v *MultiReadRequest) GetFieldsToRead() (o map[string]struct{}) {
	if v != nil && v.FieldsToRead != nil {
		return v.FieldsToRead
	}

	return
}

// IsSetFieldsToRead returns true if FieldsToRead is not nil.
func (v *MultiReadRequest) IsSetFieldsToRead() bool {
	return v != nil && v.FieldsToRead != nil
}

type MultiReadResponse struct {
	Results []*EntityOrError `json:"results,omitempty"`
}

type _List_EntityOrError_ValueList []*EntityOrError

func (v _List_EntityOrError_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid list '[]*EntityOrError', index [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_EntityOrError_ValueList) Size() int {
	return len(v)
}

func (_List_EntityOrError_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_EntityOrError_ValueList) Close() {}

// ToWire translates a MultiReadResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *MultiReadResponse) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Results != nil {
		w, err = wire.NewValueList(_List_EntityOrError_ValueList(v.Results)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _EntityOrError_Read(w wire.Value) (*EntityOrError, error) {
	var v EntityOrError
	err := v.FromWire(w)
	return &v, err
}

func _List_EntityOrError_Read(l wire.ValueList) ([]*EntityOrError, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*EntityOrError, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _EntityOrError_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a MultiReadResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a MultiReadResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v MultiReadResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *MultiReadResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Results, err = _List_EntityOrError_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

func _List_EntityOrError_Encode(val []*EntityOrError, sw stream.Writer) error {

	lh := stream.ListHeader{
		Type:   wire.TStruct,
		Length: len(val),
	}
	if err := sw.WriteListBegin(lh); err != nil {
		return err
	}

	for i, v := range val {
		if v == nil {
			return fmt.Errorf("invalid list '[]*EntityOrError', index [%v]: value is nil", i)
		}
		if err := v.Encode(sw); err != nil {
			return err
		}
	}
	return sw.WriteListEnd()
}

// Encode serializes a MultiReadResponse struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a MultiReadResponse struct could not be encoded.
func (v *MultiReadResponse) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Results != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_EntityOrError_Encode(v.Results, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _EntityOrError_Decode(sr stream.Reader) (*EntityOrError, error) {
	var v EntityOrError
	err := v.Decode(sr)
	return &v, err
}

func _List_EntityOrError_Decode(sr stream.Reader) ([]*EntityOrError, error) {
	lh, err := sr.ReadListBegin()
	if err != nil {
		return nil, err
	}

	if lh.Type != wire.TStruct {
		for i := 0; i < lh.Length; i++ {
			if err := sr.Skip(lh.Type); err != nil {
				return nil, err
			}
		}
		return nil, sr.ReadListEnd()
	}

	o := make([]*EntityOrError, 0, lh.Length)
	for i := 0; i < lh.Length; i++ {
		v, err := _EntityOrError_Decode(sr)
		if err != nil {
			return nil, err
		}
		o = append(o, v)
	}

	if err = sr.ReadListEnd(); err != nil {
		return nil, err
	}
	return o, err
}

// Decode deserializes a MultiReadResponse struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a MultiReadResponse struct could not be generated from the wire
// representation.
func (v *MultiReadResponse) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TList:
			v.Results, err = _List_EntityOrError_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a MultiReadResponse
// struct.
func (v *MultiReadResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Results != nil {
		fields[i] = fmt.Sprintf("Results: %v", v.Results)
		i++
	}

	return fmt.Sprintf("MultiReadResponse{%v}", strings.Join(fields[:i], ", "))
}

func _List_EntityOrError_Equals(lhs, rhs []*EntityOrError) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this MultiReadResponse match the
// provided MultiReadResponse.
//
// This function performs a deep comparison.
func (v *MultiReadResponse) Equals(rhs *MultiReadResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Results == nil && rhs.Results == nil) || (v.Results != nil && rhs.Results != nil && _List_EntityOrError_Equals(v.Results, rhs.Results))) {
		return false
	}

	return true
}

type _List_EntityOrError_Zapper []*EntityOrError

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_EntityOrError_Zapper.
func (l _List_EntityOrError_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of MultiReadResponse.
func (v *MultiReadResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Results != nil {
		err = multierr.Append(err, enc.AddArray("results", (_List_EntityOrError_Zapper)(v.Results)))
	}
	return err
}

// GetResults returns the value of Results if it is set or its
// zero value if it is unset.
func (v *MultiReadResponse) GetResults() (o []*EntityOrError) {
	if v != nil && v.Results != nil {
		return v.Results
	}

	return
}

// IsSetResults returns true if Results is not nil.
func (v *MultiReadResponse) IsSetResults() bool {
	return v != nil && v.Results != nil
}

type MultiRemoveRequest struct {
	Ref       *SchemaRef      `json:"ref,omitempty"`
	KeyValues []FieldValueMap `json:"keyValues,omitempty"`
	Timestamp *int64          `json:"timestamp,omitempty"`
}

// ToWire translates a MultiRemoveRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *MultiRemoveRequest) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Ref != nil {
		w, err = v.Ref.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.KeyValues != nil {
		w, err = wire.NewValueList(_List_FieldValueMap_ValueList(v.KeyValues)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Timestamp != nil {
		w, err = wire.NewValueI64(*(v.Timestamp)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a MultiRemoveRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a MultiRemoveRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v MultiRemoveRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *MultiRemoveRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Ref, err = _SchemaRef_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TList {
				v.KeyValues, err = _List_FieldValueMap_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Timestamp = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a MultiRemoveRequest struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a MultiRemoveRequest struct could not be encoded.
func (v *MultiRemoveRequest) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Ref != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Ref.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.KeyValues != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_FieldValueMap_Encode(v.KeyValues, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Timestamp != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.Timestamp)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a MultiRemoveRequest struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a MultiRemoveRequest struct could not be generated from the wire
// representation.
func (v *MultiRemoveRequest) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Ref, err = _SchemaRef_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TList:
			v.KeyValues, err = _List_FieldValueMap_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.Timestamp = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a MultiRemoveRequest
// struct.
func (v *MultiRemoveRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Ref != nil {
		fields[i] = fmt.Sprintf("Ref: %v", v.Ref)
		i++
	}
	if v.KeyValues != nil {
		fields[i] = fmt.Sprintf("KeyValues: %v", v.KeyValues)
		i++
	}
	if v.Timestamp != nil {
		fields[i] = fmt.Sprintf("Timestamp: %v", *(v.Timestamp))
		i++
	}

	return fmt.Sprintf("MultiRemoveRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this MultiRemoveRequest match the
// provided MultiRemoveRequest.
//
// This function performs a deep comparison.
func (v *MultiRemoveRequest) Equals(rhs *MultiRemoveRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Ref == nil && rhs.Ref == nil) || (v.Ref != nil && rhs.Ref != nil && v.Ref.Equals(rhs.Ref))) {
		return false
	}
	if !((v.KeyValues == nil && rhs.KeyValues == nil) || (v.KeyValues != nil && rhs.KeyValues != nil && _List_FieldValueMap_Equals(v.KeyValues, rhs.KeyValues))) {
		return false
	}
	if !_I64_EqualsPtr(v.Timestamp, rhs.Timestamp) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of MultiRemoveRequest.
func (v *MultiRemoveRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Ref != nil {
		err = multierr.Append(err, enc.AddObject("ref", v.Ref))
	}
	if v.KeyValues != nil {
		err = multierr.Append(err, enc.AddArray("keyValues", (_List_FieldValueMap_Zapper)(v.KeyValues)))
	}
	if v.Timestamp != nil {
		enc.AddInt64("timestamp", *v.Timestamp)
	}
	return err
}

// GetRef returns the value of Ref if it is set or its
// zero value if it is unset.
func (v *MultiRemoveRequest) GetRef() (o *SchemaRef) {
	if v != nil && v.Ref != nil {
		return v.Ref
	}

	return
}

// IsSetRef returns true if Ref is not nil.
func (v *MultiRemoveRequest) IsSetRef() bool {
	return v != nil && v.Ref != nil
}

// GetKeyValues returns the value of KeyValues if it is set or its
// zero value if it is unset.
func (v *MultiRemoveRequest) GetKeyValues() (o []FieldValueMap) {
	if v != nil && v.KeyValues != nil {
		return v.KeyValues
	}

	return
}

// IsSetKeyValues returns true if KeyValues is not nil.
func (v *MultiRemoveRequest) IsSetKeyValues() bool {
	return v != nil && v.KeyValues != nil
}

// GetTimestamp returns the value of Timestamp if it is set or its
// zero value if it is unset.
func (v *MultiRemoveRequest) GetTimestamp() (o int64) {
	if v != nil && v.Timestamp != nil {
		return *v.Timestamp
	}

	return
}

// IsSetTimestamp returns true if Timestamp is not nil.
func (v *MultiRemoveRequest) IsSetTimestamp() bool {
	return v != nil && v.Timestamp != nil
}

type MultiRemoveResponse struct {
	Errors []*Error `json:"errors,omitempty"`
}

type _List_Error_ValueList []*Error

func (v _List_Error_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid list '[]*Error', index [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Error_ValueList) Size() int {
	return len(v)
}

func (_List_Error_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_Error_ValueList) Close() {}

// ToWire translates a MultiRemoveResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *MultiRemoveResponse) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Errors != nil {
		w, err = wire.NewValueList(_List_Error_ValueList(v.Errors)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_Error_Read(l wire.ValueList) ([]*Error, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Error, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Error_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a MultiRemoveResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a MultiRemoveResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v MultiRemoveResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *MultiRemoveResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Errors, err = _List_Error_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

func _List_Error_Encode(val []*Error, sw stream.Writer) error {

	lh := stream.ListHeader{
		Type:   wire.TStruct,
		Length: len(val),
	}
	if err := sw.WriteListBegin(lh); err != nil {
		return err
	}

	for i, v := range val {
		if v == nil {
			return fmt.Errorf("invalid list '[]*Error', index [%v]: value is nil", i)
		}
		if err := v.Encode(sw); err != nil {
			return err
		}
	}
	return sw.WriteListEnd()
}

// Encode serializes a MultiRemoveResponse struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a MultiRemoveResponse struct could not be encoded.
func (v *MultiRemoveResponse) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Errors != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_Error_Encode(v.Errors, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _List_Error_Decode(sr stream.Reader) ([]*Error, error) {
	lh, err := sr.ReadListBegin()
	if err != nil {
		return nil, err
	}

	if lh.Type != wire.TStruct {
		for i := 0; i < lh.Length; i++ {
			if err := sr.Skip(lh.Type); err != nil {
				return nil, err
			}
		}
		return nil, sr.ReadListEnd()
	}

	o := make([]*Error, 0, lh.Length)
	for i := 0; i < lh.Length; i++ {
		v, err := _Error_Decode(sr)
		if err != nil {
			return nil, err
		}
		o = append(o, v)
	}

	if err = sr.ReadListEnd(); err != nil {
		return nil, err
	}
	return o, err
}

// Decode deserializes a MultiRemoveResponse struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a MultiRemoveResponse struct could not be generated from the wire
// representation.
func (v *MultiRemoveResponse) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TList:
			v.Errors, err = _List_Error_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a MultiRemoveResponse
// struct.
func (v *MultiRemoveResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Errors != nil {
		fields[i] = fmt.Sprintf("Errors: %v", v.Errors)
		i++
	}

	return fmt.Sprintf("MultiRemoveResponse{%v}", strings.Join(fields[:i], ", "))
}

func _List_Error_Equals(lhs, rhs []*Error) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this MultiRemoveResponse match the
// provided MultiRemoveResponse.
//
// This function performs a deep comparison.
func (v *MultiRemoveResponse) Equals(rhs *MultiRemoveResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Errors == nil && rhs.Errors == nil) || (v.Errors != nil && rhs.Errors != nil && _List_Error_Equals(v.Errors, rhs.Errors))) {
		return false
	}

	return true
}

type _List_Error_Zapper []*Error

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Error_Zapper.
func (l _List_Error_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of MultiRemoveResponse.
func (v *MultiRemoveResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Errors != nil {
		err = multierr.Append(err, enc.AddArray("errors", (_List_Error_Zapper)(v.Errors)))
	}
	return err
}

// GetErrors returns the value of Errors if it is set or its
// zero value if it is unset.
func (v *MultiRemoveResponse) GetErrors() (o []*Error) {
	if v != nil && v.Errors != nil {
		return v.Errors
	}

	return
}

// IsSetErrors returns true if Errors is not nil.
func (v *MultiRemoveResponse) IsSetErrors() bool {
	return v != nil && v.Errors != nil
}

type MultiUpsertRequest struct {
	Ref       *SchemaRef      `json:"ref,omitempty"`
	Entities  []FieldValueMap `json:"entities,omitempty"`
	Timestamp *int64          `json:"timestamp,omitempty"`
}

// ToWire translates a MultiUpsertRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *MultiUpsertRequest) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Ref != nil {
		w, err = v.Ref.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Entities != nil {
		w, err = wire.NewValueList(_List_FieldValueMap_ValueList(v.Entities)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Timestamp != nil {
		w, err = wire.NewValueI64(*(v.Timestamp)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a MultiUpsertRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a MultiUpsertRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v MultiUpsertRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *MultiUpsertRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Ref, err = _SchemaRef_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TList {
				v.Entities, err = _List_FieldValueMap_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Timestamp = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a MultiUpsertRequest struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a MultiUpsertRequest struct could not be encoded.
func (v *MultiUpsertRequest) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Ref != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Ref.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Entities != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_FieldValueMap_Encode(v.Entities, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Timestamp != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.Timestamp)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a MultiUpsertRequest struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a MultiUpsertRequest struct could not be generated from the wire
// representation.
func (v *MultiUpsertRequest) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Ref, err = _SchemaRef_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TList:
			v.Entities, err = _List_FieldValueMap_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.Timestamp = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a MultiUpsertRequest
// struct.
func (v *MultiUpsertRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Ref != nil {
		fields[i] = fmt.Sprintf("Ref: %v", v.Ref)
		i++
	}
	if v.Entities != nil {
		fields[i] = fmt.Sprintf("Entities: %v", v.Entities)
		i++
	}
	if v.Timestamp != nil {
		fields[i] = fmt.Sprintf("Timestamp: %v", *(v.Timestamp))
		i++
	}

	return fmt.Sprintf("MultiUpsertRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this MultiUpsertRequest match the
// provided MultiUpsertRequest.
//
// This function performs a deep comparison.
func (v *MultiUpsertRequest) Equals(rhs *MultiUpsertRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Ref == nil && rhs.Ref == nil) || (v.Ref != nil && rhs.Ref != nil && v.Ref.Equals(rhs.Ref))) {
		return false
	}
	if !((v.Entities == nil && rhs.Entities == nil) || (v.Entities != nil && rhs.Entities != nil && _List_FieldValueMap_Equals(v.Entities, rhs.Entities))) {
		return false
	}
	if !_I64_EqualsPtr(v.Timestamp, rhs.Timestamp) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of MultiUpsertRequest.
func (v *MultiUpsertRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Ref != nil {
		err = multierr.Append(err, enc.AddObject("ref", v.Ref))
	}
	if v.Entities != nil {
		err = multierr.Append(err, enc.AddArray("entities", (_List_FieldValueMap_Zapper)(v.Entities)))
	}
	if v.Timestamp != nil {
		enc.AddInt64("timestamp", *v.Timestamp)
	}
	return err
}

// GetRef returns the value of Ref if it is set or its
// zero value if it is unset.
func (v *MultiUpsertRequest) GetRef() (o *SchemaRef) {
	if v != nil && v.Ref != nil {
		return v.Ref
	}

	return
}

// IsSetRef returns true if Ref is not nil.
func (v *MultiUpsertRequest) IsSetRef() bool {
	return v != nil && v.Ref != nil
}

// GetEntities returns the value of Entities if it is set or its
// zero value if it is unset.
func (v *MultiUpsertRequest) GetEntities() (o []FieldValueMap) {
	if v != nil && v.Entities != nil {
		return v.Entities
	}

	return
}

// IsSetEntities returns true if Entities is not nil.
func (v *MultiUpsertRequest) IsSetEntities() bool {
	return v != nil && v.Entities != nil
}

// GetTimestamp returns the value of Timestamp if it is set or its
// zero value if it is unset.
func (v *MultiUpsertRequest) GetTimestamp() (o int64) {
	if v != nil && v.Timestamp != nil {
		return *v.Timestamp
	}

	return
}

// IsSetTimestamp returns true if Timestamp is not nil.
func (v *MultiUpsertRequest) IsSetTimestamp() bool {
	return v != nil && v.Timestamp != nil
}

type MultiUpsertResponse struct {
	Errors []*Error `json:"errors,omitempty"`
}

// ToWire translates a MultiUpsertResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *MultiUpsertResponse) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Errors != nil {
		w, err = wire.NewValueList(_List_Error_ValueList(v.Errors)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a MultiUpsertResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a MultiUpsertResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v MultiUpsertResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *MultiUpsertResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Errors, err = _List_Error_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a MultiUpsertResponse struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a MultiUpsertResponse struct could not be encoded.
func (v *MultiUpsertResponse) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Errors != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_Error_Encode(v.Errors, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a MultiUpsertResponse struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a MultiUpsertResponse struct could not be generated from the wire
// representation.
func (v *MultiUpsertResponse) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TList:
			v.Errors, err = _List_Error_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a MultiUpsertResponse
// struct.
func (v *MultiUpsertResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Errors != nil {
		fields[i] = fmt.Sprintf("Errors: %v", v.Errors)
		i++
	}

	return fmt.Sprintf("MultiUpsertResponse{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this MultiUpsertResponse match the
// provided MultiUpsertResponse.
//
// This function performs a deep comparison.
func (v *MultiUpsertResponse) Equals(rhs *MultiUpsertResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Errors == nil && rhs.Errors == nil) || (v.Errors != nil && rhs.Errors != nil && _List_Error_Equals(v.Errors, rhs.Errors))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of MultiUpsertResponse.
func (v *MultiUpsertResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Errors != nil {
		err = multierr.Append(err, enc.AddArray("errors", (_List_Error_Zapper)(v.Errors)))
	}
	return err
}

// GetErrors returns the value of Errors if it is set or its
// zero value if it is unset.
func (v *MultiUpsertResponse) GetErrors() (o []*Error) {
	if v != nil && v.Errors != nil {
		return v.Errors
	}

	return
}

// IsSetErrors returns true if Errors is not nil.
func (v *MultiUpsertResponse) IsSetErrors() bool {
	return v != nil && v.Errors != nil
}

type Operator int32

const (
	OperatorEq     Operator = 0
	OperatorLt     Operator = 1
	OperatorGt     Operator = 2
	OperatorLtOrEq Operator = 3
	OperatorGtOrEq Operator = 4
)

// Operator_Values returns all recognized values of Operator.
func Operator_Values() []Operator {
	return []Operator{
		OperatorEq,
		OperatorLt,
		OperatorGt,
		OperatorLtOrEq,
		OperatorGtOrEq,
	}
}

// UnmarshalText tries to decode Operator from a byte slice
// containing its name.
//
//   var v Operator
//   err := v.UnmarshalText([]byte("EQ"))
func (v *Operator) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "EQ":
		*v = OperatorEq
		return nil
	case "LT":
		*v = OperatorLt
		return nil
	case "GT":
		*v = OperatorGt
		return nil
	case "LT_OR_EQ":
		*v = OperatorLtOrEq
		return nil
	case "GT_OR_EQ":
		*v = OperatorGtOrEq
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "Operator", err)
		}
		*v = Operator(val)
		return nil
	}
}

// MarshalText encodes Operator to text.
//
// If the enum value is recognized, its name is returned.
// Otherwise, its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v Operator) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("EQ"), nil
	case 1:
		return []byte("LT"), nil
	case 2:
		return []byte("GT"), nil
	case 3:
		return []byte("LT_OR_EQ"), nil
	case 4:
		return []byte("GT_OR_EQ"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Operator.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v Operator) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "EQ")
	case 1:
		enc.AddString("name", "LT")
	case 2:
		enc.AddString("name", "GT")
	case 3:
		enc.AddString("name", "LT_OR_EQ")
	case 4:
		enc.AddString("name", "GT_OR_EQ")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v Operator) Ptr() *Operator {
	return &v
}

// Encode encodes Operator directly to bytes.
//
//   sWriter := BinaryStreamer.Writer(writer)
//
//   var v Operator
//   return v.Encode(sWriter)
func (v Operator) Encode(sw stream.Writer) error {
	return sw.WriteInt32(int32(v))
}

// ToWire translates Operator into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v Operator) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes Operator from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return Operator(0), err
//   }
//
//   var v Operator
//   if err := v.FromWire(x); err != nil {
//     return Operator(0), err
//   }
//   return v, nil
func (v *Operator) FromWire(w wire.Value) error {
	*v = (Operator)(w.GetI32())
	return nil
}

// Decode reads off the encoded Operator directly off of the wire.
//
//   sReader := BinaryStreamer.Reader(reader)
//
//   var v Operator
//   if err := v.Decode(sReader); err != nil {
//     return Operator(0), err
//   }
//   return v, nil
func (v *Operator) Decode(sr stream.Reader) error {
	i, err := sr.ReadInt32()
	if err != nil {
		return err
	}
	*v = (Operator)(i)
	return nil
}

// String returns a readable string representation of Operator.
func (v Operator) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "EQ"
	case 1:
		return "LT"
	case 2:
		return "GT"
	case 3:
		return "LT_OR_EQ"
	case 4:
		return "GT_OR_EQ"
	}
	return fmt.Sprintf("Operator(%d)", w)
}

// Equals returns true if this Operator value matches the provided
// value.
func (v Operator) Equals(rhs Operator) bool {
	return v == rhs
}

// MarshalJSON serializes Operator into JSON.
//
// If the enum value is recognized, its name is returned.
// Otherwise, its integer value is returned.
//
// This implements json.Marshaler.
func (v Operator) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"EQ\""), nil
	case 1:
		return ([]byte)("\"LT\""), nil
	case 2:
		return ([]byte)("\"GT\""), nil
	case 3:
		return ([]byte)("\"LT_OR_EQ\""), nil
	case 4:
		return ([]byte)("\"GT_OR_EQ\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode Operator from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *Operator) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "Operator")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "Operator")
		}
		*v = (Operator)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "Operator")
	}
}

type PrimaryKey struct {
	PartitionKeys  []string         `json:"partitionKeys,omitempty"`
	ClusteringKeys []*ClusteringKey `json:"clusteringKeys,omitempty"`
}

type _List_ClusteringKey_ValueList []*ClusteringKey

func (v _List_ClusteringKey_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid list '[]*ClusteringKey', index [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_ClusteringKey_ValueList) Size() int {
	return len(v)
}

func (_List_ClusteringKey_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_ClusteringKey_ValueList) Close() {}

// ToWire translates a PrimaryKey struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *PrimaryKey) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.PartitionKeys != nil {
		w, err = wire.NewValueList(_List_String_ValueList(v.PartitionKeys)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ClusteringKeys != nil {
		w, err = wire.NewValueList(_List_ClusteringKey_ValueList(v.ClusteringKeys)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ClusteringKey_Read(w wire.Value) (*ClusteringKey, error) {
	var v ClusteringKey
	err := v.FromWire(w)
	return &v, err
}

func _List_ClusteringKey_Read(l wire.ValueList) ([]*ClusteringKey, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*ClusteringKey, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _ClusteringKey_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a PrimaryKey struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a PrimaryKey struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v PrimaryKey
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *PrimaryKey) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.PartitionKeys, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TList {
				v.ClusteringKeys, err = _List_ClusteringKey_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

func _List_ClusteringKey_Encode(val []*ClusteringKey, sw stream.Writer) error {

	lh := stream.ListHeader{
		Type:   wire.TStruct,
		Length: len(val),
	}
	if err := sw.WriteListBegin(lh); err != nil {
		return err
	}

	for i, v := range val {
		if v == nil {
			return fmt.Errorf("invalid list '[]*ClusteringKey', index [%v]: value is nil", i)
		}
		if err := v.Encode(sw); err != nil {
			return err
		}
	}
	return sw.WriteListEnd()
}

// Encode serializes a PrimaryKey struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a PrimaryKey struct could not be encoded.
func (v *PrimaryKey) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.PartitionKeys != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_String_Encode(v.PartitionKeys, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ClusteringKeys != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_ClusteringKey_Encode(v.ClusteringKeys, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _ClusteringKey_Decode(sr stream.Reader) (*ClusteringKey, error) {
	var v ClusteringKey
	err := v.Decode(sr)
	return &v, err
}

func _List_ClusteringKey_Decode(sr stream.Reader) ([]*ClusteringKey, error) {
	lh, err := sr.ReadListBegin()
	if err != nil {
		return nil, err
	}

	if lh.Type != wire.TStruct {
		for i := 0; i < lh.Length; i++ {
			if err := sr.Skip(lh.Type); err != nil {
				return nil, err
			}
		}
		return nil, sr.ReadListEnd()
	}

	o := make([]*ClusteringKey, 0, lh.Length)
	for i := 0; i < lh.Length; i++ {
		v, err := _ClusteringKey_Decode(sr)
		if err != nil {
			return nil, err
		}
		o = append(o, v)
	}

	if err = sr.ReadListEnd(); err != nil {
		return nil, err
	}
	return o, err
}

// Decode deserializes a PrimaryKey struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a PrimaryKey struct could not be generated from the wire
// representation.
func (v *PrimaryKey) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TList:
			v.PartitionKeys, err = _List_String_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TList:
			v.ClusteringKeys, err = _List_ClusteringKey_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a PrimaryKey
// struct.
func (v *PrimaryKey) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.PartitionKeys != nil {
		fields[i] = fmt.Sprintf("PartitionKeys: %v", v.PartitionKeys)
		i++
	}
	if v.ClusteringKeys != nil {
		fields[i] = fmt.Sprintf("ClusteringKeys: %v", v.ClusteringKeys)
		i++
	}

	return fmt.Sprintf("PrimaryKey{%v}", strings.Join(fields[:i], ", "))
}

func _List_ClusteringKey_Equals(lhs, rhs []*ClusteringKey) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this PrimaryKey match the
// provided PrimaryKey.
//
// This function performs a deep comparison.
func (v *PrimaryKey) Equals(rhs *PrimaryKey) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.PartitionKeys == nil && rhs.PartitionKeys == nil) || (v.PartitionKeys != nil && rhs.PartitionKeys != nil && _List_String_Equals(v.PartitionKeys, rhs.PartitionKeys))) {
		return false
	}
	if !((v.ClusteringKeys == nil && rhs.ClusteringKeys == nil) || (v.ClusteringKeys != nil && rhs.ClusteringKeys != nil && _List_ClusteringKey_Equals(v.ClusteringKeys, rhs.ClusteringKeys))) {
		return false
	}

	return true
}

type _List_ClusteringKey_Zapper []*ClusteringKey

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_ClusteringKey_Zapper.
func (l _List_ClusteringKey_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of PrimaryKey.
func (v *PrimaryKey) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.PartitionKeys != nil {
		err = multierr.Append(err, enc.AddArray("partitionKeys", (_List_String_Zapper)(v.PartitionKeys)))
	}
	if v.ClusteringKeys != nil {
		err = multierr.Append(err, enc.AddArray("clusteringKeys", (_List_ClusteringKey_Zapper)(v.ClusteringKeys)))
	}
	return err
}

// GetPartitionKeys returns the value of PartitionKeys if it is set or its
// zero value if it is unset.
func (v *PrimaryKey) GetPartitionKeys() (o []string) {
	if v != nil && v.PartitionKeys != nil {
		return v.PartitionKeys
	}

	return
}

// IsSetPartitionKeys returns true if PartitionKeys is not nil.
func (v *PrimaryKey) IsSetPartitionKeys() bool {
	return v != nil && v.PartitionKeys != nil
}

// GetClusteringKeys returns the value of ClusteringKeys if it is set or its
// zero value if it is unset.
func (v *PrimaryKey) GetClusteringKeys() (o []*ClusteringKey) {
	if v != nil && v.ClusteringKeys != nil {
		return v.ClusteringKeys
	}

	return
}

// IsSetClusteringKeys returns true if ClusteringKeys is not nil.
func (v *PrimaryKey) IsSetClusteringKeys() bool {
	return v != nil && v.ClusteringKeys != nil
}

type RangeRequest struct {
	Ref          *SchemaRef          `json:"ref,omitempty"`
	Token        *string             `json:"token,omitempty"`
	Limit        *int32              `json:"limit,omitempty"`
	Conditions   []*Condition        `json:"conditions,omitempty"`
	FieldsToRead map[string]struct{} `json:"fieldsToRead,omitempty"`
}

type _List_Condition_ValueList []*Condition

func (v _List_Condition_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid list '[]*Condition', index [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Condition_ValueList) Size() int {
	return len(v)
}

func (_List_Condition_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_Condition_ValueList) Close() {}

// ToWire translates a RangeRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RangeRequest) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Ref != nil {
		w, err = v.Ref.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Token != nil {
		w, err = wire.NewValueString(*(v.Token)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Limit != nil {
		w, err = wire.NewValueI32(*(v.Limit)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Conditions != nil {
		w, err = wire.NewValueList(_List_Condition_ValueList(v.Conditions)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.FieldsToRead != nil {
		w, err = wire.NewValueSet(_Set_String_mapType_ValueList(v.FieldsToRead)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Condition_Read(w wire.Value) (*Condition, error) {
	var v Condition
	err := v.FromWire(w)
	return &v, err
}

func _List_Condition_Read(l wire.ValueList) ([]*Condition, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Condition, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Condition_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a RangeRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RangeRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RangeRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RangeRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Ref, err = _SchemaRef_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Token = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Limit = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TList {
				v.Conditions, err = _List_Condition_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TSet {
				v.FieldsToRead, err = _Set_String_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

func _List_Condition_Encode(val []*Condition, sw stream.Writer) error {

	lh := stream.ListHeader{
		Type:   wire.TStruct,
		Length: len(val),
	}
	if err := sw.WriteListBegin(lh); err != nil {
		return err
	}

	for i, v := range val {
		if v == nil {
			return fmt.Errorf("invalid list '[]*Condition', index [%v]: value is nil", i)
		}
		if err := v.Encode(sw); err != nil {
			return err
		}
	}
	return sw.WriteListEnd()
}

// Encode serializes a RangeRequest struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a RangeRequest struct could not be encoded.
func (v *RangeRequest) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Ref != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Ref.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Token != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Token)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Limit != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.Limit)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Conditions != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 4, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_Condition_Encode(v.Conditions, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.FieldsToRead != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 5, Type: wire.TSet}); err != nil {
			return err
		}
		if err := _Set_String_mapType_Encode(v.FieldsToRead, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _Condition_Decode(sr stream.Reader) (*Condition, error) {
	var v Condition
	err := v.Decode(sr)
	return &v, err
}

func _List_Condition_Decode(sr stream.Reader) ([]*Condition, error) {
	lh, err := sr.ReadListBegin()
	if err != nil {
		return nil, err
	}

	if lh.Type != wire.TStruct {
		for i := 0; i < lh.Length; i++ {
			if err := sr.Skip(lh.Type); err != nil {
				return nil, err
			}
		}
		return nil, sr.ReadListEnd()
	}

	o := make([]*Condition, 0, lh.Length)
	for i := 0; i < lh.Length; i++ {
		v, err := _Condition_Decode(sr)
		if err != nil {
			return nil, err
		}
		o = append(o, v)
	}

	if err = sr.ReadListEnd(); err != nil {
		return nil, err
	}
	return o, err
}

// Decode deserializes a RangeRequest struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a RangeRequest struct could not be generated from the wire
// representation.
func (v *RangeRequest) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Ref, err = _SchemaRef_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Token = &x
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.Limit = &x
			if err != nil {
				return err
			}

		case fh.ID == 4 && fh.Type == wire.TList:
			v.Conditions, err = _List_Condition_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 5 && fh.Type == wire.TSet:
			v.FieldsToRead, err = _Set_String_mapType_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a RangeRequest
// struct.
func (v *RangeRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [5]string
	i := 0
	if v.Ref != nil {
		fields[i] = fmt.Sprintf("Ref: %v", v.Ref)
		i++
	}
	if v.Token != nil {
		fields[i] = fmt.Sprintf("Token: %v", *(v.Token))
		i++
	}
	if v.Limit != nil {
		fields[i] = fmt.Sprintf("Limit: %v", *(v.Limit))
		i++
	}
	if v.Conditions != nil {
		fields[i] = fmt.Sprintf("Conditions: %v", v.Conditions)
		i++
	}
	if v.FieldsToRead != nil {
		fields[i] = fmt.Sprintf("FieldsToRead: %v", v.FieldsToRead)
		i++
	}

	return fmt.Sprintf("RangeRequest{%v}", strings.Join(fields[:i], ", "))
}

func _List_Condition_Equals(lhs, rhs []*Condition) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this RangeRequest match the
// provided RangeRequest.
//
// This function performs a deep comparison.
func (v *RangeRequest) Equals(rhs *RangeRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Ref == nil && rhs.Ref == nil) || (v.Ref != nil && rhs.Ref != nil && v.Ref.Equals(rhs.Ref))) {
		return false
	}
	if !_String_EqualsPtr(v.Token, rhs.Token) {
		return false
	}
	if !_I32_EqualsPtr(v.Limit, rhs.Limit) {
		return false
	}
	if !((v.Conditions == nil && rhs.Conditions == nil) || (v.Conditions != nil && rhs.Conditions != nil && _List_Condition_Equals(v.Conditions, rhs.Conditions))) {
		return false
	}
	if !((v.FieldsToRead == nil && rhs.FieldsToRead == nil) || (v.FieldsToRead != nil && rhs.FieldsToRead != nil && _Set_String_mapType_Equals(v.FieldsToRead, rhs.FieldsToRead))) {
		return false
	}

	return true
}

type _List_Condition_Zapper []*Condition

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Condition_Zapper.
func (l _List_Condition_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RangeRequest.
func (v *RangeRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Ref != nil {
		err = multierr.Append(err, enc.AddObject("ref", v.Ref))
	}
	if v.Token != nil {
		enc.AddString("token", *v.Token)
	}
	if v.Limit != nil {
		enc.AddInt32("limit", *v.Limit)
	}
	if v.Conditions != nil {
		err = multierr.Append(err, enc.AddArray("conditions", (_List_Condition_Zapper)(v.Conditions)))
	}
	if v.FieldsToRead != nil {
		err = multierr.Append(err, enc.AddArray("fieldsToRead", (_Set_String_mapType_Zapper)(v.FieldsToRead)))
	}
	return err
}

// GetRef returns the value of Ref if it is set or its
// zero value if it is unset.
func (v *RangeRequest) GetRef() (o *SchemaRef) {
	if v != nil && v.Ref != nil {
		return v.Ref
	}

	return
}

// IsSetRef returns true if Ref is not nil.
func (v *RangeRequest) IsSetRef() bool {
	return v != nil && v.Ref != nil
}

// GetToken returns the value of Token if it is set or its
// zero value if it is unset.
func (v *RangeRequest) GetToken() (o string) {
	if v != nil && v.Token != nil {
		return *v.Token
	}

	return
}

// IsSetToken returns true if Token is not nil.
func (v *RangeRequest) IsSetToken() bool {
	return v != nil && v.Token != nil
}

// GetLimit returns the value of Limit if it is set or its
// zero value if it is unset.
func (v *RangeRequest) GetLimit() (o int32) {
	if v != nil && v.Limit != nil {
		return *v.Limit
	}

	return
}

// IsSetLimit returns true if Limit is not nil.
func (v *RangeRequest) IsSetLimit() bool {
	return v != nil && v.Limit != nil
}

// GetConditions returns the value of Conditions if it is set or its
// zero value if it is unset.
func (v *RangeRequest) GetConditions() (o []*Condition) {
	if v != nil && v.Conditions != nil {
		return v.Conditions
	}

	return
}

// IsSetConditions returns true if Conditions is not nil.
func (v *RangeRequest) IsSetConditions() bool {
	return v != nil && v.Conditions != nil
}

// GetFieldsToRead returns the value of FieldsToRead if it is set or its
// zero value if it is unset.
func (v *RangeRequest) GetFieldsToRead() (o map[string]struct{}) {
	if v != nil && v.FieldsToRead != nil {
		return v.FieldsToRead
	}

	return
}

// IsSetFieldsToRead returns true if FieldsToRead is not nil.
func (v *RangeRequest) IsSetFieldsToRead() bool {
	return v != nil && v.FieldsToRead != nil
}

type RangeResponse struct {
	Entities  []FieldValueMap `json:"entities,omitempty"`
	NextToken *string         `json:"nextToken,omitempty"`
}

// ToWire translates a RangeResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RangeResponse) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Entities != nil {
		w, err = wire.NewValueList(_List_FieldValueMap_ValueList(v.Entities)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.NextToken != nil {
		w, err = wire.NewValueString(*(v.NextToken)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a RangeResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RangeResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RangeResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RangeResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Entities, err = _List_FieldValueMap_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.NextToken = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a RangeResponse struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a RangeResponse struct could not be encoded.
func (v *RangeResponse) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Entities != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_FieldValueMap_Encode(v.Entities, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.NextToken != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.NextToken)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a RangeResponse struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a RangeResponse struct could not be generated from the wire
// representation.
func (v *RangeResponse) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TList:
			v.Entities, err = _List_FieldValueMap_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.NextToken = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a RangeResponse
// struct.
func (v *RangeResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Entities != nil {
		fields[i] = fmt.Sprintf("Entities: %v", v.Entities)
		i++
	}
	if v.NextToken != nil {
		fields[i] = fmt.Sprintf("NextToken: %v", *(v.NextToken))
		i++
	}

	return fmt.Sprintf("RangeResponse{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this RangeResponse match the
// provided RangeResponse.
//
// This function performs a deep comparison.
func (v *RangeResponse) Equals(rhs *RangeResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Entities == nil && rhs.Entities == nil) || (v.Entities != nil && rhs.Entities != nil && _List_FieldValueMap_Equals(v.Entities, rhs.Entities))) {
		return false
	}
	if !_String_EqualsPtr(v.NextToken, rhs.NextToken) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RangeResponse.
func (v *RangeResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Entities != nil {
		err = multierr.Append(err, enc.AddArray("entities", (_List_FieldValueMap_Zapper)(v.Entities)))
	}
	if v.NextToken != nil {
		enc.AddString("nextToken", *v.NextToken)
	}
	return err
}

// GetEntities returns the value of Entities if it is set or its
// zero value if it is unset.
func (v *RangeResponse) GetEntities() (o []FieldValueMap) {
	if v != nil && v.Entities != nil {
		return v.Entities
	}

	return
}

// IsSetEntities returns true if Entities is not nil.
func (v *RangeResponse) IsSetEntities() bool {
	return v != nil && v.Entities != nil
}

// GetNextToken returns the value of NextToken if it is set or its
// zero value if it is unset.
func (v *RangeResponse) GetNextToken() (o string) {
	if v != nil && v.NextToken != nil {
		return *v.NextToken
	}

	return
}

// IsSetNextToken returns true if NextToken is not nil.
func (v *RangeResponse) IsSetNextToken() bool {
	return v != nil && v.NextToken != nil
}

type RateLimitError struct {
	Err       string  `json:"err,required"`
	Message   *string `json:"message,omitempty"`
	ErrorCode *int32  `json:"errorCode,omitempty"`
}

// ToWire translates a RateLimitError struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RateLimitError) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Err), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Message != nil {
		w, err = wire.NewValueString(*(v.Message)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.ErrorCode != nil {
		w, err = wire.NewValueI32(*(v.ErrorCode)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a RateLimitError struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RateLimitError struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RateLimitError
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RateLimitError) FromWire(w wire.Value) error {
	var err error

	errIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Err, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				errIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Message = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ErrorCode = &x
				if err != nil {
					return err
				}

			}
		}
	}

	if !errIsSet {
		return errors.New("field Err of RateLimitError is required")
	}

	return nil
}

// Encode serializes a RateLimitError struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a RateLimitError struct could not be encoded.
func (v *RateLimitError) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
		return err
	}
	if err := sw.WriteString(v.Err); err != nil {
		return err
	}
	if err := sw.WriteFieldEnd(); err != nil {
		return err
	}

	if v.Message != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Message)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ErrorCode != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.ErrorCode)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a RateLimitError struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a RateLimitError struct could not be generated from the wire
// representation.
func (v *RateLimitError) Decode(sr stream.Reader) error {

	errIsSet := false

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TBinary:
			v.Err, err = sr.ReadString()
			if err != nil {
				return err
			}
			errIsSet = true
		case fh.ID == 2 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Message = &x
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.ErrorCode = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	if !errIsSet {
		return errors.New("field Err of RateLimitError is required")
	}

	return nil
}

// String returns a readable string representation of a RateLimitError
// struct.
func (v *RateLimitError) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	fields[i] = fmt.Sprintf("Err: %v", v.Err)
	i++
	if v.Message != nil {
		fields[i] = fmt.Sprintf("Message: %v", *(v.Message))
		i++
	}
	if v.ErrorCode != nil {
		fields[i] = fmt.Sprintf("ErrorCode: %v", *(v.ErrorCode))
		i++
	}

	return fmt.Sprintf("RateLimitError{%v}", strings.Join(fields[:i], ", "))
}

// ErrorName is the name of this type as defined in the Thrift
// file.
func (*RateLimitError) ErrorName() string {
	return "RateLimitError"
}

// Equals returns true if all the fields of this RateLimitError match the
// provided RateLimitError.
//
// This function performs a deep comparison.
func (v *RateLimitError) Equals(rhs *RateLimitError) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Err == rhs.Err) {
		return false
	}
	if !_String_EqualsPtr(v.Message, rhs.Message) {
		return false
	}
	if !_I32_EqualsPtr(v.ErrorCode, rhs.ErrorCode) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RateLimitError.
func (v *RateLimitError) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("err", v.Err)
	if v.Message != nil {
		enc.AddString("message", *v.Message)
	}
	if v.ErrorCode != nil {
		enc.AddInt32("errorCode", *v.ErrorCode)
	}
	return err
}

// GetErr returns the value of Err if it is set or its
// zero value if it is unset.
func (v *RateLimitError) GetErr() (o string) {
	if v != nil {
		o = v.Err
	}
	return
}

// GetMessage returns the value of Message if it is set or its
// zero value if it is unset.
func (v *RateLimitError) GetMessage() (o string) {
	if v != nil && v.Message != nil {
		return *v.Message
	}

	return
}

// IsSetMessage returns true if Message is not nil.
func (v *RateLimitError) IsSetMessage() bool {
	return v != nil && v.Message != nil
}

// GetErrorCode returns the value of ErrorCode if it is set or its
// zero value if it is unset.
func (v *RateLimitError) GetErrorCode() (o int32) {
	if v != nil && v.ErrorCode != nil {
		return *v.ErrorCode
	}

	return
}

// IsSetErrorCode returns true if ErrorCode is not nil.
func (v *RateLimitError) IsSetErrorCode() bool {
	return v != nil && v.ErrorCode != nil
}

func (v *RateLimitError) Error() string {
	return v.String()
}

type RawValue struct {
	BinaryValue []byte   `json:"binaryValue,omitempty"`
	BoolValue   *bool    `json:"boolValue,omitempty"`
	DoubleValue *float64 `json:"doubleValue,omitempty"`
	Int32Value  *int32   `json:"int32Value,omitempty"`
	Int64Value  *int64   `json:"int64Value,omitempty"`
	StringValue *string  `json:"stringValue,omitempty"`
}

// ToWire translates a RawValue struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RawValue) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.BinaryValue != nil {
		w, err = wire.NewValueBinary(v.BinaryValue), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.BoolValue != nil {
		w, err = wire.NewValueBool(*(v.BoolValue)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.DoubleValue != nil {
		w, err = wire.NewValueDouble(*(v.DoubleValue)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Int32Value != nil {
		w, err = wire.NewValueI32(*(v.Int32Value)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Int64Value != nil {
		w, err = wire.NewValueI64(*(v.Int64Value)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.StringValue != nil {
		w, err = wire.NewValueString(*(v.StringValue)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("RawValue should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a RawValue struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RawValue struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RawValue
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RawValue) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.BinaryValue, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.BoolValue = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.DoubleValue = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Int32Value = &x
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Int64Value = &x
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StringValue = &x
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.BinaryValue != nil {
		count++
	}
	if v.BoolValue != nil {
		count++
	}
	if v.DoubleValue != nil {
		count++
	}
	if v.Int32Value != nil {
		count++
	}
	if v.Int64Value != nil {
		count++
	}
	if v.StringValue != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("RawValue should have exactly one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a RawValue struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a RawValue struct could not be encoded.
func (v *RawValue) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.BinaryValue != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteBinary(v.BinaryValue); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.BoolValue != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBool}); err != nil {
			return err
		}
		if err := sw.WriteBool(*(v.BoolValue)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.DoubleValue != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TDouble}); err != nil {
			return err
		}
		if err := sw.WriteDouble(*(v.DoubleValue)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Int32Value != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 4, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.Int32Value)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Int64Value != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 5, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.Int64Value)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.StringValue != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 6, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.StringValue)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.BinaryValue != nil {
		count++
	}
	if v.BoolValue != nil {
		count++
	}
	if v.DoubleValue != nil {
		count++
	}
	if v.Int32Value != nil {
		count++
	}
	if v.Int64Value != nil {
		count++
	}
	if v.StringValue != nil {
		count++
	}

	if count != 1 {
		return fmt.Errorf("RawValue should have exactly one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a RawValue struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a RawValue struct could not be generated from the wire
// representation.
func (v *RawValue) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TBinary:
			v.BinaryValue, err = sr.ReadBinary()
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TBool:
			var x bool
			x, err = sr.ReadBool()
			v.BoolValue = &x
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TDouble:
			var x float64
			x, err = sr.ReadDouble()
			v.DoubleValue = &x
			if err != nil {
				return err
			}

		case fh.ID == 4 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.Int32Value = &x
			if err != nil {
				return err
			}

		case fh.ID == 5 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.Int64Value = &x
			if err != nil {
				return err
			}

		case fh.ID == 6 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.StringValue = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.BinaryValue != nil {
		count++
	}
	if v.BoolValue != nil {
		count++
	}
	if v.DoubleValue != nil {
		count++
	}
	if v.Int32Value != nil {
		count++
	}
	if v.Int64Value != nil {
		count++
	}
	if v.StringValue != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("RawValue should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a RawValue
// struct.
func (v *RawValue) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	if v.BinaryValue != nil {
		fields[i] = fmt.Sprintf("BinaryValue: %v", v.BinaryValue)
		i++
	}
	if v.BoolValue != nil {
		fields[i] = fmt.Sprintf("BoolValue: %v", *(v.BoolValue))
		i++
	}
	if v.DoubleValue != nil {
		fields[i] = fmt.Sprintf("DoubleValue: %v", *(v.DoubleValue))
		i++
	}
	if v.Int32Value != nil {
		fields[i] = fmt.Sprintf("Int32Value: %v", *(v.Int32Value))
		i++
	}
	if v.Int64Value != nil {
		fields[i] = fmt.Sprintf("Int64Value: %v", *(v.Int64Value))
		i++
	}
	if v.StringValue != nil {
		fields[i] = fmt.Sprintf("StringValue: %v", *(v.StringValue))
		i++
	}

	return fmt.Sprintf("RawValue{%v}", strings.Join(fields[:i], ", "))
}

func _Double_EqualsPtr(lhs, rhs *float64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this RawValue match the
// provided RawValue.
//
// This function performs a deep comparison.
func (v *RawValue) Equals(rhs *RawValue) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.BinaryValue == nil && rhs.BinaryValue == nil) || (v.BinaryValue != nil && rhs.BinaryValue != nil && bytes.Equal(v.BinaryValue, rhs.BinaryValue))) {
		return false
	}
	if !_Bool_EqualsPtr(v.BoolValue, rhs.BoolValue) {
		return false
	}
	if !_Double_EqualsPtr(v.DoubleValue, rhs.DoubleValue) {
		return false
	}
	if !_I32_EqualsPtr(v.Int32Value, rhs.Int32Value) {
		return false
	}
	if !_I64_EqualsPtr(v.Int64Value, rhs.Int64Value) {
		return false
	}
	if !_String_EqualsPtr(v.StringValue, rhs.StringValue) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RawValue.
func (v *RawValue) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.BinaryValue != nil {
		enc.AddString("binaryValue", base64.StdEncoding.EncodeToString(v.BinaryValue))
	}
	if v.BoolValue != nil {
		enc.AddBool("boolValue", *v.BoolValue)
	}
	if v.DoubleValue != nil {
		enc.AddFloat64("doubleValue", *v.DoubleValue)
	}
	if v.Int32Value != nil {
		enc.AddInt32("int32Value", *v.Int32Value)
	}
	if v.Int64Value != nil {
		enc.AddInt64("int64Value", *v.Int64Value)
	}
	if v.StringValue != nil {
		enc.AddString("stringValue", *v.StringValue)
	}
	return err
}

// GetBinaryValue returns the value of BinaryValue if it is set or its
// zero value if it is unset.
func (v *RawValue) GetBinaryValue() (o []byte) {
	if v != nil && v.BinaryValue != nil {
		return v.BinaryValue
	}

	return
}

// IsSetBinaryValue returns true if BinaryValue is not nil.
func (v *RawValue) IsSetBinaryValue() bool {
	return v != nil && v.BinaryValue != nil
}

// GetBoolValue returns the value of BoolValue if it is set or its
// zero value if it is unset.
func (v *RawValue) GetBoolValue() (o bool) {
	if v != nil && v.BoolValue != nil {
		return *v.BoolValue
	}

	return
}

// IsSetBoolValue returns true if BoolValue is not nil.
func (v *RawValue) IsSetBoolValue() bool {
	return v != nil && v.BoolValue != nil
}

// GetDoubleValue returns the value of DoubleValue if it is set or its
// zero value if it is unset.
func (v *RawValue) GetDoubleValue() (o float64) {
	if v != nil && v.DoubleValue != nil {
		return *v.DoubleValue
	}

	return
}

// IsSetDoubleValue returns true if DoubleValue is not nil.
func (v *RawValue) IsSetDoubleValue() bool {
	return v != nil && v.DoubleValue != nil
}

// GetInt32Value returns the value of Int32Value if it is set or its
// zero value if it is unset.
func (v *RawValue) GetInt32Value() (o int32) {
	if v != nil && v.Int32Value != nil {
		return *v.Int32Value
	}

	return
}

// IsSetInt32Value returns true if Int32Value is not nil.
func (v *RawValue) IsSetInt32Value() bool {
	return v != nil && v.Int32Value != nil
}

// GetInt64Value returns the value of Int64Value if it is set or its
// zero value if it is unset.
func (v *RawValue) GetInt64Value() (o int64) {
	if v != nil && v.Int64Value != nil {
		return *v.Int64Value
	}

	return
}

// IsSetInt64Value returns true if Int64Value is not nil.
func (v *RawValue) IsSetInt64Value() bool {
	return v != nil && v.Int64Value != nil
}

// GetStringValue returns the value of StringValue if it is set or its
// zero value if it is unset.
func (v *RawValue) GetStringValue() (o string) {
	if v != nil && v.StringValue != nil {
		return *v.StringValue
	}

	return
}

// IsSetStringValue returns true if StringValue is not nil.
func (v *RawValue) IsSetStringValue() bool {
	return v != nil && v.StringValue != nil
}

type ReadRequest struct {
	Ref          *SchemaRef          `json:"ref,omitempty"`
	KeyValues    FieldValueMap       `json:"keyValues,omitempty"`
	FieldsToRead map[string]struct{} `json:"fieldsToRead,omitempty"`
}

// ToWire translates a ReadRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ReadRequest) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Ref != nil {
		w, err = v.Ref.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.KeyValues != nil {
		w, err = v.KeyValues.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.FieldsToRead != nil {
		w, err = wire.NewValueSet(_Set_String_mapType_ValueList(v.FieldsToRead)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ReadRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ReadRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ReadRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ReadRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Ref, err = _SchemaRef_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TMap {
				v.KeyValues, err = _FieldValueMap_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TSet {
				v.FieldsToRead, err = _Set_String_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a ReadRequest struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a ReadRequest struct could not be encoded.
func (v *ReadRequest) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Ref != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Ref.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.KeyValues != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TMap}); err != nil {
			return err
		}
		if err := v.KeyValues.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.FieldsToRead != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TSet}); err != nil {
			return err
		}
		if err := _Set_String_mapType_Encode(v.FieldsToRead, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a ReadRequest struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a ReadRequest struct could not be generated from the wire
// representation.
func (v *ReadRequest) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Ref, err = _SchemaRef_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TMap:
			v.KeyValues, err = _FieldValueMap_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TSet:
			v.FieldsToRead, err = _Set_String_mapType_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a ReadRequest
// struct.
func (v *ReadRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Ref != nil {
		fields[i] = fmt.Sprintf("Ref: %v", v.Ref)
		i++
	}
	if v.KeyValues != nil {
		fields[i] = fmt.Sprintf("KeyValues: %v", v.KeyValues)
		i++
	}
	if v.FieldsToRead != nil {
		fields[i] = fmt.Sprintf("FieldsToRead: %v", v.FieldsToRead)
		i++
	}

	return fmt.Sprintf("ReadRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ReadRequest match the
// provided ReadRequest.
//
// This function performs a deep comparison.
func (v *ReadRequest) Equals(rhs *ReadRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Ref == nil && rhs.Ref == nil) || (v.Ref != nil && rhs.Ref != nil && v.Ref.Equals(rhs.Ref))) {
		return false
	}
	if !((v.KeyValues == nil && rhs.KeyValues == nil) || (v.KeyValues != nil && rhs.KeyValues != nil && v.KeyValues.Equals(rhs.KeyValues))) {
		return false
	}
	if !((v.FieldsToRead == nil && rhs.FieldsToRead == nil) || (v.FieldsToRead != nil && rhs.FieldsToRead != nil && _Set_String_mapType_Equals(v.FieldsToRead, rhs.FieldsToRead))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ReadRequest.
func (v *ReadRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Ref != nil {
		err = multierr.Append(err, enc.AddObject("ref", v.Ref))
	}
	if v.KeyValues != nil {
		err = multierr.Append(err, enc.AddObject("keyValues", (_Map_String_Value_Zapper)(v.KeyValues)))
	}
	if v.FieldsToRead != nil {
		err = multierr.Append(err, enc.AddArray("fieldsToRead", (_Set_String_mapType_Zapper)(v.FieldsToRead)))
	}
	return err
}

// GetRef returns the value of Ref if it is set or its
// zero value if it is unset.
func (v *ReadRequest) GetRef() (o *SchemaRef) {
	if v != nil && v.Ref != nil {
		return v.Ref
	}

	return
}

// IsSetRef returns true if Ref is not nil.
func (v *ReadRequest) IsSetRef() bool {
	return v != nil && v.Ref != nil
}

// GetKeyValues returns the value of KeyValues if it is set or its
// zero value if it is unset.
func (v *ReadRequest) GetKeyValues() (o FieldValueMap) {
	if v != nil && v.KeyValues != nil {
		return v.KeyValues
	}

	return
}

// IsSetKeyValues returns true if KeyValues is not nil.
func (v *ReadRequest) IsSetKeyValues() bool {
	return v != nil && v.KeyValues != nil
}

// GetFieldsToRead returns the value of FieldsToRead if it is set or its
// zero value if it is unset.
func (v *ReadRequest) GetFieldsToRead() (o map[string]struct{}) {
	if v != nil && v.FieldsToRead != nil {
		return v.FieldsToRead
	}

	return
}

// IsSetFieldsToRead returns true if FieldsToRead is not nil.
func (v *ReadRequest) IsSetFieldsToRead() bool {
	return v != nil && v.FieldsToRead != nil
}

type ReadResponse struct {
	EntityValues FieldValueMap `json:"entityValues,omitempty"`
}

// ToWire translates a ReadResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ReadResponse) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.EntityValues != nil {
		w, err = v.EntityValues.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ReadResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ReadResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ReadResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ReadResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.EntityValues, err = _FieldValueMap_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a ReadResponse struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a ReadResponse struct could not be encoded.
func (v *ReadResponse) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.EntityValues != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TMap}); err != nil {
			return err
		}
		if err := v.EntityValues.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a ReadResponse struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a ReadResponse struct could not be generated from the wire
// representation.
func (v *ReadResponse) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TMap:
			v.EntityValues, err = _FieldValueMap_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a ReadResponse
// struct.
func (v *ReadResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.EntityValues != nil {
		fields[i] = fmt.Sprintf("EntityValues: %v", v.EntityValues)
		i++
	}

	return fmt.Sprintf("ReadResponse{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ReadResponse match the
// provided ReadResponse.
//
// This function performs a deep comparison.
func (v *ReadResponse) Equals(rhs *ReadResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.EntityValues == nil && rhs.EntityValues == nil) || (v.EntityValues != nil && rhs.EntityValues != nil && v.EntityValues.Equals(rhs.EntityValues))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ReadResponse.
func (v *ReadResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.EntityValues != nil {
		err = multierr.Append(err, enc.AddObject("entityValues", (_Map_String_Value_Zapper)(v.EntityValues)))
	}
	return err
}

// GetEntityValues returns the value of EntityValues if it is set or its
// zero value if it is unset.
func (v *ReadResponse) GetEntityValues() (o FieldValueMap) {
	if v != nil && v.EntityValues != nil {
		return v.EntityValues
	}

	return
}

// IsSetEntityValues returns true if EntityValues is not nil.
func (v *ReadResponse) IsSetEntityValues() bool {
	return v != nil && v.EntityValues != nil
}

type RemoveRangeRequest struct {
	Ref        *SchemaRef   `json:"ref,omitempty"`
	Conditions []*Condition `json:"conditions,omitempty"`
	Timestamp  *int64       `json:"timestamp,omitempty"`
}

// ToWire translates a RemoveRangeRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RemoveRangeRequest) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Ref != nil {
		w, err = v.Ref.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Conditions != nil {
		w, err = wire.NewValueList(_List_Condition_ValueList(v.Conditions)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Timestamp != nil {
		w, err = wire.NewValueI64(*(v.Timestamp)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a RemoveRangeRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RemoveRangeRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RemoveRangeRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RemoveRangeRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Ref, err = _SchemaRef_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TList {
				v.Conditions, err = _List_Condition_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Timestamp = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a RemoveRangeRequest struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a RemoveRangeRequest struct could not be encoded.
func (v *RemoveRangeRequest) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Ref != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Ref.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Conditions != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_Condition_Encode(v.Conditions, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Timestamp != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.Timestamp)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a RemoveRangeRequest struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a RemoveRangeRequest struct could not be generated from the wire
// representation.
func (v *RemoveRangeRequest) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Ref, err = _SchemaRef_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TList:
			v.Conditions, err = _List_Condition_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.Timestamp = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a RemoveRangeRequest
// struct.
func (v *RemoveRangeRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Ref != nil {
		fields[i] = fmt.Sprintf("Ref: %v", v.Ref)
		i++
	}
	if v.Conditions != nil {
		fields[i] = fmt.Sprintf("Conditions: %v", v.Conditions)
		i++
	}
	if v.Timestamp != nil {
		fields[i] = fmt.Sprintf("Timestamp: %v", *(v.Timestamp))
		i++
	}

	return fmt.Sprintf("RemoveRangeRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this RemoveRangeRequest match the
// provided RemoveRangeRequest.
//
// This function performs a deep comparison.
func (v *RemoveRangeRequest) Equals(rhs *RemoveRangeRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Ref == nil && rhs.Ref == nil) || (v.Ref != nil && rhs.Ref != nil && v.Ref.Equals(rhs.Ref))) {
		return false
	}
	if !((v.Conditions == nil && rhs.Conditions == nil) || (v.Conditions != nil && rhs.Conditions != nil && _List_Condition_Equals(v.Conditions, rhs.Conditions))) {
		return false
	}
	if !_I64_EqualsPtr(v.Timestamp, rhs.Timestamp) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RemoveRangeRequest.
func (v *RemoveRangeRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Ref != nil {
		err = multierr.Append(err, enc.AddObject("ref", v.Ref))
	}
	if v.Conditions != nil {
		err = multierr.Append(err, enc.AddArray("conditions", (_List_Condition_Zapper)(v.Conditions)))
	}
	if v.Timestamp != nil {
		enc.AddInt64("timestamp", *v.Timestamp)
	}
	return err
}

// GetRef returns the value of Ref if it is set or its
// zero value if it is unset.
func (v *RemoveRangeRequest) GetRef() (o *SchemaRef) {
	if v != nil && v.Ref != nil {
		return v.Ref
	}

	return
}

// IsSetRef returns true if Ref is not nil.
func (v *RemoveRangeRequest) IsSetRef() bool {
	return v != nil && v.Ref != nil
}

// GetConditions returns the value of Conditions if it is set or its
// zero value if it is unset.
func (v *RemoveRangeRequest) GetConditions() (o []*Condition) {
	if v != nil && v.Conditions != nil {
		return v.Conditions
	}

	return
}

// IsSetConditions returns true if Conditions is not nil.
func (v *RemoveRangeRequest) IsSetConditions() bool {
	return v != nil && v.Conditions != nil
}

// GetTimestamp returns the value of Timestamp if it is set or its
// zero value if it is unset.
func (v *RemoveRangeRequest) GetTimestamp() (o int64) {
	if v != nil && v.Timestamp != nil {
		return *v.Timestamp
	}

	return
}

// IsSetTimestamp returns true if Timestamp is not nil.
func (v *RemoveRangeRequest) IsSetTimestamp() bool {
	return v != nil && v.Timestamp != nil
}

type RemoveRequest struct {
	Ref       *SchemaRef    `json:"ref,omitempty"`
	KeyValues FieldValueMap `json:"keyValues,omitempty"`
	Timestamp *int64        `json:"timestamp,omitempty"`
}

// ToWire translates a RemoveRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RemoveRequest) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Ref != nil {
		w, err = v.Ref.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.KeyValues != nil {
		w, err = v.KeyValues.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Timestamp != nil {
		w, err = wire.NewValueI64(*(v.Timestamp)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a RemoveRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RemoveRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RemoveRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RemoveRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Ref, err = _SchemaRef_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TMap {
				v.KeyValues, err = _FieldValueMap_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Timestamp = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a RemoveRequest struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a RemoveRequest struct could not be encoded.
func (v *RemoveRequest) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Ref != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Ref.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.KeyValues != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TMap}); err != nil {
			return err
		}
		if err := v.KeyValues.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Timestamp != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.Timestamp)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a RemoveRequest struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a RemoveRequest struct could not be generated from the wire
// representation.
func (v *RemoveRequest) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Ref, err = _SchemaRef_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TMap:
			v.KeyValues, err = _FieldValueMap_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.Timestamp = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a RemoveRequest
// struct.
func (v *RemoveRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Ref != nil {
		fields[i] = fmt.Sprintf("Ref: %v", v.Ref)
		i++
	}
	if v.KeyValues != nil {
		fields[i] = fmt.Sprintf("KeyValues: %v", v.KeyValues)
		i++
	}
	if v.Timestamp != nil {
		fields[i] = fmt.Sprintf("Timestamp: %v", *(v.Timestamp))
		i++
	}

	return fmt.Sprintf("RemoveRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this RemoveRequest match the
// provided RemoveRequest.
//
// This function performs a deep comparison.
func (v *RemoveRequest) Equals(rhs *RemoveRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Ref == nil && rhs.Ref == nil) || (v.Ref != nil && rhs.Ref != nil && v.Ref.Equals(rhs.Ref))) {
		return false
	}
	if !((v.KeyValues == nil && rhs.KeyValues == nil) || (v.KeyValues != nil && rhs.KeyValues != nil && v.KeyValues.Equals(rhs.KeyValues))) {
		return false
	}
	if !_I64_EqualsPtr(v.Timestamp, rhs.Timestamp) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RemoveRequest.
func (v *RemoveRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Ref != nil {
		err = multierr.Append(err, enc.AddObject("ref", v.Ref))
	}
	if v.KeyValues != nil {
		err = multierr.Append(err, enc.AddObject("keyValues", (_Map_String_Value_Zapper)(v.KeyValues)))
	}
	if v.Timestamp != nil {
		enc.AddInt64("timestamp", *v.Timestamp)
	}
	return err
}

// GetRef returns the value of Ref if it is set or its
// zero value if it is unset.
func (v *RemoveRequest) GetRef() (o *SchemaRef) {
	if v != nil && v.Ref != nil {
		return v.Ref
	}

	return
}

// IsSetRef returns true if Ref is not nil.
func (v *RemoveRequest) IsSetRef() bool {
	return v != nil && v.Ref != nil
}

// GetKeyValues returns the value of KeyValues if it is set or its
// zero value if it is unset.
func (v *RemoveRequest) GetKeyValues() (o FieldValueMap) {
	if v != nil && v.KeyValues != nil {
		return v.KeyValues
	}

	return
}

// IsSetKeyValues returns true if KeyValues is not nil.
func (v *RemoveRequest) IsSetKeyValues() bool {
	return v != nil && v.KeyValues != nil
}

// GetTimestamp returns the value of Timestamp if it is set or its
// zero value if it is unset.
func (v *RemoveRequest) GetTimestamp() (o int64) {
	if v != nil && v.Timestamp != nil {
		return *v.Timestamp
	}

	return
}

// IsSetTimestamp returns true if Timestamp is not nil.
func (v *RemoveRequest) IsSetTimestamp() bool {
	return v != nil && v.Timestamp != nil
}

type ScanRequest struct {
	Ref          *SchemaRef          `json:"ref,omitempty"`
	Token        *string             `json:"token,omitempty"`
	Limit        *int32              `json:"limit,omitempty"`
	FieldsToRead map[string]struct{} `json:"fieldsToRead,omitempty"`
}

// ToWire translates a ScanRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ScanRequest) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Ref != nil {
		w, err = v.Ref.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Token != nil {
		w, err = wire.NewValueString(*(v.Token)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Limit != nil {
		w, err = wire.NewValueI32(*(v.Limit)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.FieldsToRead != nil {
		w, err = wire.NewValueSet(_Set_String_mapType_ValueList(v.FieldsToRead)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ScanRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ScanRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ScanRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ScanRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Ref, err = _SchemaRef_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Token = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Limit = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TSet {
				v.FieldsToRead, err = _Set_String_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a ScanRequest struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a ScanRequest struct could not be encoded.
func (v *ScanRequest) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Ref != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Ref.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Token != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Token)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Limit != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.Limit)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.FieldsToRead != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 4, Type: wire.TSet}); err != nil {
			return err
		}
		if err := _Set_String_mapType_Encode(v.FieldsToRead, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a ScanRequest struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a ScanRequest struct could not be generated from the wire
// representation.
func (v *ScanRequest) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Ref, err = _SchemaRef_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Token = &x
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.Limit = &x
			if err != nil {
				return err
			}

		case fh.ID == 4 && fh.Type == wire.TSet:
			v.FieldsToRead, err = _Set_String_mapType_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a ScanRequest
// struct.
func (v *ScanRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Ref != nil {
		fields[i] = fmt.Sprintf("Ref: %v", v.Ref)
		i++
	}
	if v.Token != nil {
		fields[i] = fmt.Sprintf("Token: %v", *(v.Token))
		i++
	}
	if v.Limit != nil {
		fields[i] = fmt.Sprintf("Limit: %v", *(v.Limit))
		i++
	}
	if v.FieldsToRead != nil {
		fields[i] = fmt.Sprintf("FieldsToRead: %v", v.FieldsToRead)
		i++
	}

	return fmt.Sprintf("ScanRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ScanRequest match the
// provided ScanRequest.
//
// This function performs a deep comparison.
func (v *ScanRequest) Equals(rhs *ScanRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Ref == nil && rhs.Ref == nil) || (v.Ref != nil && rhs.Ref != nil && v.Ref.Equals(rhs.Ref))) {
		return false
	}
	if !_String_EqualsPtr(v.Token, rhs.Token) {
		return false
	}
	if !_I32_EqualsPtr(v.Limit, rhs.Limit) {
		return false
	}
	if !((v.FieldsToRead == nil && rhs.FieldsToRead == nil) || (v.FieldsToRead != nil && rhs.FieldsToRead != nil && _Set_String_mapType_Equals(v.FieldsToRead, rhs.FieldsToRead))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ScanRequest.
func (v *ScanRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Ref != nil {
		err = multierr.Append(err, enc.AddObject("ref", v.Ref))
	}
	if v.Token != nil {
		enc.AddString("token", *v.Token)
	}
	if v.Limit != nil {
		enc.AddInt32("limit", *v.Limit)
	}
	if v.FieldsToRead != nil {
		err = multierr.Append(err, enc.AddArray("fieldsToRead", (_Set_String_mapType_Zapper)(v.FieldsToRead)))
	}
	return err
}

// GetRef returns the value of Ref if it is set or its
// zero value if it is unset.
func (v *ScanRequest) GetRef() (o *SchemaRef) {
	if v != nil && v.Ref != nil {
		return v.Ref
	}

	return
}

// IsSetRef returns true if Ref is not nil.
func (v *ScanRequest) IsSetRef() bool {
	return v != nil && v.Ref != nil
}

// GetToken returns the value of Token if it is set or its
// zero value if it is unset.
func (v *ScanRequest) GetToken() (o string) {
	if v != nil && v.Token != nil {
		return *v.Token
	}

	return
}

// IsSetToken returns true if Token is not nil.
func (v *ScanRequest) IsSetToken() bool {
	return v != nil && v.Token != nil
}

// GetLimit returns the value of Limit if it is set or its
// zero value if it is unset.
func (v *ScanRequest) GetLimit() (o int32) {
	if v != nil && v.Limit != nil {
		return *v.Limit
	}

	return
}

// IsSetLimit returns true if Limit is not nil.
func (v *ScanRequest) IsSetLimit() bool {
	return v != nil && v.Limit != nil
}

// GetFieldsToRead returns the value of FieldsToRead if it is set or its
// zero value if it is unset.
func (v *ScanRequest) GetFieldsToRead() (o map[string]struct{}) {
	if v != nil && v.FieldsToRead != nil {
		return v.FieldsToRead
	}

	return
}

// IsSetFieldsToRead returns true if FieldsToRead is not nil.
func (v *ScanRequest) IsSetFieldsToRead() bool {
	return v != nil && v.FieldsToRead != nil
}

type ScanResponse struct {
	Entities  []FieldValueMap `json:"entities,omitempty"`
	NextToken *string         `json:"nextToken,omitempty"`
}

// ToWire translates a ScanResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ScanResponse) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Entities != nil {
		w, err = wire.NewValueList(_List_FieldValueMap_ValueList(v.Entities)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.NextToken != nil {
		w, err = wire.NewValueString(*(v.NextToken)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ScanResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ScanResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ScanResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ScanResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Entities, err = _List_FieldValueMap_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.NextToken = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a ScanResponse struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a ScanResponse struct could not be encoded.
func (v *ScanResponse) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Entities != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_FieldValueMap_Encode(v.Entities, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.NextToken != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.NextToken)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a ScanResponse struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a ScanResponse struct could not be generated from the wire
// representation.
func (v *ScanResponse) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TList:
			v.Entities, err = _List_FieldValueMap_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.NextToken = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a ScanResponse
// struct.
func (v *ScanResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Entities != nil {
		fields[i] = fmt.Sprintf("Entities: %v", v.Entities)
		i++
	}
	if v.NextToken != nil {
		fields[i] = fmt.Sprintf("NextToken: %v", *(v.NextToken))
		i++
	}

	return fmt.Sprintf("ScanResponse{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ScanResponse match the
// provided ScanResponse.
//
// This function performs a deep comparison.
func (v *ScanResponse) Equals(rhs *ScanResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Entities == nil && rhs.Entities == nil) || (v.Entities != nil && rhs.Entities != nil && _List_FieldValueMap_Equals(v.Entities, rhs.Entities))) {
		return false
	}
	if !_String_EqualsPtr(v.NextToken, rhs.NextToken) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ScanResponse.
func (v *ScanResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Entities != nil {
		err = multierr.Append(err, enc.AddArray("entities", (_List_FieldValueMap_Zapper)(v.Entities)))
	}
	if v.NextToken != nil {
		enc.AddString("nextToken", *v.NextToken)
	}
	return err
}

// GetEntities returns the value of Entities if it is set or its
// zero value if it is unset.
func (v *ScanResponse) GetEntities() (o []FieldValueMap) {
	if v != nil && v.Entities != nil {
		return v.Entities
	}

	return
}

// IsSetEntities returns true if Entities is not nil.
func (v *ScanResponse) IsSetEntities() bool {
	return v != nil && v.Entities != nil
}

// GetNextToken returns the value of NextToken if it is set or its
// zero value if it is unset.
func (v *ScanResponse) GetNextToken() (o string) {
	if v != nil && v.NextToken != nil {
		return *v.NextToken
	}

	return
}

// IsSetNextToken returns true if NextToken is not nil.
func (v *ScanResponse) IsSetNextToken() bool {
	return v != nil && v.NextToken != nil
}

type SchemaRef struct {
	Scope      *string `json:"scope,omitempty"`
	NamePrefix *string `json:"namePrefix,omitempty"`
	EntityName *string `json:"entityName,omitempty"`
	Version    *int32  `json:"version,omitempty"`
}

// ToWire translates a SchemaRef struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *SchemaRef) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Scope != nil {
		w, err = wire.NewValueString(*(v.Scope)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.NamePrefix != nil {
		w, err = wire.NewValueString(*(v.NamePrefix)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.EntityName != nil {
		w, err = wire.NewValueString(*(v.EntityName)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Version != nil {
		w, err = wire.NewValueI32(*(v.Version)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a SchemaRef struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a SchemaRef struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v SchemaRef
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *SchemaRef) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Scope = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.NamePrefix = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.EntityName = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Version = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a SchemaRef struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a SchemaRef struct could not be encoded.
func (v *SchemaRef) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Scope != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Scope)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.NamePrefix != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.NamePrefix)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.EntityName != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.EntityName)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Version != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 4, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.Version)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a SchemaRef struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a SchemaRef struct could not be generated from the wire
// representation.
func (v *SchemaRef) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Scope = &x
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.NamePrefix = &x
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.EntityName = &x
			if err != nil {
				return err
			}

		case fh.ID == 4 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.Version = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a SchemaRef
// struct.
func (v *SchemaRef) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Scope != nil {
		fields[i] = fmt.Sprintf("Scope: %v", *(v.Scope))
		i++
	}
	if v.NamePrefix != nil {
		fields[i] = fmt.Sprintf("NamePrefix: %v", *(v.NamePrefix))
		i++
	}
	if v.EntityName != nil {
		fields[i] = fmt.Sprintf("EntityName: %v", *(v.EntityName))
		i++
	}
	if v.Version != nil {
		fields[i] = fmt.Sprintf("Version: %v", *(v.Version))
		i++
	}

	return fmt.Sprintf("SchemaRef{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this SchemaRef match the
// provided SchemaRef.
//
// This function performs a deep comparison.
func (v *SchemaRef) Equals(rhs *SchemaRef) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Scope, rhs.Scope) {
		return false
	}
	if !_String_EqualsPtr(v.NamePrefix, rhs.NamePrefix) {
		return false
	}
	if !_String_EqualsPtr(v.EntityName, rhs.EntityName) {
		return false
	}
	if !_I32_EqualsPtr(v.Version, rhs.Version) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of SchemaRef.
func (v *SchemaRef) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Scope != nil {
		enc.AddString("scope", *v.Scope)
	}
	if v.NamePrefix != nil {
		enc.AddString("namePrefix", *v.NamePrefix)
	}
	if v.EntityName != nil {
		enc.AddString("entityName", *v.EntityName)
	}
	if v.Version != nil {
		enc.AddInt32("version", *v.Version)
	}
	return err
}

// GetScope returns the value of Scope if it is set or its
// zero value if it is unset.
func (v *SchemaRef) GetScope() (o string) {
	if v != nil && v.Scope != nil {
		return *v.Scope
	}

	return
}

// IsSetScope returns true if Scope is not nil.
func (v *SchemaRef) IsSetScope() bool {
	return v != nil && v.Scope != nil
}

// GetNamePrefix returns the value of NamePrefix if it is set or its
// zero value if it is unset.
func (v *SchemaRef) GetNamePrefix() (o string) {
	if v != nil && v.NamePrefix != nil {
		return *v.NamePrefix
	}

	return
}

// IsSetNamePrefix returns true if NamePrefix is not nil.
func (v *SchemaRef) IsSetNamePrefix() bool {
	return v != nil && v.NamePrefix != nil
}

// GetEntityName returns the value of EntityName if it is set or its
// zero value if it is unset.
func (v *SchemaRef) GetEntityName() (o string) {
	if v != nil && v.EntityName != nil {
		return *v.EntityName
	}

	return
}

// IsSetEntityName returns true if EntityName is not nil.
func (v *SchemaRef) IsSetEntityName() bool {
	return v != nil && v.EntityName != nil
}

// GetVersion returns the value of Version if it is set or its
// zero value if it is unset.
func (v *SchemaRef) GetVersion() (o int32) {
	if v != nil && v.Version != nil {
		return *v.Version
	}

	return
}

// IsSetVersion returns true if Version is not nil.
func (v *SchemaRef) IsSetVersion() bool {
	return v != nil && v.Version != nil
}

type ScopeExistsRequest struct {
	Name *string `json:"name,omitempty"`
}

// ToWire translates a ScopeExistsRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ScopeExistsRequest) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ScopeExistsRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ScopeExistsRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ScopeExistsRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ScopeExistsRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a ScopeExistsRequest struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a ScopeExistsRequest struct could not be encoded.
func (v *ScopeExistsRequest) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Name != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Name)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a ScopeExistsRequest struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a ScopeExistsRequest struct could not be generated from the wire
// representation.
func (v *ScopeExistsRequest) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Name = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a ScopeExistsRequest
// struct.
func (v *ScopeExistsRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}

	return fmt.Sprintf("ScopeExistsRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ScopeExistsRequest match the
// provided ScopeExistsRequest.
//
// This function performs a deep comparison.
func (v *ScopeExistsRequest) Equals(rhs *ScopeExistsRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ScopeExistsRequest.
func (v *ScopeExistsRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *ScopeExistsRequest) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *ScopeExistsRequest) IsSetName() bool {
	return v != nil && v.Name != nil
}

type ScopeExistsResponse struct {
	Exists *bool `json:"exists,omitempty"`
}

// ToWire translates a ScopeExistsResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ScopeExistsResponse) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Exists != nil {
		w, err = wire.NewValueBool(*(v.Exists)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ScopeExistsResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ScopeExistsResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ScopeExistsResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ScopeExistsResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.Exists = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a ScopeExistsResponse struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a ScopeExistsResponse struct could not be encoded.
func (v *ScopeExistsResponse) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Exists != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBool}); err != nil {
			return err
		}
		if err := sw.WriteBool(*(v.Exists)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a ScopeExistsResponse struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a ScopeExistsResponse struct could not be generated from the wire
// representation.
func (v *ScopeExistsResponse) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TBool:
			var x bool
			x, err = sr.ReadBool()
			v.Exists = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a ScopeExistsResponse
// struct.
func (v *ScopeExistsResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Exists != nil {
		fields[i] = fmt.Sprintf("Exists: %v", *(v.Exists))
		i++
	}

	return fmt.Sprintf("ScopeExistsResponse{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ScopeExistsResponse match the
// provided ScopeExistsResponse.
//
// This function performs a deep comparison.
func (v *ScopeExistsResponse) Equals(rhs *ScopeExistsResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Bool_EqualsPtr(v.Exists, rhs.Exists) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ScopeExistsResponse.
func (v *ScopeExistsResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Exists != nil {
		enc.AddBool("exists", *v.Exists)
	}
	return err
}

// GetExists returns the value of Exists if it is set or its
// zero value if it is unset.
func (v *ScopeExistsResponse) GetExists() (o bool) {
	if v != nil && v.Exists != nil {
		return *v.Exists
	}

	return
}

// IsSetExists returns true if Exists is not nil.
func (v *ScopeExistsResponse) IsSetExists() bool {
	return v != nil && v.Exists != nil
}

type SearchRequest struct {
	Ref          *SchemaRef          `json:"ref,omitempty"`
	Token        *string             `json:"token,omitempty"`
	Limit        *int32              `json:"limit,omitempty"`
	SearchBy     *Field              `json:"searchBy,omitempty"`
	FieldsToRead map[string]struct{} `json:"fieldsToRead,omitempty"`
}

// ToWire translates a SearchRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *SearchRequest) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Ref != nil {
		w, err = v.Ref.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Token != nil {
		w, err = wire.NewValueString(*(v.Token)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Limit != nil {
		w, err = wire.NewValueI32(*(v.Limit)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.SearchBy != nil {
		w, err = v.SearchBy.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.FieldsToRead != nil {
		w, err = wire.NewValueSet(_Set_String_mapType_ValueList(v.FieldsToRead)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a SearchRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a SearchRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v SearchRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *SearchRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Ref, err = _SchemaRef_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Token = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Limit = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TStruct {
				v.SearchBy, err = _Field_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TSet {
				v.FieldsToRead, err = _Set_String_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a SearchRequest struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a SearchRequest struct could not be encoded.
func (v *SearchRequest) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Ref != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Ref.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Token != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Token)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Limit != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.Limit)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.SearchBy != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 4, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.SearchBy.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.FieldsToRead != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 5, Type: wire.TSet}); err != nil {
			return err
		}
		if err := _Set_String_mapType_Encode(v.FieldsToRead, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a SearchRequest struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a SearchRequest struct could not be generated from the wire
// representation.
func (v *SearchRequest) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Ref, err = _SchemaRef_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Token = &x
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.Limit = &x
			if err != nil {
				return err
			}

		case fh.ID == 4 && fh.Type == wire.TStruct:
			v.SearchBy, err = _Field_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 5 && fh.Type == wire.TSet:
			v.FieldsToRead, err = _Set_String_mapType_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a SearchRequest
// struct.
func (v *SearchRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [5]string
	i := 0
	if v.Ref != nil {
		fields[i] = fmt.Sprintf("Ref: %v", v.Ref)
		i++
	}
	if v.Token != nil {
		fields[i] = fmt.Sprintf("Token: %v", *(v.Token))
		i++
	}
	if v.Limit != nil {
		fields[i] = fmt.Sprintf("Limit: %v", *(v.Limit))
		i++
	}
	if v.SearchBy != nil {
		fields[i] = fmt.Sprintf("SearchBy: %v", v.SearchBy)
		i++
	}
	if v.FieldsToRead != nil {
		fields[i] = fmt.Sprintf("FieldsToRead: %v", v.FieldsToRead)
		i++
	}

	return fmt.Sprintf("SearchRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this SearchRequest match the
// provided SearchRequest.
//
// This function performs a deep comparison.
func (v *SearchRequest) Equals(rhs *SearchRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Ref == nil && rhs.Ref == nil) || (v.Ref != nil && rhs.Ref != nil && v.Ref.Equals(rhs.Ref))) {
		return false
	}
	if !_String_EqualsPtr(v.Token, rhs.Token) {
		return false
	}
	if !_I32_EqualsPtr(v.Limit, rhs.Limit) {
		return false
	}
	if !((v.SearchBy == nil && rhs.SearchBy == nil) || (v.SearchBy != nil && rhs.SearchBy != nil && v.SearchBy.Equals(rhs.SearchBy))) {
		return false
	}
	if !((v.FieldsToRead == nil && rhs.FieldsToRead == nil) || (v.FieldsToRead != nil && rhs.FieldsToRead != nil && _Set_String_mapType_Equals(v.FieldsToRead, rhs.FieldsToRead))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of SearchRequest.
func (v *SearchRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Ref != nil {
		err = multierr.Append(err, enc.AddObject("ref", v.Ref))
	}
	if v.Token != nil {
		enc.AddString("token", *v.Token)
	}
	if v.Limit != nil {
		enc.AddInt32("limit", *v.Limit)
	}
	if v.SearchBy != nil {
		err = multierr.Append(err, enc.AddObject("searchBy", v.SearchBy))
	}
	if v.FieldsToRead != nil {
		err = multierr.Append(err, enc.AddArray("fieldsToRead", (_Set_String_mapType_Zapper)(v.FieldsToRead)))
	}
	return err
}

// GetRef returns the value of Ref if it is set or its
// zero value if it is unset.
func (v *SearchRequest) GetRef() (o *SchemaRef) {
	if v != nil && v.Ref != nil {
		return v.Ref
	}

	return
}

// IsSetRef returns true if Ref is not nil.
func (v *SearchRequest) IsSetRef() bool {
	return v != nil && v.Ref != nil
}

// GetToken returns the value of Token if it is set or its
// zero value if it is unset.
func (v *SearchRequest) GetToken() (o string) {
	if v != nil && v.Token != nil {
		return *v.Token
	}

	return
}

// IsSetToken returns true if Token is not nil.
func (v *SearchRequest) IsSetToken() bool {
	return v != nil && v.Token != nil
}

// GetLimit returns the value of Limit if it is set or its
// zero value if it is unset.
func (v *SearchRequest) GetLimit() (o int32) {
	if v != nil && v.Limit != nil {
		return *v.Limit
	}

	return
}

// IsSetLimit returns true if Limit is not nil.
func (v *SearchRequest) IsSetLimit() bool {
	return v != nil && v.Limit != nil
}

// GetSearchBy returns the value of SearchBy if it is set or its
// zero value if it is unset.
func (v *SearchRequest) GetSearchBy() (o *Field) {
	if v != nil && v.SearchBy != nil {
		return v.SearchBy
	}

	return
}

// IsSetSearchBy returns true if SearchBy is not nil.
func (v *SearchRequest) IsSetSearchBy() bool {
	return v != nil && v.SearchBy != nil
}

// GetFieldsToRead returns the value of FieldsToRead if it is set or its
// zero value if it is unset.
func (v *SearchRequest) GetFieldsToRead() (o map[string]struct{}) {
	if v != nil && v.FieldsToRead != nil {
		return v.FieldsToRead
	}

	return
}

// IsSetFieldsToRead returns true if FieldsToRead is not nil.
func (v *SearchRequest) IsSetFieldsToRead() bool {
	return v != nil && v.FieldsToRead != nil
}

type SearchResponse struct {
	Entities  []FieldValueMap `json:"entities,omitempty"`
	NextToken *string         `json:"nextToken,omitempty"`
}

// ToWire translates a SearchResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *SearchResponse) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Entities != nil {
		w, err = wire.NewValueList(_List_FieldValueMap_ValueList(v.Entities)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.NextToken != nil {
		w, err = wire.NewValueString(*(v.NextToken)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a SearchResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a SearchResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v SearchResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *SearchResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Entities, err = _List_FieldValueMap_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.NextToken = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a SearchResponse struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a SearchResponse struct could not be encoded.
func (v *SearchResponse) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Entities != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_FieldValueMap_Encode(v.Entities, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.NextToken != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.NextToken)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a SearchResponse struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a SearchResponse struct could not be generated from the wire
// representation.
func (v *SearchResponse) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TList:
			v.Entities, err = _List_FieldValueMap_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.NextToken = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a SearchResponse
// struct.
func (v *SearchResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Entities != nil {
		fields[i] = fmt.Sprintf("Entities: %v", v.Entities)
		i++
	}
	if v.NextToken != nil {
		fields[i] = fmt.Sprintf("NextToken: %v", *(v.NextToken))
		i++
	}

	return fmt.Sprintf("SearchResponse{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this SearchResponse match the
// provided SearchResponse.
//
// This function performs a deep comparison.
func (v *SearchResponse) Equals(rhs *SearchResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Entities == nil && rhs.Entities == nil) || (v.Entities != nil && rhs.Entities != nil && _List_FieldValueMap_Equals(v.Entities, rhs.Entities))) {
		return false
	}
	if !_String_EqualsPtr(v.NextToken, rhs.NextToken) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of SearchResponse.
func (v *SearchResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Entities != nil {
		err = multierr.Append(err, enc.AddArray("entities", (_List_FieldValueMap_Zapper)(v.Entities)))
	}
	if v.NextToken != nil {
		enc.AddString("nextToken", *v.NextToken)
	}
	return err
}

// GetEntities returns the value of Entities if it is set or its
// zero value if it is unset.
func (v *SearchResponse) GetEntities() (o []FieldValueMap) {
	if v != nil && v.Entities != nil {
		return v.Entities
	}

	return
}

// IsSetEntities returns true if Entities is not nil.
func (v *SearchResponse) IsSetEntities() bool {
	return v != nil && v.Entities != nil
}

// GetNextToken returns the value of NextToken if it is set or its
// zero value if it is unset.
func (v *SearchResponse) GetNextToken() (o string) {
	if v != nil && v.NextToken != nil {
		return *v.NextToken
	}

	return
}

// IsSetNextToken returns true if NextToken is not nil.
func (v *SearchResponse) IsSetNextToken() bool {
	return v != nil && v.NextToken != nil
}

type TruncateScopeRequest struct {
	Name      *string `json:"name,omitempty"`
	Requester *string `json:"requester,omitempty"`
}

// ToWire translates a TruncateScopeRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *TruncateScopeRequest) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Requester != nil {
		w, err = wire.NewValueString(*(v.Requester)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a TruncateScopeRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TruncateScopeRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v TruncateScopeRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *TruncateScopeRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Requester = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a TruncateScopeRequest struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a TruncateScopeRequest struct could not be encoded.
func (v *TruncateScopeRequest) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Name != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Name)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Requester != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Requester)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a TruncateScopeRequest struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a TruncateScopeRequest struct could not be generated from the wire
// representation.
func (v *TruncateScopeRequest) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Name = &x
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Requester = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a TruncateScopeRequest
// struct.
func (v *TruncateScopeRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Requester != nil {
		fields[i] = fmt.Sprintf("Requester: %v", *(v.Requester))
		i++
	}

	return fmt.Sprintf("TruncateScopeRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this TruncateScopeRequest match the
// provided TruncateScopeRequest.
//
// This function performs a deep comparison.
func (v *TruncateScopeRequest) Equals(rhs *TruncateScopeRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !_String_EqualsPtr(v.Requester, rhs.Requester) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TruncateScopeRequest.
func (v *TruncateScopeRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.Requester != nil {
		enc.AddString("requester", *v.Requester)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *TruncateScopeRequest) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *TruncateScopeRequest) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetRequester returns the value of Requester if it is set or its
// zero value if it is unset.
func (v *TruncateScopeRequest) GetRequester() (o string) {
	if v != nil && v.Requester != nil {
		return *v.Requester
	}

	return
}

// IsSetRequester returns true if Requester is not nil.
func (v *TruncateScopeRequest) IsSetRequester() bool {
	return v != nil && v.Requester != nil
}

type UpsertRequest struct {
	Ref          *SchemaRef    `json:"ref,omitempty"`
	EntityValues FieldValueMap `json:"entityValues,omitempty"`
	TTL          *int64        `json:"ttl,omitempty"`
	Timestamp    *int64        `json:"timestamp,omitempty"`
}

// ToWire translates a UpsertRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *UpsertRequest) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Ref != nil {
		w, err = v.Ref.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.EntityValues != nil {
		w, err = v.EntityValues.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.TTL != nil {
		w, err = wire.NewValueI64(*(v.TTL)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Timestamp != nil {
		w, err = wire.NewValueI64(*(v.Timestamp)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a UpsertRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a UpsertRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v UpsertRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *UpsertRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Ref, err = _SchemaRef_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TMap {
				v.EntityValues, err = _FieldValueMap_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.TTL = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Timestamp = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a UpsertRequest struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a UpsertRequest struct could not be encoded.
func (v *UpsertRequest) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Ref != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Ref.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.EntityValues != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TMap}); err != nil {
			return err
		}
		if err := v.EntityValues.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.TTL != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.TTL)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Timestamp != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 4, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.Timestamp)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a UpsertRequest struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a UpsertRequest struct could not be generated from the wire
// representation.
func (v *UpsertRequest) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Ref, err = _SchemaRef_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TMap:
			v.EntityValues, err = _FieldValueMap_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.TTL = &x
			if err != nil {
				return err
			}

		case fh.ID == 4 && fh.Type == wire.TI64:
			var x int64
			x, err = sr.ReadInt64()
			v.Timestamp = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a UpsertRequest
// struct.
func (v *UpsertRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Ref != nil {
		fields[i] = fmt.Sprintf("Ref: %v", v.Ref)
		i++
	}
	if v.EntityValues != nil {
		fields[i] = fmt.Sprintf("EntityValues: %v", v.EntityValues)
		i++
	}
	if v.TTL != nil {
		fields[i] = fmt.Sprintf("TTL: %v", *(v.TTL))
		i++
	}
	if v.Timestamp != nil {
		fields[i] = fmt.Sprintf("Timestamp: %v", *(v.Timestamp))
		i++
	}

	return fmt.Sprintf("UpsertRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this UpsertRequest match the
// provided UpsertRequest.
//
// This function performs a deep comparison.
func (v *UpsertRequest) Equals(rhs *UpsertRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Ref == nil && rhs.Ref == nil) || (v.Ref != nil && rhs.Ref != nil && v.Ref.Equals(rhs.Ref))) {
		return false
	}
	if !((v.EntityValues == nil && rhs.EntityValues == nil) || (v.EntityValues != nil && rhs.EntityValues != nil && v.EntityValues.Equals(rhs.EntityValues))) {
		return false
	}
	if !_I64_EqualsPtr(v.TTL, rhs.TTL) {
		return false
	}
	if !_I64_EqualsPtr(v.Timestamp, rhs.Timestamp) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of UpsertRequest.
func (v *UpsertRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Ref != nil {
		err = multierr.Append(err, enc.AddObject("ref", v.Ref))
	}
	if v.EntityValues != nil {
		err = multierr.Append(err, enc.AddObject("entityValues", (_Map_String_Value_Zapper)(v.EntityValues)))
	}
	if v.TTL != nil {
		enc.AddInt64("ttl", *v.TTL)
	}
	if v.Timestamp != nil {
		enc.AddInt64("timestamp", *v.Timestamp)
	}
	return err
}

// GetRef returns the value of Ref if it is set or its
// zero value if it is unset.
func (v *UpsertRequest) GetRef() (o *SchemaRef) {
	if v != nil && v.Ref != nil {
		return v.Ref
	}

	return
}

// IsSetRef returns true if Ref is not nil.
func (v *UpsertRequest) IsSetRef() bool {
	return v != nil && v.Ref != nil
}

// GetEntityValues returns the value of EntityValues if it is set or its
// zero value if it is unset.
func (v *UpsertRequest) GetEntityValues() (o FieldValueMap) {
	if v != nil && v.EntityValues != nil {
		return v.EntityValues
	}

	return
}

// IsSetEntityValues returns true if EntityValues is not nil.
func (v *UpsertRequest) IsSetEntityValues() bool {
	return v != nil && v.EntityValues != nil
}

// GetTTL returns the value of TTL if it is set or its
// zero value if it is unset.
func (v *UpsertRequest) GetTTL() (o int64) {
	if v != nil && v.TTL != nil {
		return *v.TTL
	}

	return
}

// IsSetTTL returns true if TTL is not nil.
func (v *UpsertRequest) IsSetTTL() bool {
	return v != nil && v.TTL != nil
}

// GetTimestamp returns the value of Timestamp if it is set or its
// zero value if it is unset.
func (v *UpsertRequest) GetTimestamp() (o int64) {
	if v != nil && v.Timestamp != nil {
		return *v.Timestamp
	}

	return
}

// IsSetTimestamp returns true if Timestamp is not nil.
func (v *UpsertRequest) IsSetTimestamp() bool {
	return v != nil && v.Timestamp != nil
}

type UpsertSchemaRequest struct {
	Scope      *string             `json:"scope,omitempty"`
	NamePrefix *string             `json:"namePrefix,omitempty"`
	EntityDefs []*EntityDefinition `json:"entityDefs,omitempty"`
	DryRun     *bool               `json:"dryRun,omitempty"`
}

// ToWire translates a UpsertSchemaRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *UpsertSchemaRequest) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Scope != nil {
		w, err = wire.NewValueString(*(v.Scope)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.NamePrefix != nil {
		w, err = wire.NewValueString(*(v.NamePrefix)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.EntityDefs != nil {
		w, err = wire.NewValueList(_List_EntityDefinition_ValueList(v.EntityDefs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.DryRun != nil {
		w, err = wire.NewValueBool(*(v.DryRun)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a UpsertSchemaRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a UpsertSchemaRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v UpsertSchemaRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *UpsertSchemaRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Scope = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.NamePrefix = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.EntityDefs, err = _List_EntityDefinition_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.DryRun = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a UpsertSchemaRequest struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a UpsertSchemaRequest struct could not be encoded.
func (v *UpsertSchemaRequest) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Scope != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Scope)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.NamePrefix != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.NamePrefix)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.EntityDefs != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TList}); err != nil {
			return err
		}
		if err := _List_EntityDefinition_Encode(v.EntityDefs, sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.DryRun != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 4, Type: wire.TBool}); err != nil {
			return err
		}
		if err := sw.WriteBool(*(v.DryRun)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a UpsertSchemaRequest struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a UpsertSchemaRequest struct could not be generated from the wire
// representation.
func (v *UpsertSchemaRequest) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Scope = &x
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.NamePrefix = &x
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TList:
			v.EntityDefs, err = _List_EntityDefinition_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 4 && fh.Type == wire.TBool:
			var x bool
			x, err = sr.ReadBool()
			v.DryRun = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a UpsertSchemaRequest
// struct.
func (v *UpsertSchemaRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Scope != nil {
		fields[i] = fmt.Sprintf("Scope: %v", *(v.Scope))
		i++
	}
	if v.NamePrefix != nil {
		fields[i] = fmt.Sprintf("NamePrefix: %v", *(v.NamePrefix))
		i++
	}
	if v.EntityDefs != nil {
		fields[i] = fmt.Sprintf("EntityDefs: %v", v.EntityDefs)
		i++
	}
	if v.DryRun != nil {
		fields[i] = fmt.Sprintf("DryRun: %v", *(v.DryRun))
		i++
	}

	return fmt.Sprintf("UpsertSchemaRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this UpsertSchemaRequest match the
// provided UpsertSchemaRequest.
//
// This function performs a deep comparison.
func (v *UpsertSchemaRequest) Equals(rhs *UpsertSchemaRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Scope, rhs.Scope) {
		return false
	}
	if !_String_EqualsPtr(v.NamePrefix, rhs.NamePrefix) {
		return false
	}
	if !((v.EntityDefs == nil && rhs.EntityDefs == nil) || (v.EntityDefs != nil && rhs.EntityDefs != nil && _List_EntityDefinition_Equals(v.EntityDefs, rhs.EntityDefs))) {
		return false
	}
	if !_Bool_EqualsPtr(v.DryRun, rhs.DryRun) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of UpsertSchemaRequest.
func (v *UpsertSchemaRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Scope != nil {
		enc.AddString("scope", *v.Scope)
	}
	if v.NamePrefix != nil {
		enc.AddString("namePrefix", *v.NamePrefix)
	}
	if v.EntityDefs != nil {
		err = multierr.Append(err, enc.AddArray("entityDefs", (_List_EntityDefinition_Zapper)(v.EntityDefs)))
	}
	if v.DryRun != nil {
		enc.AddBool("dryRun", *v.DryRun)
	}
	return err
}

// GetScope returns the value of Scope if it is set or its
// zero value if it is unset.
func (v *UpsertSchemaRequest) GetScope() (o string) {
	if v != nil && v.Scope != nil {
		return *v.Scope
	}

	return
}

// IsSetScope returns true if Scope is not nil.
func (v *UpsertSchemaRequest) IsSetScope() bool {
	return v != nil && v.Scope != nil
}

// GetNamePrefix returns the value of NamePrefix if it is set or its
// zero value if it is unset.
func (v *UpsertSchemaRequest) GetNamePrefix() (o string) {
	if v != nil && v.NamePrefix != nil {
		return *v.NamePrefix
	}

	return
}

// IsSetNamePrefix returns true if NamePrefix is not nil.
func (v *UpsertSchemaRequest) IsSetNamePrefix() bool {
	return v != nil && v.NamePrefix != nil
}

// GetEntityDefs returns the value of EntityDefs if it is set or its
// zero value if it is unset.
func (v *UpsertSchemaRequest) GetEntityDefs() (o []*EntityDefinition) {
	if v != nil && v.EntityDefs != nil {
		return v.EntityDefs
	}

	return
}

// IsSetEntityDefs returns true if EntityDefs is not nil.
func (v *UpsertSchemaRequest) IsSetEntityDefs() bool {
	return v != nil && v.EntityDefs != nil
}

// GetDryRun returns the value of DryRun if it is set or its
// zero value if it is unset.
func (v *UpsertSchemaRequest) GetDryRun() (o bool) {
	if v != nil && v.DryRun != nil {
		return *v.DryRun
	}

	return
}

// IsSetDryRun returns true if DryRun is not nil.
func (v *UpsertSchemaRequest) IsSetDryRun() bool {
	return v != nil && v.DryRun != nil
}

type UpsertSchemaResponse struct {
	Version *int32  `json:"version,omitempty"`
	Status  *string `json:"status,omitempty"`
}

// ToWire translates a UpsertSchemaResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *UpsertSchemaResponse) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Version != nil {
		w, err = wire.NewValueI32(*(v.Version)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Status != nil {
		w, err = wire.NewValueString(*(v.Status)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a UpsertSchemaResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a UpsertSchemaResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v UpsertSchemaResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *UpsertSchemaResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Version = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Status = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a UpsertSchemaResponse struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a UpsertSchemaResponse struct could not be encoded.
func (v *UpsertSchemaResponse) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Version != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TI32}); err != nil {
			return err
		}
		if err := sw.WriteInt32(*(v.Version)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Status != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Status)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a UpsertSchemaResponse struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a UpsertSchemaResponse struct could not be generated from the wire
// representation.
func (v *UpsertSchemaResponse) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TI32:
			var x int32
			x, err = sr.ReadInt32()
			v.Version = &x
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TBinary:
			var x string
			x, err = sr.ReadString()
			v.Status = &x
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a UpsertSchemaResponse
// struct.
func (v *UpsertSchemaResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Version != nil {
		fields[i] = fmt.Sprintf("Version: %v", *(v.Version))
		i++
	}
	if v.Status != nil {
		fields[i] = fmt.Sprintf("Status: %v", *(v.Status))
		i++
	}

	return fmt.Sprintf("UpsertSchemaResponse{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this UpsertSchemaResponse match the
// provided UpsertSchemaResponse.
//
// This function performs a deep comparison.
func (v *UpsertSchemaResponse) Equals(rhs *UpsertSchemaResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.Version, rhs.Version) {
		return false
	}
	if !_String_EqualsPtr(v.Status, rhs.Status) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of UpsertSchemaResponse.
func (v *UpsertSchemaResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Version != nil {
		enc.AddInt32("version", *v.Version)
	}
	if v.Status != nil {
		enc.AddString("status", *v.Status)
	}
	return err
}

// GetVersion returns the value of Version if it is set or its
// zero value if it is unset.
func (v *UpsertSchemaResponse) GetVersion() (o int32) {
	if v != nil && v.Version != nil {
		return *v.Version
	}

	return
}

// IsSetVersion returns true if Version is not nil.
func (v *UpsertSchemaResponse) IsSetVersion() bool {
	return v != nil && v.Version != nil
}

// GetStatus returns the value of Status if it is set or its
// zero value if it is unset.
func (v *UpsertSchemaResponse) GetStatus() (o string) {
	if v != nil && v.Status != nil {
		return *v.Status
	}

	return
}

// IsSetStatus returns true if Status is not nil.
func (v *UpsertSchemaResponse) IsSetStatus() bool {
	return v != nil && v.Status != nil
}

type Value struct {
	ElemValue *RawValue `json:"elemValue,omitempty"`
}

// ToWire translates a Value struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Value) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ElemValue != nil {
		w, err = v.ElemValue.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Value should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _RawValue_Read(w wire.Value) (*RawValue, error) {
	var v RawValue
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Value struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Value struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Value
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Value) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ElemValue, err = _RawValue_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.ElemValue != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Value should have exactly one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a Value struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Value struct could not be encoded.
func (v *Value) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.ElemValue != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ElemValue.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.ElemValue != nil {
		count++
	}

	if count != 1 {
		return fmt.Errorf("Value should have exactly one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

func _RawValue_Decode(sr stream.Reader) (*RawValue, error) {
	var v RawValue
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Value struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Value struct could not be generated from the wire
// representation.
func (v *Value) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.ElemValue, err = _RawValue_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.ElemValue != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Value should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Value
// struct.
func (v *Value) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.ElemValue != nil {
		fields[i] = fmt.Sprintf("ElemValue: %v", v.ElemValue)
		i++
	}

	return fmt.Sprintf("Value{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Value match the
// provided Value.
//
// This function performs a deep comparison.
func (v *Value) Equals(rhs *Value) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.ElemValue == nil && rhs.ElemValue == nil) || (v.ElemValue != nil && rhs.ElemValue != nil && v.ElemValue.Equals(rhs.ElemValue))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Value.
func (v *Value) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ElemValue != nil {
		err = multierr.Append(err, enc.AddObject("elemValue", v.ElemValue))
	}
	return err
}

// GetElemValue returns the value of ElemValue if it is set or its
// zero value if it is unset.
func (v *Value) GetElemValue() (o *RawValue) {
	if v != nil && v.ElemValue != nil {
		return v.ElemValue
	}

	return
}

// IsSetElemValue returns true if ElemValue is not nil.
func (v *Value) IsSetElemValue() bool {
	return v != nil && v.ElemValue != nil
}

// ThriftModule represents the IDL file used to generate this package.
var ThriftModule = &thriftreflect.ThriftModule{
	Name:     "dosa",
	Package:  "github.com/uber/dosa-idl/.gen/dosa",
	FilePath: "dosa.thrift",
	SHA1:     "03d9ec431fa9b8949303908f7211be063b82bacc",
	Raw:      rawIDL,
}

const rawIDL = "// Copyright (c) 2019 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nnamespace java com.uber.dosa\n\ntypedef map<string, Value> FieldValueMap\n\nenum ElemType {\n   BOOL,\n   BLOB,\n   STRING,\n   INT32,\n   INT64,\n   DOUBLE,\n   TIMESTAMP, // Timestamps are 64-bit integers, the number of ns from the Unix epoch.\n   UUID,\n\n   // Reserve a few enum types in case we want to support few more\n   RESERVED0,\n   RESERVED1,\n   RESERVED2,\n   RESERVED3,\n}\n\nunion RawValue {\n 1: optional binary binaryValue                 // BLOB, UUID\n 2: optional bool boolValue                     // BOOL\n 3: optional double doubleValue                 // DOUBLE\n 4: optional i32 int32Value                     // INT32\n 5: optional i64 (js.type = \"Long\") int64Value  // INT64, TIMESTAMP\n 6: optional string stringValue                 // STRING\n}\n\n// make it union in case we want to support collections like set\nunion Value {\n   1: optional RawValue elemValue\n}\n\nstruct SchemaRef {\n    1: optional string scope\n    2: optional string namePrefix\n    3: optional string entityName\n    4: optional i32 version\n}\n\nstruct FieldTag {\n   1: optional string name\n   2: optional string value\n}\n\nstruct FieldDesc {\n   1: optional ElemType type\n   2: optional set<FieldTag> tags\n}\n\nstruct ClusteringKey {\n   1: optional string name\n   2: optional bool asc\n}\n\nstruct PrimaryKey {\n   1: optional list<string> partitionKeys\n   2: optional list<ClusteringKey> clusteringKeys\n}\n\nstruct IndexDefinition {\n   1: optional PrimaryKey key\n   2: optional list<string> columns\n   3: optional bool defunct\n}\n\nenum ETLState {\n    OFF = 1,\n    ON,\n\n    // Reserve a few enum types in case we want to support more\n    RESERVED0,\n    RESERVED1\n}\n\nstruct EntityDefinition {\n   1: optional string name\n   2: optional map<string, FieldDesc> fieldDescs\n   3: optional PrimaryKey primaryKey\n   4: optional map<string, IndexDefinition> Indexes\n   5: optional ETLState etl\n   6: optional list<string> columnOrder\n}\n\nstruct Error {\n   1: optional i32 errCode\n   2: optional string msg\n   3: optional bool shouldRetry\n}\n\nstruct CreateRequest {\n   1: optional SchemaRef ref\n   2: optional FieldValueMap entityValues\n   3: optional i64 ttl\n   4: optional i64 timestamp\n}\n\nstruct ReadRequest {\n   1: optional SchemaRef ref\n   2: optional FieldValueMap keyValues\n   3: optional set<string> fieldsToRead\n}\n\nstruct ReadResponse {\n   1: optional FieldValueMap entityValues\n}\n\nstruct MultiReadRequest {\n   1: optional SchemaRef ref\n   2: optional list<FieldValueMap> keyValues\n   3: optional set<string> fieldsToRead\n}\n\nunion EntityOrError{\n   1: optional FieldValueMap entityValues\n   2: optional Error error\n}\n\nstruct MultiReadResponse {\n   1: optional list<EntityOrError> results\n}\n\nstruct MultiUpsertResponse {\n   1: optional list<Error> errors\n}\n\nstruct UpsertRequest {\n    1: optional SchemaRef ref\n    2: optional FieldValueMap entityValues\n    3: optional i64 ttl\n    4: optional i64 timestamp\n}\n\nstruct MultiUpsertRequest {\n    1: optional SchemaRef ref\n    2: optional list<FieldValueMap> entities\n    3: optional i64 timestamp\n}\n\nstruct RemoveRequest {\n   1: optional SchemaRef ref\n   2: optional FieldValueMap keyValues\n   3: optional i64 timestamp\n}\n\nstruct MultiRemoveRequest {\n   1: optional SchemaRef ref\n   2: optional list<FieldValueMap> keyValues\n   3: optional i64 timestamp\n}\n\nstruct MultiRemoveResponse {\n   1: optional list<Error> errors\n}\n\nenum Operator {\n   EQ,\n   LT,\n   GT,\n   LT_OR_EQ,\n   GT_OR_EQ,\n}\n\nstruct Field {\n   1: optional string name\n   2: optional Value value\n}\n\nstruct Condition {\n   1: optional Operator op\n   2: optional Field field\n}\n\nstruct RangeRequest {\n   1: optional SchemaRef ref\n   2: optional string token\n   3: optional i32 limit\n   4: optional list<Condition> conditions\n   5: optional set<string> fieldsToRead\n}\n\nstruct RangeResponse {\n   1: optional list<FieldValueMap> entities\n   2: optional string nextToken\n}\n\nstruct RemoveRangeRequest {\n   1: optional SchemaRef ref\n   2: optional list<Condition> conditions\n   3: optional i64 timestamp\n}\n\nstruct SearchRequest {\n   1: optional SchemaRef ref\n   2: optional string token\n   3: optional i32 limit\n   4: optional Field searchBy\n   5: optional set<string> fieldsToRead\n}\n\nstruct SearchResponse {\n   1: optional list<FieldValueMap> entities\n   2: optional string nextToken\n}\n\nstruct ScanRequest {\n   1: optional SchemaRef ref\n   2: optional string token\n   3: optional i32 limit\n   4: optional set<string> fieldsToRead\n}\n\nstruct ScanResponse {\n   1: optional list<FieldValueMap> entities\n   2: optional string nextToken\n}\n\nstruct CanUpsertSchemaRequest {\n   1: optional string scope\n   2: optional string namePrefix\n   3: optional list<EntityDefinition> entityDefs\n}\n\nstruct CanUpsertSchemaResponse {\n   // latest upserted version\n   1: optional i32 version\n}\n\nstruct CheckSchemaRequest {\n   1: optional string scope\n   2: optional string namePrefix\n   3: optional list<EntityDefinition> entityDefs\n}\n\nstruct CheckSchemaResponse {\n   1: optional i32 version\n}\n\nstruct UpsertSchemaRequest {\n   1: optional string scope\n   2: optional string namePrefix\n   3: optional list<EntityDefinition> entityDefs\n   4: optional bool dryRun\n}\n\nstruct UpsertSchemaResponse {\n   1: optional i32 version\n   2: optional string status\n}\n\nstruct CheckSchemaStatusRequest {\n   1: optional string scope\n   2: optional string namePrefix\n   3: optional i32 version\n}\n\nstruct CheckSchemaStatusResponse {\n    1: optional i32 version\n    2: optional string status\n}\n\nstruct CreateScopeRequest {\n   1: optional string name\n   2: optional string requester\n   3: optional string metadata\n}\n\nstruct ScopeExistsRequest {\n   1: optional string name\n}\n\nstruct ScopeExistsResponse {\n   1: optional bool exists\n}\n\nstruct TruncateScopeRequest {\n   1: optional string name\n   2: optional string requester\n}\nstruct DropScopeRequest {\n   1: optional string name\n   2: optional string requester\n}\n\nexception BadRequestError {\n    1: required string err\n    2: optional string message\n    3: optional i32 errorCode\n}\n\nexception InternalServerError {\n    1: required string err\n    2: optional string message\n    3: optional i32 errorCode\n}\n\nexception BadSchemaError {\n    // EntityName -> Error msg\n    1: required map<string, string> reasons\n}\n\nexception RateLimitError {\n    1: required string err\n    2: optional string message\n    3: optional i32 errorCode\n}\n\nservice Dosa {\n   void createIfNotExists(\n       1: CreateRequest request\n   ) throws (\n       1: BadRequestError clientError\n       2: InternalServerError serverError\n       3: RateLimitError limitError\n   )\n\n   ReadResponse read (\n       1: ReadRequest request\n   ) throws (\n       1: BadRequestError clientError\n       2: InternalServerError serverError\n       3: RateLimitError limitError\n   )\n\n   MultiReadResponse multiRead (\n       1: MultiReadRequest request\n   ) throws (\n       1: BadRequestError clientError\n       2: InternalServerError serverError\n       3: RateLimitError limitError\n   )\n\n   void upsert (\n       1: UpsertRequest request\n   ) throws (\n       1: BadRequestError clientError\n       2: InternalServerError serverError\n       3: RateLimitError limitError\n   )\n\n   MultiUpsertResponse multiUpsert (\n       1: MultiUpsertRequest request\n   ) throws (\n       1: BadRequestError clientError\n       2: InternalServerError serverError\n       3: RateLimitError limitError\n   )\n\n   void remove (\n       1: RemoveRequest request\n   ) throws (\n       1: BadRequestError clientError\n       2: InternalServerError serverError\n       3: RateLimitError limitError\n   )\n\n   MultiRemoveResponse multiRemove (\n       1: MultiRemoveRequest request\n   ) throws (\n       1: BadRequestError clientError\n       2: InternalServerError serverError\n       3: RateLimitError limitError\n   )\n\n   RangeResponse range (\n       1: RangeRequest request\n   ) throws (\n       1: BadRequestError clientError\n       2: InternalServerError serverError\n       3: RateLimitError limitError\n   )\n\n   void removeRange (\n       1: RemoveRangeRequest request\n   ) throws (\n       1: BadRequestError clientError\n       2: InternalServerError serverError\n       3: RateLimitError limitError\n   )\n\n   SearchResponse search (\n       1: SearchRequest request\n   ) throws (\n       1: BadRequestError clientError\n       2: InternalServerError serverError\n       3: RateLimitError limitError\n   )\n\n   ScanResponse scan (\n       1: ScanRequest request\n   ) throws (\n       1: BadRequestError clientError\n       2: InternalServerError serverError\n       3: RateLimitError limitError\n   )\n\n   CanUpsertSchemaResponse canUpsertSchema(\n       1: CanUpsertSchemaRequest request\n   ) throws (\n       1: BadRequestError clientError\n       2: InternalServerError serverError\n       3: BadSchemaError schemaError\n       4: RateLimitError limitError\n   )\n\n   CheckSchemaResponse checkSchema(\n       1: CheckSchemaRequest request\n   ) throws (\n       1: BadRequestError clientError\n       2: InternalServerError serverError\n       3: BadSchemaError schemaError\n       4: RateLimitError limitError\n   )\n\n   UpsertSchemaResponse upsertSchema(\n       1: UpsertSchemaRequest request\n   ) throws (\n       1: BadRequestError clientError\n       2: InternalServerError serverError\n       3: BadSchemaError schemaError\n       4: RateLimitError limitError\n   )\n\n   CheckSchemaStatusResponse checkSchemaStatus(\n       1: CheckSchemaStatusRequest request\n   ) throws (\n       1: BadRequestError clientError\n       2: InternalServerError serverError\n       3: RateLimitError limitError\n   )\n\n   void createScope(\n       1: CreateScopeRequest request\n   ) throws (\n       1: BadRequestError clientError\n       2: InternalServerError serverError\n       3: RateLimitError limitError\n   )\n\n   ScopeExistsResponse scopeExists(\n       1: ScopeExistsRequest request\n   ) throws (\n       1: BadRequestError clientError\n       2: InternalServerError serverError\n       3: RateLimitError limitError\n   )\n\n   void truncateScope(\n       1: TruncateScopeRequest request\n   ) throws (\n       1: BadRequestError clientError\n       2: InternalServerError serverError\n       3: RateLimitError limitError\n   )\n\n   void dropScope(\n       1: DropScopeRequest request\n   ) throws (\n       1: BadRequestError clientError\n       2: InternalServerError serverError\n       3: RateLimitError limitError\n   )\n}\n"

// Dosa_CanUpsertSchema_Args represents the arguments for the Dosa.canUpsertSchema function.
//
// The arguments for canUpsertSchema are sent and received over the wire as this struct.
type Dosa_CanUpsertSchema_Args struct {
	Request *CanUpsertSchemaRequest `json:"request,omitempty"`
}

// ToWire translates a Dosa_CanUpsertSchema_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_CanUpsertSchema_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _CanUpsertSchemaRequest_Read(w wire.Value) (*CanUpsertSchemaRequest, error) {
	var v CanUpsertSchemaRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_CanUpsertSchema_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_CanUpsertSchema_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_CanUpsertSchema_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_CanUpsertSchema_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _CanUpsertSchemaRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Dosa_CanUpsertSchema_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_CanUpsertSchema_Args struct could not be encoded.
func (v *Dosa_CanUpsertSchema_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Request != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Request.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _CanUpsertSchemaRequest_Decode(sr stream.Reader) (*CanUpsertSchemaRequest, error) {
	var v CanUpsertSchemaRequest
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_CanUpsertSchema_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_CanUpsertSchema_Args struct could not be generated from the wire
// representation.
func (v *Dosa_CanUpsertSchema_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Request, err = _CanUpsertSchemaRequest_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Dosa_CanUpsertSchema_Args
// struct.
func (v *Dosa_CanUpsertSchema_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("Dosa_CanUpsertSchema_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_CanUpsertSchema_Args match the
// provided Dosa_CanUpsertSchema_Args.
//
// This function performs a deep comparison.
func (v *Dosa_CanUpsertSchema_Args) Equals(rhs *Dosa_CanUpsertSchema_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_CanUpsertSchema_Args.
func (v *Dosa_CanUpsertSchema_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Dosa_CanUpsertSchema_Args) GetRequest() (o *CanUpsertSchemaRequest) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Dosa_CanUpsertSchema_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "canUpsertSchema" for this struct.
func (v *Dosa_CanUpsertSchema_Args) MethodName() string {
	return "canUpsertSchema"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Dosa_CanUpsertSchema_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Dosa_CanUpsertSchema_Helper provides functions that aid in handling the
// parameters and return values of the Dosa.canUpsertSchema
// function.
var Dosa_CanUpsertSchema_Helper = struct {
	// Args accepts the parameters of canUpsertSchema in-order and returns
	// the arguments struct for the function.
	Args func(
		request *CanUpsertSchemaRequest,
	) *Dosa_CanUpsertSchema_Args

	// IsException returns true if the given error can be thrown
	// by canUpsertSchema.
	//
	// An error can be thrown by canUpsertSchema only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for canUpsertSchema
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// canUpsertSchema into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by canUpsertSchema
	//
	//   value, err := canUpsertSchema(args)
	//   result, err := Dosa_CanUpsertSchema_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from canUpsertSchema: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*CanUpsertSchemaResponse, error) (*Dosa_CanUpsertSchema_Result, error)

	// UnwrapResponse takes the result struct for canUpsertSchema
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if canUpsertSchema threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Dosa_CanUpsertSchema_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Dosa_CanUpsertSchema_Result) (*CanUpsertSchemaResponse, error)
}{}

func init() {
	Dosa_CanUpsertSchema_Helper.Args = func(
		request *CanUpsertSchemaRequest,
	) *Dosa_CanUpsertSchema_Args {
		return &Dosa_CanUpsertSchema_Args{
			Request: request,
		}
	}

	Dosa_CanUpsertSchema_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BadRequestError:
			return true
		case *InternalServerError:
			return true
		case *BadSchemaError:
			return true
		case *RateLimitError:
			return true
		default:
			return false
		}
	}

	Dosa_CanUpsertSchema_Helper.WrapResponse = func(success *CanUpsertSchemaResponse, err error) (*Dosa_CanUpsertSchema_Result, error) {
		if err == nil {
			return &Dosa_CanUpsertSchema_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *BadRequestError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_CanUpsertSchema_Result.ClientError")
			}
			return &Dosa_CanUpsertSchema_Result{ClientError: e}, nil
		case *InternalServerError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_CanUpsertSchema_Result.ServerError")
			}
			return &Dosa_CanUpsertSchema_Result{ServerError: e}, nil
		case *BadSchemaError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_CanUpsertSchema_Result.SchemaError")
			}
			return &Dosa_CanUpsertSchema_Result{SchemaError: e}, nil
		case *RateLimitError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_CanUpsertSchema_Result.LimitError")
			}
			return &Dosa_CanUpsertSchema_Result{LimitError: e}, nil
		}

		return nil, err
	}
	Dosa_CanUpsertSchema_Helper.UnwrapResponse = func(result *Dosa_CanUpsertSchema_Result) (success *CanUpsertSchemaResponse, err error) {
		if result.ClientError != nil {
			err = result.ClientError
			return
		}
		if result.ServerError != nil {
			err = result.ServerError
			return
		}
		if result.SchemaError != nil {
			err = result.SchemaError
			return
		}
		if result.LimitError != nil {
			err = result.LimitError
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Dosa_CanUpsertSchema_Result represents the result of a Dosa.canUpsertSchema function call.
//
// The result of a canUpsertSchema execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Dosa_CanUpsertSchema_Result struct {
	// Value returned by canUpsertSchema after a successful execution.
	Success     *CanUpsertSchemaResponse `json:"success,omitempty"`
	ClientError *BadRequestError         `json:"clientError,omitempty"`
	ServerError *InternalServerError     `json:"serverError,omitempty"`
	SchemaError *BadSchemaError          `json:"schemaError,omitempty"`
	LimitError  *RateLimitError          `json:"limitError,omitempty"`
}

// ToWire translates a Dosa_CanUpsertSchema_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_CanUpsertSchema_Result) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.ClientError != nil {
		w, err = v.ClientError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ServerError != nil {
		w, err = v.ServerError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.SchemaError != nil {
		w, err = v.SchemaError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.LimitError != nil {
		w, err = v.LimitError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Dosa_CanUpsertSchema_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _CanUpsertSchemaResponse_Read(w wire.Value) (*CanUpsertSchemaResponse, error) {
	var v CanUpsertSchemaResponse
	err := v.FromWire(w)
	return &v, err
}

func _BadRequestError_Read(w wire.Value) (*BadRequestError, error) {
	var v BadRequestError
	err := v.FromWire(w)
	return &v, err
}

func _InternalServerError_Read(w wire.Value) (*InternalServerError, error) {
	var v InternalServerError
	err := v.FromWire(w)
	return &v, err
}

func _BadSchemaError_Read(w wire.Value) (*BadSchemaError, error) {
	var v BadSchemaError
	err := v.FromWire(w)
	return &v, err
}

func _RateLimitError_Read(w wire.Value) (*RateLimitError, error) {
	var v RateLimitError
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_CanUpsertSchema_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_CanUpsertSchema_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_CanUpsertSchema_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_CanUpsertSchema_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _CanUpsertSchemaResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ClientError, err = _BadRequestError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ServerError, err = _InternalServerError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.SchemaError, err = _BadSchemaError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TStruct {
				v.LimitError, err = _RateLimitError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.SchemaError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_CanUpsertSchema_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a Dosa_CanUpsertSchema_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_CanUpsertSchema_Result struct could not be encoded.
func (v *Dosa_CanUpsertSchema_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Success != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 0, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Success.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ClientError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ClientError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ServerError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ServerError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.SchemaError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.SchemaError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LimitError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 4, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.LimitError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.SchemaError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}

	if count != 1 {
		return fmt.Errorf("Dosa_CanUpsertSchema_Result should have exactly one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

func _CanUpsertSchemaResponse_Decode(sr stream.Reader) (*CanUpsertSchemaResponse, error) {
	var v CanUpsertSchemaResponse
	err := v.Decode(sr)
	return &v, err
}

func _BadRequestError_Decode(sr stream.Reader) (*BadRequestError, error) {
	var v BadRequestError
	err := v.Decode(sr)
	return &v, err
}

func _InternalServerError_Decode(sr stream.Reader) (*InternalServerError, error) {
	var v InternalServerError
	err := v.Decode(sr)
	return &v, err
}

func _BadSchemaError_Decode(sr stream.Reader) (*BadSchemaError, error) {
	var v BadSchemaError
	err := v.Decode(sr)
	return &v, err
}

func _RateLimitError_Decode(sr stream.Reader) (*RateLimitError, error) {
	var v RateLimitError
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_CanUpsertSchema_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_CanUpsertSchema_Result struct could not be generated from the wire
// representation.
func (v *Dosa_CanUpsertSchema_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 0 && fh.Type == wire.TStruct:
			v.Success, err = _CanUpsertSchemaResponse_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.ClientError, err = _BadRequestError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.ServerError, err = _InternalServerError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TStruct:
			v.SchemaError, err = _BadSchemaError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 4 && fh.Type == wire.TStruct:
			v.LimitError, err = _RateLimitError_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.SchemaError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_CanUpsertSchema_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Dosa_CanUpsertSchema_Result
// struct.
func (v *Dosa_CanUpsertSchema_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [5]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.ClientError != nil {
		fields[i] = fmt.Sprintf("ClientError: %v", v.ClientError)
		i++
	}
	if v.ServerError != nil {
		fields[i] = fmt.Sprintf("ServerError: %v", v.ServerError)
		i++
	}
	if v.SchemaError != nil {
		fields[i] = fmt.Sprintf("SchemaError: %v", v.SchemaError)
		i++
	}
	if v.LimitError != nil {
		fields[i] = fmt.Sprintf("LimitError: %v", v.LimitError)
		i++
	}

	return fmt.Sprintf("Dosa_CanUpsertSchema_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_CanUpsertSchema_Result match the
// provided Dosa_CanUpsertSchema_Result.
//
// This function performs a deep comparison.
func (v *Dosa_CanUpsertSchema_Result) Equals(rhs *Dosa_CanUpsertSchema_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.ClientError == nil && rhs.ClientError == nil) || (v.ClientError != nil && rhs.ClientError != nil && v.ClientError.Equals(rhs.ClientError))) {
		return false
	}
	if !((v.ServerError == nil && rhs.ServerError == nil) || (v.ServerError != nil && rhs.ServerError != nil && v.ServerError.Equals(rhs.ServerError))) {
		return false
	}
	if !((v.SchemaError == nil && rhs.SchemaError == nil) || (v.SchemaError != nil && rhs.SchemaError != nil && v.SchemaError.Equals(rhs.SchemaError))) {
		return false
	}
	if !((v.LimitError == nil && rhs.LimitError == nil) || (v.LimitError != nil && rhs.LimitError != nil && v.LimitError.Equals(rhs.LimitError))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_CanUpsertSchema_Result.
func (v *Dosa_CanUpsertSchema_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.ClientError != nil {
		err = multierr.Append(err, enc.AddObject("clientError", v.ClientError))
	}
	if v.ServerError != nil {
		err = multierr.Append(err, enc.AddObject("serverError", v.ServerError))
	}
	if v.SchemaError != nil {
		err = multierr.Append(err, enc.AddObject("schemaError", v.SchemaError))
	}
	if v.LimitError != nil {
		err = multierr.Append(err, enc.AddObject("limitError", v.LimitError))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Dosa_CanUpsertSchema_Result) GetSuccess() (o *CanUpsertSchemaResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Dosa_CanUpsertSchema_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetClientError returns the value of ClientError if it is set or its
// zero value if it is unset.
func (v *Dosa_CanUpsertSchema_Result) GetClientError() (o *BadRequestError) {
	if v != nil && v.ClientError != nil {
		return v.ClientError
	}

	return
}

// IsSetClientError returns true if ClientError is not nil.
func (v *Dosa_CanUpsertSchema_Result) IsSetClientError() bool {
	return v != nil && v.ClientError != nil
}

// GetServerError returns the value of ServerError if it is set or its
// zero value if it is unset.
func (v *Dosa_CanUpsertSchema_Result) GetServerError() (o *InternalServerError) {
	if v != nil && v.ServerError != nil {
		return v.ServerError
	}

	return
}

// IsSetServerError returns true if ServerError is not nil.
func (v *Dosa_CanUpsertSchema_Result) IsSetServerError() bool {
	return v != nil && v.ServerError != nil
}

// GetSchemaError returns the value of SchemaError if it is set or its
// zero value if it is unset.
func (v *Dosa_CanUpsertSchema_Result) GetSchemaError() (o *BadSchemaError) {
	if v != nil && v.SchemaError != nil {
		return v.SchemaError
	}

	return
}

// IsSetSchemaError returns true if SchemaError is not nil.
func (v *Dosa_CanUpsertSchema_Result) IsSetSchemaError() bool {
	return v != nil && v.SchemaError != nil
}

// GetLimitError returns the value of LimitError if it is set or its
// zero value if it is unset.
func (v *Dosa_CanUpsertSchema_Result) GetLimitError() (o *RateLimitError) {
	if v != nil && v.LimitError != nil {
		return v.LimitError
	}

	return
}

// IsSetLimitError returns true if LimitError is not nil.
func (v *Dosa_CanUpsertSchema_Result) IsSetLimitError() bool {
	return v != nil && v.LimitError != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "canUpsertSchema" for this struct.
func (v *Dosa_CanUpsertSchema_Result) MethodName() string {
	return "canUpsertSchema"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Dosa_CanUpsertSchema_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Dosa_CheckSchema_Args represents the arguments for the Dosa.checkSchema function.
//
// The arguments for checkSchema are sent and received over the wire as this struct.
type Dosa_CheckSchema_Args struct {
	Request *CheckSchemaRequest `json:"request,omitempty"`
}

// ToWire translates a Dosa_CheckSchema_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_CheckSchema_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _CheckSchemaRequest_Read(w wire.Value) (*CheckSchemaRequest, error) {
	var v CheckSchemaRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_CheckSchema_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_CheckSchema_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_CheckSchema_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_CheckSchema_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _CheckSchemaRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Dosa_CheckSchema_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_CheckSchema_Args struct could not be encoded.
func (v *Dosa_CheckSchema_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Request != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Request.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _CheckSchemaRequest_Decode(sr stream.Reader) (*CheckSchemaRequest, error) {
	var v CheckSchemaRequest
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_CheckSchema_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_CheckSchema_Args struct could not be generated from the wire
// representation.
func (v *Dosa_CheckSchema_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Request, err = _CheckSchemaRequest_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Dosa_CheckSchema_Args
// struct.
func (v *Dosa_CheckSchema_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("Dosa_CheckSchema_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_CheckSchema_Args match the
// provided Dosa_CheckSchema_Args.
//
// This function performs a deep comparison.
func (v *Dosa_CheckSchema_Args) Equals(rhs *Dosa_CheckSchema_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_CheckSchema_Args.
func (v *Dosa_CheckSchema_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Dosa_CheckSchema_Args) GetRequest() (o *CheckSchemaRequest) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Dosa_CheckSchema_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "checkSchema" for this struct.
func (v *Dosa_CheckSchema_Args) MethodName() string {
	return "checkSchema"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Dosa_CheckSchema_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Dosa_CheckSchema_Helper provides functions that aid in handling the
// parameters and return values of the Dosa.checkSchema
// function.
var Dosa_CheckSchema_Helper = struct {
	// Args accepts the parameters of checkSchema in-order and returns
	// the arguments struct for the function.
	Args func(
		request *CheckSchemaRequest,
	) *Dosa_CheckSchema_Args

	// IsException returns true if the given error can be thrown
	// by checkSchema.
	//
	// An error can be thrown by checkSchema only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for checkSchema
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// checkSchema into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by checkSchema
	//
	//   value, err := checkSchema(args)
	//   result, err := Dosa_CheckSchema_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from checkSchema: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*CheckSchemaResponse, error) (*Dosa_CheckSchema_Result, error)

	// UnwrapResponse takes the result struct for checkSchema
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if checkSchema threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Dosa_CheckSchema_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Dosa_CheckSchema_Result) (*CheckSchemaResponse, error)
}{}

func init() {
	Dosa_CheckSchema_Helper.Args = func(
		request *CheckSchemaRequest,
	) *Dosa_CheckSchema_Args {
		return &Dosa_CheckSchema_Args{
			Request: request,
		}
	}

	Dosa_CheckSchema_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BadRequestError:
			return true
		case *InternalServerError:
			return true
		case *BadSchemaError:
			return true
		case *RateLimitError:
			return true
		default:
			return false
		}
	}

	Dosa_CheckSchema_Helper.WrapResponse = func(success *CheckSchemaResponse, err error) (*Dosa_CheckSchema_Result, error) {
		if err == nil {
			return &Dosa_CheckSchema_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *BadRequestError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_CheckSchema_Result.ClientError")
			}
			return &Dosa_CheckSchema_Result{ClientError: e}, nil
		case *InternalServerError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_CheckSchema_Result.ServerError")
			}
			return &Dosa_CheckSchema_Result{ServerError: e}, nil
		case *BadSchemaError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_CheckSchema_Result.SchemaError")
			}
			return &Dosa_CheckSchema_Result{SchemaError: e}, nil
		case *RateLimitError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_CheckSchema_Result.LimitError")
			}
			return &Dosa_CheckSchema_Result{LimitError: e}, nil
		}

		return nil, err
	}
	Dosa_CheckSchema_Helper.UnwrapResponse = func(result *Dosa_CheckSchema_Result) (success *CheckSchemaResponse, err error) {
		if result.ClientError != nil {
			err = result.ClientError
			return
		}
		if result.ServerError != nil {
			err = result.ServerError
			return
		}
		if result.SchemaError != nil {
			err = result.SchemaError
			return
		}
		if result.LimitError != nil {
			err = result.LimitError
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Dosa_CheckSchema_Result represents the result of a Dosa.checkSchema function call.
//
// The result of a checkSchema execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Dosa_CheckSchema_Result struct {
	// Value returned by checkSchema after a successful execution.
	Success     *CheckSchemaResponse `json:"success,omitempty"`
	ClientError *BadRequestError     `json:"clientError,omitempty"`
	ServerError *InternalServerError `json:"serverError,omitempty"`
	SchemaError *BadSchemaError      `json:"schemaError,omitempty"`
	LimitError  *RateLimitError      `json:"limitError,omitempty"`
}

// ToWire translates a Dosa_CheckSchema_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_CheckSchema_Result) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.ClientError != nil {
		w, err = v.ClientError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ServerError != nil {
		w, err = v.ServerError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.SchemaError != nil {
		w, err = v.SchemaError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.LimitError != nil {
		w, err = v.LimitError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Dosa_CheckSchema_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _CheckSchemaResponse_Read(w wire.Value) (*CheckSchemaResponse, error) {
	var v CheckSchemaResponse
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_CheckSchema_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_CheckSchema_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_CheckSchema_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_CheckSchema_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _CheckSchemaResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ClientError, err = _BadRequestError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ServerError, err = _InternalServerError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.SchemaError, err = _BadSchemaError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TStruct {
				v.LimitError, err = _RateLimitError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.SchemaError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_CheckSchema_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a Dosa_CheckSchema_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_CheckSchema_Result struct could not be encoded.
func (v *Dosa_CheckSchema_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Success != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 0, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Success.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ClientError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ClientError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ServerError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ServerError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.SchemaError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.SchemaError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LimitError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 4, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.LimitError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.SchemaError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}

	if count != 1 {
		return fmt.Errorf("Dosa_CheckSchema_Result should have exactly one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

func _CheckSchemaResponse_Decode(sr stream.Reader) (*CheckSchemaResponse, error) {
	var v CheckSchemaResponse
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_CheckSchema_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_CheckSchema_Result struct could not be generated from the wire
// representation.
func (v *Dosa_CheckSchema_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 0 && fh.Type == wire.TStruct:
			v.Success, err = _CheckSchemaResponse_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.ClientError, err = _BadRequestError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.ServerError, err = _InternalServerError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TStruct:
			v.SchemaError, err = _BadSchemaError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 4 && fh.Type == wire.TStruct:
			v.LimitError, err = _RateLimitError_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.SchemaError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_CheckSchema_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Dosa_CheckSchema_Result
// struct.
func (v *Dosa_CheckSchema_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [5]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.ClientError != nil {
		fields[i] = fmt.Sprintf("ClientError: %v", v.ClientError)
		i++
	}
	if v.ServerError != nil {
		fields[i] = fmt.Sprintf("ServerError: %v", v.ServerError)
		i++
	}
	if v.SchemaError != nil {
		fields[i] = fmt.Sprintf("SchemaError: %v", v.SchemaError)
		i++
	}
	if v.LimitError != nil {
		fields[i] = fmt.Sprintf("LimitError: %v", v.LimitError)
		i++
	}

	return fmt.Sprintf("Dosa_CheckSchema_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_CheckSchema_Result match the
// provided Dosa_CheckSchema_Result.
//
// This function performs a deep comparison.
func (v *Dosa_CheckSchema_Result) Equals(rhs *Dosa_CheckSchema_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.ClientError == nil && rhs.ClientError == nil) || (v.ClientError != nil && rhs.ClientError != nil && v.ClientError.Equals(rhs.ClientError))) {
		return false
	}
	if !((v.ServerError == nil && rhs.ServerError == nil) || (v.ServerError != nil && rhs.ServerError != nil && v.ServerError.Equals(rhs.ServerError))) {
		return false
	}
	if !((v.SchemaError == nil && rhs.SchemaError == nil) || (v.SchemaError != nil && rhs.SchemaError != nil && v.SchemaError.Equals(rhs.SchemaError))) {
		return false
	}
	if !((v.LimitError == nil && rhs.LimitError == nil) || (v.LimitError != nil && rhs.LimitError != nil && v.LimitError.Equals(rhs.LimitError))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_CheckSchema_Result.
func (v *Dosa_CheckSchema_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.ClientError != nil {
		err = multierr.Append(err, enc.AddObject("clientError", v.ClientError))
	}
	if v.ServerError != nil {
		err = multierr.Append(err, enc.AddObject("serverError", v.ServerError))
	}
	if v.SchemaError != nil {
		err = multierr.Append(err, enc.AddObject("schemaError", v.SchemaError))
	}
	if v.LimitError != nil {
		err = multierr.Append(err, enc.AddObject("limitError", v.LimitError))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Dosa_CheckSchema_Result) GetSuccess() (o *CheckSchemaResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Dosa_CheckSchema_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetClientError returns the value of ClientError if it is set or its
// zero value if it is unset.
func (v *Dosa_CheckSchema_Result) GetClientError() (o *BadRequestError) {
	if v != nil && v.ClientError != nil {
		return v.ClientError
	}

	return
}

// IsSetClientError returns true if ClientError is not nil.
func (v *Dosa_CheckSchema_Result) IsSetClientError() bool {
	return v != nil && v.ClientError != nil
}

// GetServerError returns the value of ServerError if it is set or its
// zero value if it is unset.
func (v *Dosa_CheckSchema_Result) GetServerError() (o *InternalServerError) {
	if v != nil && v.ServerError != nil {
		return v.ServerError
	}

	return
}

// IsSetServerError returns true if ServerError is not nil.
func (v *Dosa_CheckSchema_Result) IsSetServerError() bool {
	return v != nil && v.ServerError != nil
}

// GetSchemaError returns the value of SchemaError if it is set or its
// zero value if it is unset.
func (v *Dosa_CheckSchema_Result) GetSchemaError() (o *BadSchemaError) {
	if v != nil && v.SchemaError != nil {
		return v.SchemaError
	}

	return
}

// IsSetSchemaError returns true if SchemaError is not nil.
func (v *Dosa_CheckSchema_Result) IsSetSchemaError() bool {
	return v != nil && v.SchemaError != nil
}

// GetLimitError returns the value of LimitError if it is set or its
// zero value if it is unset.
func (v *Dosa_CheckSchema_Result) GetLimitError() (o *RateLimitError) {
	if v != nil && v.LimitError != nil {
		return v.LimitError
	}

	return
}

// IsSetLimitError returns true if LimitError is not nil.
func (v *Dosa_CheckSchema_Result) IsSetLimitError() bool {
	return v != nil && v.LimitError != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "checkSchema" for this struct.
func (v *Dosa_CheckSchema_Result) MethodName() string {
	return "checkSchema"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Dosa_CheckSchema_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Dosa_CheckSchemaStatus_Args represents the arguments for the Dosa.checkSchemaStatus function.
//
// The arguments for checkSchemaStatus are sent and received over the wire as this struct.
type Dosa_CheckSchemaStatus_Args struct {
	Request *CheckSchemaStatusRequest `json:"request,omitempty"`
}

// ToWire translates a Dosa_CheckSchemaStatus_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_CheckSchemaStatus_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _CheckSchemaStatusRequest_Read(w wire.Value) (*CheckSchemaStatusRequest, error) {
	var v CheckSchemaStatusRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_CheckSchemaStatus_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_CheckSchemaStatus_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_CheckSchemaStatus_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_CheckSchemaStatus_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _CheckSchemaStatusRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Dosa_CheckSchemaStatus_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_CheckSchemaStatus_Args struct could not be encoded.
func (v *Dosa_CheckSchemaStatus_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Request != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Request.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _CheckSchemaStatusRequest_Decode(sr stream.Reader) (*CheckSchemaStatusRequest, error) {
	var v CheckSchemaStatusRequest
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_CheckSchemaStatus_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_CheckSchemaStatus_Args struct could not be generated from the wire
// representation.
func (v *Dosa_CheckSchemaStatus_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Request, err = _CheckSchemaStatusRequest_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Dosa_CheckSchemaStatus_Args
// struct.
func (v *Dosa_CheckSchemaStatus_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("Dosa_CheckSchemaStatus_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_CheckSchemaStatus_Args match the
// provided Dosa_CheckSchemaStatus_Args.
//
// This function performs a deep comparison.
func (v *Dosa_CheckSchemaStatus_Args) Equals(rhs *Dosa_CheckSchemaStatus_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_CheckSchemaStatus_Args.
func (v *Dosa_CheckSchemaStatus_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Dosa_CheckSchemaStatus_Args) GetRequest() (o *CheckSchemaStatusRequest) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Dosa_CheckSchemaStatus_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "checkSchemaStatus" for this struct.
func (v *Dosa_CheckSchemaStatus_Args) MethodName() string {
	return "checkSchemaStatus"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Dosa_CheckSchemaStatus_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Dosa_CheckSchemaStatus_Helper provides functions that aid in handling the
// parameters and return values of the Dosa.checkSchemaStatus
// function.
var Dosa_CheckSchemaStatus_Helper = struct {
	// Args accepts the parameters of checkSchemaStatus in-order and returns
	// the arguments struct for the function.
	Args func(
		request *CheckSchemaStatusRequest,
	) *Dosa_CheckSchemaStatus_Args

	// IsException returns true if the given error can be thrown
	// by checkSchemaStatus.
	//
	// An error can be thrown by checkSchemaStatus only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for checkSchemaStatus
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// checkSchemaStatus into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by checkSchemaStatus
	//
	//   value, err := checkSchemaStatus(args)
	//   result, err := Dosa_CheckSchemaStatus_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from checkSchemaStatus: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*CheckSchemaStatusResponse, error) (*Dosa_CheckSchemaStatus_Result, error)

	// UnwrapResponse takes the result struct for checkSchemaStatus
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if checkSchemaStatus threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Dosa_CheckSchemaStatus_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Dosa_CheckSchemaStatus_Result) (*CheckSchemaStatusResponse, error)
}{}

func init() {
	Dosa_CheckSchemaStatus_Helper.Args = func(
		request *CheckSchemaStatusRequest,
	) *Dosa_CheckSchemaStatus_Args {
		return &Dosa_CheckSchemaStatus_Args{
			Request: request,
		}
	}

	Dosa_CheckSchemaStatus_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BadRequestError:
			return true
		case *InternalServerError:
			return true
		case *RateLimitError:
			return true
		default:
			return false
		}
	}

	Dosa_CheckSchemaStatus_Helper.WrapResponse = func(success *CheckSchemaStatusResponse, err error) (*Dosa_CheckSchemaStatus_Result, error) {
		if err == nil {
			return &Dosa_CheckSchemaStatus_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *BadRequestError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_CheckSchemaStatus_Result.ClientError")
			}
			return &Dosa_CheckSchemaStatus_Result{ClientError: e}, nil
		case *InternalServerError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_CheckSchemaStatus_Result.ServerError")
			}
			return &Dosa_CheckSchemaStatus_Result{ServerError: e}, nil
		case *RateLimitError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_CheckSchemaStatus_Result.LimitError")
			}
			return &Dosa_CheckSchemaStatus_Result{LimitError: e}, nil
		}

		return nil, err
	}
	Dosa_CheckSchemaStatus_Helper.UnwrapResponse = func(result *Dosa_CheckSchemaStatus_Result) (success *CheckSchemaStatusResponse, err error) {
		if result.ClientError != nil {
			err = result.ClientError
			return
		}
		if result.ServerError != nil {
			err = result.ServerError
			return
		}
		if result.LimitError != nil {
			err = result.LimitError
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Dosa_CheckSchemaStatus_Result represents the result of a Dosa.checkSchemaStatus function call.
//
// The result of a checkSchemaStatus execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Dosa_CheckSchemaStatus_Result struct {
	// Value returned by checkSchemaStatus after a successful execution.
	Success     *CheckSchemaStatusResponse `json:"success,omitempty"`
	ClientError *BadRequestError           `json:"clientError,omitempty"`
	ServerError *InternalServerError       `json:"serverError,omitempty"`
	LimitError  *RateLimitError            `json:"limitError,omitempty"`
}

// ToWire translates a Dosa_CheckSchemaStatus_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_CheckSchemaStatus_Result) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.ClientError != nil {
		w, err = v.ClientError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ServerError != nil {
		w, err = v.ServerError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.LimitError != nil {
		w, err = v.LimitError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Dosa_CheckSchemaStatus_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _CheckSchemaStatusResponse_Read(w wire.Value) (*CheckSchemaStatusResponse, error) {
	var v CheckSchemaStatusResponse
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_CheckSchemaStatus_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_CheckSchemaStatus_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_CheckSchemaStatus_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_CheckSchemaStatus_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _CheckSchemaStatusResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ClientError, err = _BadRequestError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ServerError, err = _InternalServerError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.LimitError, err = _RateLimitError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_CheckSchemaStatus_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a Dosa_CheckSchemaStatus_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_CheckSchemaStatus_Result struct could not be encoded.
func (v *Dosa_CheckSchemaStatus_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Success != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 0, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Success.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ClientError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ClientError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ServerError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ServerError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LimitError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.LimitError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}

	if count != 1 {
		return fmt.Errorf("Dosa_CheckSchemaStatus_Result should have exactly one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

func _CheckSchemaStatusResponse_Decode(sr stream.Reader) (*CheckSchemaStatusResponse, error) {
	var v CheckSchemaStatusResponse
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_CheckSchemaStatus_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_CheckSchemaStatus_Result struct could not be generated from the wire
// representation.
func (v *Dosa_CheckSchemaStatus_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 0 && fh.Type == wire.TStruct:
			v.Success, err = _CheckSchemaStatusResponse_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.ClientError, err = _BadRequestError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.ServerError, err = _InternalServerError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TStruct:
			v.LimitError, err = _RateLimitError_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_CheckSchemaStatus_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Dosa_CheckSchemaStatus_Result
// struct.
func (v *Dosa_CheckSchemaStatus_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.ClientError != nil {
		fields[i] = fmt.Sprintf("ClientError: %v", v.ClientError)
		i++
	}
	if v.ServerError != nil {
		fields[i] = fmt.Sprintf("ServerError: %v", v.ServerError)
		i++
	}
	if v.LimitError != nil {
		fields[i] = fmt.Sprintf("LimitError: %v", v.LimitError)
		i++
	}

	return fmt.Sprintf("Dosa_CheckSchemaStatus_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_CheckSchemaStatus_Result match the
// provided Dosa_CheckSchemaStatus_Result.
//
// This function performs a deep comparison.
func (v *Dosa_CheckSchemaStatus_Result) Equals(rhs *Dosa_CheckSchemaStatus_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.ClientError == nil && rhs.ClientError == nil) || (v.ClientError != nil && rhs.ClientError != nil && v.ClientError.Equals(rhs.ClientError))) {
		return false
	}
	if !((v.ServerError == nil && rhs.ServerError == nil) || (v.ServerError != nil && rhs.ServerError != nil && v.ServerError.Equals(rhs.ServerError))) {
		return false
	}
	if !((v.LimitError == nil && rhs.LimitError == nil) || (v.LimitError != nil && rhs.LimitError != nil && v.LimitError.Equals(rhs.LimitError))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_CheckSchemaStatus_Result.
func (v *Dosa_CheckSchemaStatus_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.ClientError != nil {
		err = multierr.Append(err, enc.AddObject("clientError", v.ClientError))
	}
	if v.ServerError != nil {
		err = multierr.Append(err, enc.AddObject("serverError", v.ServerError))
	}
	if v.LimitError != nil {
		err = multierr.Append(err, enc.AddObject("limitError", v.LimitError))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Dosa_CheckSchemaStatus_Result) GetSuccess() (o *CheckSchemaStatusResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Dosa_CheckSchemaStatus_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetClientError returns the value of ClientError if it is set or its
// zero value if it is unset.
func (v *Dosa_CheckSchemaStatus_Result) GetClientError() (o *BadRequestError) {
	if v != nil && v.ClientError != nil {
		return v.ClientError
	}

	return
}

// IsSetClientError returns true if ClientError is not nil.
func (v *Dosa_CheckSchemaStatus_Result) IsSetClientError() bool {
	return v != nil && v.ClientError != nil
}

// GetServerError returns the value of ServerError if it is set or its
// zero value if it is unset.
func (v *Dosa_CheckSchemaStatus_Result) GetServerError() (o *InternalServerError) {
	if v != nil && v.ServerError != nil {
		return v.ServerError
	}

	return
}

// IsSetServerError returns true if ServerError is not nil.
func (v *Dosa_CheckSchemaStatus_Result) IsSetServerError() bool {
	return v != nil && v.ServerError != nil
}

// GetLimitError returns the value of LimitError if it is set or its
// zero value if it is unset.
func (v *Dosa_CheckSchemaStatus_Result) GetLimitError() (o *RateLimitError) {
	if v != nil && v.LimitError != nil {
		return v.LimitError
	}

	return
}

// IsSetLimitError returns true if LimitError is not nil.
func (v *Dosa_CheckSchemaStatus_Result) IsSetLimitError() bool {
	return v != nil && v.LimitError != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "checkSchemaStatus" for this struct.
func (v *Dosa_CheckSchemaStatus_Result) MethodName() string {
	return "checkSchemaStatus"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Dosa_CheckSchemaStatus_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Dosa_CreateIfNotExists_Args represents the arguments for the Dosa.createIfNotExists function.
//
// The arguments for createIfNotExists are sent and received over the wire as this struct.
type Dosa_CreateIfNotExists_Args struct {
	Request *CreateRequest `json:"request,omitempty"`
}

// ToWire translates a Dosa_CreateIfNotExists_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_CreateIfNotExists_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _CreateRequest_Read(w wire.Value) (*CreateRequest, error) {
	var v CreateRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_CreateIfNotExists_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_CreateIfNotExists_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_CreateIfNotExists_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_CreateIfNotExists_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _CreateRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Dosa_CreateIfNotExists_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_CreateIfNotExists_Args struct could not be encoded.
func (v *Dosa_CreateIfNotExists_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Request != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Request.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _CreateRequest_Decode(sr stream.Reader) (*CreateRequest, error) {
	var v CreateRequest
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_CreateIfNotExists_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_CreateIfNotExists_Args struct could not be generated from the wire
// representation.
func (v *Dosa_CreateIfNotExists_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Request, err = _CreateRequest_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Dosa_CreateIfNotExists_Args
// struct.
func (v *Dosa_CreateIfNotExists_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("Dosa_CreateIfNotExists_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_CreateIfNotExists_Args match the
// provided Dosa_CreateIfNotExists_Args.
//
// This function performs a deep comparison.
func (v *Dosa_CreateIfNotExists_Args) Equals(rhs *Dosa_CreateIfNotExists_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_CreateIfNotExists_Args.
func (v *Dosa_CreateIfNotExists_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Dosa_CreateIfNotExists_Args) GetRequest() (o *CreateRequest) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Dosa_CreateIfNotExists_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "createIfNotExists" for this struct.
func (v *Dosa_CreateIfNotExists_Args) MethodName() string {
	return "createIfNotExists"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Dosa_CreateIfNotExists_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Dosa_CreateIfNotExists_Helper provides functions that aid in handling the
// parameters and return values of the Dosa.createIfNotExists
// function.
var Dosa_CreateIfNotExists_Helper = struct {
	// Args accepts the parameters of createIfNotExists in-order and returns
	// the arguments struct for the function.
	Args func(
		request *CreateRequest,
	) *Dosa_CreateIfNotExists_Args

	// IsException returns true if the given error can be thrown
	// by createIfNotExists.
	//
	// An error can be thrown by createIfNotExists only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for createIfNotExists
	// given the error returned by it. The provided error may
	// be nil if createIfNotExists did not fail.
	//
	// This allows mapping errors returned by createIfNotExists into a
	// serializable result struct. WrapResponse returns a
	// non-nil error if the provided error cannot be thrown by
	// createIfNotExists
	//
	//   err := createIfNotExists(args)
	//   result, err := Dosa_CreateIfNotExists_Helper.WrapResponse(err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from createIfNotExists: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(error) (*Dosa_CreateIfNotExists_Result, error)

	// UnwrapResponse takes the result struct for createIfNotExists
	// and returns the erorr returned by it (if any).
	//
	// The error is non-nil only if createIfNotExists threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   err := Dosa_CreateIfNotExists_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Dosa_CreateIfNotExists_Result) error
}{}

func init() {
	Dosa_CreateIfNotExists_Helper.Args = func(
		request *CreateRequest,
	) *Dosa_CreateIfNotExists_Args {
		return &Dosa_CreateIfNotExists_Args{
			Request: request,
		}
	}

	Dosa_CreateIfNotExists_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BadRequestError:
			return true
		case *InternalServerError:
			return true
		case *RateLimitError:
			return true
		default:
			return false
		}
	}

	Dosa_CreateIfNotExists_Helper.WrapResponse = func(err error) (*Dosa_CreateIfNotExists_Result, error) {
		if err == nil {
			return &Dosa_CreateIfNotExists_Result{}, nil
		}

		switch e := err.(type) {
		case *BadRequestError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_CreateIfNotExists_Result.ClientError")
			}
			return &Dosa_CreateIfNotExists_Result{ClientError: e}, nil
		case *InternalServerError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_CreateIfNotExists_Result.ServerError")
			}
			return &Dosa_CreateIfNotExists_Result{ServerError: e}, nil
		case *RateLimitError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_CreateIfNotExists_Result.LimitError")
			}
			return &Dosa_CreateIfNotExists_Result{LimitError: e}, nil
		}

		return nil, err
	}
	Dosa_CreateIfNotExists_Helper.UnwrapResponse = func(result *Dosa_CreateIfNotExists_Result) (err error) {
		if result.ClientError != nil {
			err = result.ClientError
			return
		}
		if result.ServerError != nil {
			err = result.ServerError
			return
		}
		if result.LimitError != nil {
			err = result.LimitError
			return
		}
		return
	}

}

// Dosa_CreateIfNotExists_Result represents the result of a Dosa.createIfNotExists function call.
//
// The result of a createIfNotExists execution is sent and received over the wire as this struct.
type Dosa_CreateIfNotExists_Result struct {
	ClientError *BadRequestError     `json:"clientError,omitempty"`
	ServerError *InternalServerError `json:"serverError,omitempty"`
	LimitError  *RateLimitError      `json:"limitError,omitempty"`
}

// ToWire translates a Dosa_CreateIfNotExists_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_CreateIfNotExists_Result) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ClientError != nil {
		w, err = v.ClientError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ServerError != nil {
		w, err = v.ServerError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.LimitError != nil {
		w, err = v.LimitError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	if i > 1 {
		return wire.Value{}, fmt.Errorf("Dosa_CreateIfNotExists_Result should have at most one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Dosa_CreateIfNotExists_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_CreateIfNotExists_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_CreateIfNotExists_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_CreateIfNotExists_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ClientError, err = _BadRequestError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ServerError, err = _InternalServerError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.LimitError, err = _RateLimitError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count > 1 {
		return fmt.Errorf("Dosa_CreateIfNotExists_Result should have at most one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a Dosa_CreateIfNotExists_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_CreateIfNotExists_Result struct could not be encoded.
func (v *Dosa_CreateIfNotExists_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.ClientError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ClientError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ServerError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ServerError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LimitError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.LimitError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}

	if count > 1 {
		return fmt.Errorf("Dosa_CreateIfNotExists_Result should have at most one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a Dosa_CreateIfNotExists_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_CreateIfNotExists_Result struct could not be generated from the wire
// representation.
func (v *Dosa_CreateIfNotExists_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.ClientError, err = _BadRequestError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.ServerError, err = _InternalServerError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TStruct:
			v.LimitError, err = _RateLimitError_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count > 1 {
		return fmt.Errorf("Dosa_CreateIfNotExists_Result should have at most one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Dosa_CreateIfNotExists_Result
// struct.
func (v *Dosa_CreateIfNotExists_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.ClientError != nil {
		fields[i] = fmt.Sprintf("ClientError: %v", v.ClientError)
		i++
	}
	if v.ServerError != nil {
		fields[i] = fmt.Sprintf("ServerError: %v", v.ServerError)
		i++
	}
	if v.LimitError != nil {
		fields[i] = fmt.Sprintf("LimitError: %v", v.LimitError)
		i++
	}

	return fmt.Sprintf("Dosa_CreateIfNotExists_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_CreateIfNotExists_Result match the
// provided Dosa_CreateIfNotExists_Result.
//
// This function performs a deep comparison.
func (v *Dosa_CreateIfNotExists_Result) Equals(rhs *Dosa_CreateIfNotExists_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.ClientError == nil && rhs.ClientError == nil) || (v.ClientError != nil && rhs.ClientError != nil && v.ClientError.Equals(rhs.ClientError))) {
		return false
	}
	if !((v.ServerError == nil && rhs.ServerError == nil) || (v.ServerError != nil && rhs.ServerError != nil && v.ServerError.Equals(rhs.ServerError))) {
		return false
	}
	if !((v.LimitError == nil && rhs.LimitError == nil) || (v.LimitError != nil && rhs.LimitError != nil && v.LimitError.Equals(rhs.LimitError))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_CreateIfNotExists_Result.
func (v *Dosa_CreateIfNotExists_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ClientError != nil {
		err = multierr.Append(err, enc.AddObject("clientError", v.ClientError))
	}
	if v.ServerError != nil {
		err = multierr.Append(err, enc.AddObject("serverError", v.ServerError))
	}
	if v.LimitError != nil {
		err = multierr.Append(err, enc.AddObject("limitError", v.LimitError))
	}
	return err
}

// GetClientError returns the value of ClientError if it is set or its
// zero value if it is unset.
func (v *Dosa_CreateIfNotExists_Result) GetClientError() (o *BadRequestError) {
	if v != nil && v.ClientError != nil {
		return v.ClientError
	}

	return
}

// IsSetClientError returns true if ClientError is not nil.
func (v *Dosa_CreateIfNotExists_Result) IsSetClientError() bool {
	return v != nil && v.ClientError != nil
}

// GetServerError returns the value of ServerError if it is set or its
// zero value if it is unset.
func (v *Dosa_CreateIfNotExists_Result) GetServerError() (o *InternalServerError) {
	if v != nil && v.ServerError != nil {
		return v.ServerError
	}

	return
}

// IsSetServerError returns true if ServerError is not nil.
func (v *Dosa_CreateIfNotExists_Result) IsSetServerError() bool {
	return v != nil && v.ServerError != nil
}

// GetLimitError returns the value of LimitError if it is set or its
// zero value if it is unset.
func (v *Dosa_CreateIfNotExists_Result) GetLimitError() (o *RateLimitError) {
	if v != nil && v.LimitError != nil {
		return v.LimitError
	}

	return
}

// IsSetLimitError returns true if LimitError is not nil.
func (v *Dosa_CreateIfNotExists_Result) IsSetLimitError() bool {
	return v != nil && v.LimitError != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "createIfNotExists" for this struct.
func (v *Dosa_CreateIfNotExists_Result) MethodName() string {
	return "createIfNotExists"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Dosa_CreateIfNotExists_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Dosa_CreateScope_Args represents the arguments for the Dosa.createScope function.
//
// The arguments for createScope are sent and received over the wire as this struct.
type Dosa_CreateScope_Args struct {
	Request *CreateScopeRequest `json:"request,omitempty"`
}

// ToWire translates a Dosa_CreateScope_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_CreateScope_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _CreateScopeRequest_Read(w wire.Value) (*CreateScopeRequest, error) {
	var v CreateScopeRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_CreateScope_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_CreateScope_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_CreateScope_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_CreateScope_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _CreateScopeRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Dosa_CreateScope_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_CreateScope_Args struct could not be encoded.
func (v *Dosa_CreateScope_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Request != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Request.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _CreateScopeRequest_Decode(sr stream.Reader) (*CreateScopeRequest, error) {
	var v CreateScopeRequest
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_CreateScope_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_CreateScope_Args struct could not be generated from the wire
// representation.
func (v *Dosa_CreateScope_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Request, err = _CreateScopeRequest_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Dosa_CreateScope_Args
// struct.
func (v *Dosa_CreateScope_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("Dosa_CreateScope_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_CreateScope_Args match the
// provided Dosa_CreateScope_Args.
//
// This function performs a deep comparison.
func (v *Dosa_CreateScope_Args) Equals(rhs *Dosa_CreateScope_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_CreateScope_Args.
func (v *Dosa_CreateScope_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Dosa_CreateScope_Args) GetRequest() (o *CreateScopeRequest) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Dosa_CreateScope_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "createScope" for this struct.
func (v *Dosa_CreateScope_Args) MethodName() string {
	return "createScope"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Dosa_CreateScope_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Dosa_CreateScope_Helper provides functions that aid in handling the
// parameters and return values of the Dosa.createScope
// function.
var Dosa_CreateScope_Helper = struct {
	// Args accepts the parameters of createScope in-order and returns
	// the arguments struct for the function.
	Args func(
		request *CreateScopeRequest,
	) *Dosa_CreateScope_Args

	// IsException returns true if the given error can be thrown
	// by createScope.
	//
	// An error can be thrown by createScope only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for createScope
	// given the error returned by it. The provided error may
	// be nil if createScope did not fail.
	//
	// This allows mapping errors returned by createScope into a
	// serializable result struct. WrapResponse returns a
	// non-nil error if the provided error cannot be thrown by
	// createScope
	//
	//   err := createScope(args)
	//   result, err := Dosa_CreateScope_Helper.WrapResponse(err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from createScope: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(error) (*Dosa_CreateScope_Result, error)

	// UnwrapResponse takes the result struct for createScope
	// and returns the erorr returned by it (if any).
	//
	// The error is non-nil only if createScope threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   err := Dosa_CreateScope_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Dosa_CreateScope_Result) error
}{}

func init() {
	Dosa_CreateScope_Helper.Args = func(
		request *CreateScopeRequest,
	) *Dosa_CreateScope_Args {
		return &Dosa_CreateScope_Args{
			Request: request,
		}
	}

	Dosa_CreateScope_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BadRequestError:
			return true
		case *InternalServerError:
			return true
		case *RateLimitError:
			return true
		default:
			return false
		}
	}

	Dosa_CreateScope_Helper.WrapResponse = func(err error) (*Dosa_CreateScope_Result, error) {
		if err == nil {
			return &Dosa_CreateScope_Result{}, nil
		}

		switch e := err.(type) {
		case *BadRequestError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_CreateScope_Result.ClientError")
			}
			return &Dosa_CreateScope_Result{ClientError: e}, nil
		case *InternalServerError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_CreateScope_Result.ServerError")
			}
			return &Dosa_CreateScope_Result{ServerError: e}, nil
		case *RateLimitError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_CreateScope_Result.LimitError")
			}
			return &Dosa_CreateScope_Result{LimitError: e}, nil
		}

		return nil, err
	}
	Dosa_CreateScope_Helper.UnwrapResponse = func(result *Dosa_CreateScope_Result) (err error) {
		if result.ClientError != nil {
			err = result.ClientError
			return
		}
		if result.ServerError != nil {
			err = result.ServerError
			return
		}
		if result.LimitError != nil {
			err = result.LimitError
			return
		}
		return
	}

}

// Dosa_CreateScope_Result represents the result of a Dosa.createScope function call.
//
// The result of a createScope execution is sent and received over the wire as this struct.
type Dosa_CreateScope_Result struct {
	ClientError *BadRequestError     `json:"clientError,omitempty"`
	ServerError *InternalServerError `json:"serverError,omitempty"`
	LimitError  *RateLimitError      `json:"limitError,omitempty"`
}

// ToWire translates a Dosa_CreateScope_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_CreateScope_Result) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ClientError != nil {
		w, err = v.ClientError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ServerError != nil {
		w, err = v.ServerError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.LimitError != nil {
		w, err = v.LimitError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	if i > 1 {
		return wire.Value{}, fmt.Errorf("Dosa_CreateScope_Result should have at most one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Dosa_CreateScope_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_CreateScope_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_CreateScope_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_CreateScope_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ClientError, err = _BadRequestError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ServerError, err = _InternalServerError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.LimitError, err = _RateLimitError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count > 1 {
		return fmt.Errorf("Dosa_CreateScope_Result should have at most one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a Dosa_CreateScope_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_CreateScope_Result struct could not be encoded.
func (v *Dosa_CreateScope_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.ClientError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ClientError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ServerError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ServerError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LimitError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.LimitError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}

	if count > 1 {
		return fmt.Errorf("Dosa_CreateScope_Result should have at most one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a Dosa_CreateScope_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_CreateScope_Result struct could not be generated from the wire
// representation.
func (v *Dosa_CreateScope_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.ClientError, err = _BadRequestError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.ServerError, err = _InternalServerError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TStruct:
			v.LimitError, err = _RateLimitError_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count > 1 {
		return fmt.Errorf("Dosa_CreateScope_Result should have at most one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Dosa_CreateScope_Result
// struct.
func (v *Dosa_CreateScope_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.ClientError != nil {
		fields[i] = fmt.Sprintf("ClientError: %v", v.ClientError)
		i++
	}
	if v.ServerError != nil {
		fields[i] = fmt.Sprintf("ServerError: %v", v.ServerError)
		i++
	}
	if v.LimitError != nil {
		fields[i] = fmt.Sprintf("LimitError: %v", v.LimitError)
		i++
	}

	return fmt.Sprintf("Dosa_CreateScope_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_CreateScope_Result match the
// provided Dosa_CreateScope_Result.
//
// This function performs a deep comparison.
func (v *Dosa_CreateScope_Result) Equals(rhs *Dosa_CreateScope_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.ClientError == nil && rhs.ClientError == nil) || (v.ClientError != nil && rhs.ClientError != nil && v.ClientError.Equals(rhs.ClientError))) {
		return false
	}
	if !((v.ServerError == nil && rhs.ServerError == nil) || (v.ServerError != nil && rhs.ServerError != nil && v.ServerError.Equals(rhs.ServerError))) {
		return false
	}
	if !((v.LimitError == nil && rhs.LimitError == nil) || (v.LimitError != nil && rhs.LimitError != nil && v.LimitError.Equals(rhs.LimitError))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_CreateScope_Result.
func (v *Dosa_CreateScope_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ClientError != nil {
		err = multierr.Append(err, enc.AddObject("clientError", v.ClientError))
	}
	if v.ServerError != nil {
		err = multierr.Append(err, enc.AddObject("serverError", v.ServerError))
	}
	if v.LimitError != nil {
		err = multierr.Append(err, enc.AddObject("limitError", v.LimitError))
	}
	return err
}

// GetClientError returns the value of ClientError if it is set or its
// zero value if it is unset.
func (v *Dosa_CreateScope_Result) GetClientError() (o *BadRequestError) {
	if v != nil && v.ClientError != nil {
		return v.ClientError
	}

	return
}

// IsSetClientError returns true if ClientError is not nil.
func (v *Dosa_CreateScope_Result) IsSetClientError() bool {
	return v != nil && v.ClientError != nil
}

// GetServerError returns the value of ServerError if it is set or its
// zero value if it is unset.
func (v *Dosa_CreateScope_Result) GetServerError() (o *InternalServerError) {
	if v != nil && v.ServerError != nil {
		return v.ServerError
	}

	return
}

// IsSetServerError returns true if ServerError is not nil.
func (v *Dosa_CreateScope_Result) IsSetServerError() bool {
	return v != nil && v.ServerError != nil
}

// GetLimitError returns the value of LimitError if it is set or its
// zero value if it is unset.
func (v *Dosa_CreateScope_Result) GetLimitError() (o *RateLimitError) {
	if v != nil && v.LimitError != nil {
		return v.LimitError
	}

	return
}

// IsSetLimitError returns true if LimitError is not nil.
func (v *Dosa_CreateScope_Result) IsSetLimitError() bool {
	return v != nil && v.LimitError != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "createScope" for this struct.
func (v *Dosa_CreateScope_Result) MethodName() string {
	return "createScope"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Dosa_CreateScope_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Dosa_DropScope_Args represents the arguments for the Dosa.dropScope function.
//
// The arguments for dropScope are sent and received over the wire as this struct.
type Dosa_DropScope_Args struct {
	Request *DropScopeRequest `json:"request,omitempty"`
}

// ToWire translates a Dosa_DropScope_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_DropScope_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _DropScopeRequest_Read(w wire.Value) (*DropScopeRequest, error) {
	var v DropScopeRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_DropScope_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_DropScope_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_DropScope_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_DropScope_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _DropScopeRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Dosa_DropScope_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_DropScope_Args struct could not be encoded.
func (v *Dosa_DropScope_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Request != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Request.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _DropScopeRequest_Decode(sr stream.Reader) (*DropScopeRequest, error) {
	var v DropScopeRequest
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_DropScope_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_DropScope_Args struct could not be generated from the wire
// representation.
func (v *Dosa_DropScope_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Request, err = _DropScopeRequest_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Dosa_DropScope_Args
// struct.
func (v *Dosa_DropScope_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("Dosa_DropScope_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_DropScope_Args match the
// provided Dosa_DropScope_Args.
//
// This function performs a deep comparison.
func (v *Dosa_DropScope_Args) Equals(rhs *Dosa_DropScope_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_DropScope_Args.
func (v *Dosa_DropScope_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Dosa_DropScope_Args) GetRequest() (o *DropScopeRequest) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Dosa_DropScope_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "dropScope" for this struct.
func (v *Dosa_DropScope_Args) MethodName() string {
	return "dropScope"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Dosa_DropScope_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Dosa_DropScope_Helper provides functions that aid in handling the
// parameters and return values of the Dosa.dropScope
// function.
var Dosa_DropScope_Helper = struct {
	// Args accepts the parameters of dropScope in-order and returns
	// the arguments struct for the function.
	Args func(
		request *DropScopeRequest,
	) *Dosa_DropScope_Args

	// IsException returns true if the given error can be thrown
	// by dropScope.
	//
	// An error can be thrown by dropScope only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for dropScope
	// given the error returned by it. The provided error may
	// be nil if dropScope did not fail.
	//
	// This allows mapping errors returned by dropScope into a
	// serializable result struct. WrapResponse returns a
	// non-nil error if the provided error cannot be thrown by
	// dropScope
	//
	//   err := dropScope(args)
	//   result, err := Dosa_DropScope_Helper.WrapResponse(err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from dropScope: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(error) (*Dosa_DropScope_Result, error)

	// UnwrapResponse takes the result struct for dropScope
	// and returns the erorr returned by it (if any).
	//
	// The error is non-nil only if dropScope threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   err := Dosa_DropScope_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Dosa_DropScope_Result) error
}{}

func init() {
	Dosa_DropScope_Helper.Args = func(
		request *DropScopeRequest,
	) *Dosa_DropScope_Args {
		return &Dosa_DropScope_Args{
			Request: request,
		}
	}

	Dosa_DropScope_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BadRequestError:
			return true
		case *InternalServerError:
			return true
		case *RateLimitError:
			return true
		default:
			return false
		}
	}

	Dosa_DropScope_Helper.WrapResponse = func(err error) (*Dosa_DropScope_Result, error) {
		if err == nil {
			return &Dosa_DropScope_Result{}, nil
		}

		switch e := err.(type) {
		case *BadRequestError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_DropScope_Result.ClientError")
			}
			return &Dosa_DropScope_Result{ClientError: e}, nil
		case *InternalServerError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_DropScope_Result.ServerError")
			}
			return &Dosa_DropScope_Result{ServerError: e}, nil
		case *RateLimitError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_DropScope_Result.LimitError")
			}
			return &Dosa_DropScope_Result{LimitError: e}, nil
		}

		return nil, err
	}
	Dosa_DropScope_Helper.UnwrapResponse = func(result *Dosa_DropScope_Result) (err error) {
		if result.ClientError != nil {
			err = result.ClientError
			return
		}
		if result.ServerError != nil {
			err = result.ServerError
			return
		}
		if result.LimitError != nil {
			err = result.LimitError
			return
		}
		return
	}

}

// Dosa_DropScope_Result represents the result of a Dosa.dropScope function call.
//
// The result of a dropScope execution is sent and received over the wire as this struct.
type Dosa_DropScope_Result struct {
	ClientError *BadRequestError     `json:"clientError,omitempty"`
	ServerError *InternalServerError `json:"serverError,omitempty"`
	LimitError  *RateLimitError      `json:"limitError,omitempty"`
}

// ToWire translates a Dosa_DropScope_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_DropScope_Result) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ClientError != nil {
		w, err = v.ClientError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ServerError != nil {
		w, err = v.ServerError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.LimitError != nil {
		w, err = v.LimitError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	if i > 1 {
		return wire.Value{}, fmt.Errorf("Dosa_DropScope_Result should have at most one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Dosa_DropScope_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_DropScope_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_DropScope_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_DropScope_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ClientError, err = _BadRequestError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ServerError, err = _InternalServerError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.LimitError, err = _RateLimitError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count > 1 {
		return fmt.Errorf("Dosa_DropScope_Result should have at most one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a Dosa_DropScope_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_DropScope_Result struct could not be encoded.
func (v *Dosa_DropScope_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.ClientError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ClientError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ServerError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ServerError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LimitError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.LimitError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}

	if count > 1 {
		return fmt.Errorf("Dosa_DropScope_Result should have at most one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a Dosa_DropScope_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_DropScope_Result struct could not be generated from the wire
// representation.
func (v *Dosa_DropScope_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.ClientError, err = _BadRequestError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.ServerError, err = _InternalServerError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TStruct:
			v.LimitError, err = _RateLimitError_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count > 1 {
		return fmt.Errorf("Dosa_DropScope_Result should have at most one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Dosa_DropScope_Result
// struct.
func (v *Dosa_DropScope_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.ClientError != nil {
		fields[i] = fmt.Sprintf("ClientError: %v", v.ClientError)
		i++
	}
	if v.ServerError != nil {
		fields[i] = fmt.Sprintf("ServerError: %v", v.ServerError)
		i++
	}
	if v.LimitError != nil {
		fields[i] = fmt.Sprintf("LimitError: %v", v.LimitError)
		i++
	}

	return fmt.Sprintf("Dosa_DropScope_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_DropScope_Result match the
// provided Dosa_DropScope_Result.
//
// This function performs a deep comparison.
func (v *Dosa_DropScope_Result) Equals(rhs *Dosa_DropScope_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.ClientError == nil && rhs.ClientError == nil) || (v.ClientError != nil && rhs.ClientError != nil && v.ClientError.Equals(rhs.ClientError))) {
		return false
	}
	if !((v.ServerError == nil && rhs.ServerError == nil) || (v.ServerError != nil && rhs.ServerError != nil && v.ServerError.Equals(rhs.ServerError))) {
		return false
	}
	if !((v.LimitError == nil && rhs.LimitError == nil) || (v.LimitError != nil && rhs.LimitError != nil && v.LimitError.Equals(rhs.LimitError))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_DropScope_Result.
func (v *Dosa_DropScope_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ClientError != nil {
		err = multierr.Append(err, enc.AddObject("clientError", v.ClientError))
	}
	if v.ServerError != nil {
		err = multierr.Append(err, enc.AddObject("serverError", v.ServerError))
	}
	if v.LimitError != nil {
		err = multierr.Append(err, enc.AddObject("limitError", v.LimitError))
	}
	return err
}

// GetClientError returns the value of ClientError if it is set or its
// zero value if it is unset.
func (v *Dosa_DropScope_Result) GetClientError() (o *BadRequestError) {
	if v != nil && v.ClientError != nil {
		return v.ClientError
	}

	return
}

// IsSetClientError returns true if ClientError is not nil.
func (v *Dosa_DropScope_Result) IsSetClientError() bool {
	return v != nil && v.ClientError != nil
}

// GetServerError returns the value of ServerError if it is set or its
// zero value if it is unset.
func (v *Dosa_DropScope_Result) GetServerError() (o *InternalServerError) {
	if v != nil && v.ServerError != nil {
		return v.ServerError
	}

	return
}

// IsSetServerError returns true if ServerError is not nil.
func (v *Dosa_DropScope_Result) IsSetServerError() bool {
	return v != nil && v.ServerError != nil
}

// GetLimitError returns the value of LimitError if it is set or its
// zero value if it is unset.
func (v *Dosa_DropScope_Result) GetLimitError() (o *RateLimitError) {
	if v != nil && v.LimitError != nil {
		return v.LimitError
	}

	return
}

// IsSetLimitError returns true if LimitError is not nil.
func (v *Dosa_DropScope_Result) IsSetLimitError() bool {
	return v != nil && v.LimitError != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "dropScope" for this struct.
func (v *Dosa_DropScope_Result) MethodName() string {
	return "dropScope"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Dosa_DropScope_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Dosa_MultiRead_Args represents the arguments for the Dosa.multiRead function.
//
// The arguments for multiRead are sent and received over the wire as this struct.
type Dosa_MultiRead_Args struct {
	Request *MultiReadRequest `json:"request,omitempty"`
}

// ToWire translates a Dosa_MultiRead_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_MultiRead_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _MultiReadRequest_Read(w wire.Value) (*MultiReadRequest, error) {
	var v MultiReadRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_MultiRead_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_MultiRead_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_MultiRead_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_MultiRead_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _MultiReadRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Dosa_MultiRead_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_MultiRead_Args struct could not be encoded.
func (v *Dosa_MultiRead_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Request != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Request.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _MultiReadRequest_Decode(sr stream.Reader) (*MultiReadRequest, error) {
	var v MultiReadRequest
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_MultiRead_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_MultiRead_Args struct could not be generated from the wire
// representation.
func (v *Dosa_MultiRead_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Request, err = _MultiReadRequest_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Dosa_MultiRead_Args
// struct.
func (v *Dosa_MultiRead_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("Dosa_MultiRead_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_MultiRead_Args match the
// provided Dosa_MultiRead_Args.
//
// This function performs a deep comparison.
func (v *Dosa_MultiRead_Args) Equals(rhs *Dosa_MultiRead_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_MultiRead_Args.
func (v *Dosa_MultiRead_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Dosa_MultiRead_Args) GetRequest() (o *MultiReadRequest) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Dosa_MultiRead_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "multiRead" for this struct.
func (v *Dosa_MultiRead_Args) MethodName() string {
	return "multiRead"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Dosa_MultiRead_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Dosa_MultiRead_Helper provides functions that aid in handling the
// parameters and return values of the Dosa.multiRead
// function.
var Dosa_MultiRead_Helper = struct {
	// Args accepts the parameters of multiRead in-order and returns
	// the arguments struct for the function.
	Args func(
		request *MultiReadRequest,
	) *Dosa_MultiRead_Args

	// IsException returns true if the given error can be thrown
	// by multiRead.
	//
	// An error can be thrown by multiRead only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for multiRead
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// multiRead into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by multiRead
	//
	//   value, err := multiRead(args)
	//   result, err := Dosa_MultiRead_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from multiRead: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*MultiReadResponse, error) (*Dosa_MultiRead_Result, error)

	// UnwrapResponse takes the result struct for multiRead
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if multiRead threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Dosa_MultiRead_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Dosa_MultiRead_Result) (*MultiReadResponse, error)
}{}

func init() {
	Dosa_MultiRead_Helper.Args = func(
		request *MultiReadRequest,
	) *Dosa_MultiRead_Args {
		return &Dosa_MultiRead_Args{
			Request: request,
		}
	}

	Dosa_MultiRead_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BadRequestError:
			return true
		case *InternalServerError:
			return true
		case *RateLimitError:
			return true
		default:
			return false
		}
	}

	Dosa_MultiRead_Helper.WrapResponse = func(success *MultiReadResponse, err error) (*Dosa_MultiRead_Result, error) {
		if err == nil {
			return &Dosa_MultiRead_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *BadRequestError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_MultiRead_Result.ClientError")
			}
			return &Dosa_MultiRead_Result{ClientError: e}, nil
		case *InternalServerError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_MultiRead_Result.ServerError")
			}
			return &Dosa_MultiRead_Result{ServerError: e}, nil
		case *RateLimitError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_MultiRead_Result.LimitError")
			}
			return &Dosa_MultiRead_Result{LimitError: e}, nil
		}

		return nil, err
	}
	Dosa_MultiRead_Helper.UnwrapResponse = func(result *Dosa_MultiRead_Result) (success *MultiReadResponse, err error) {
		if result.ClientError != nil {
			err = result.ClientError
			return
		}
		if result.ServerError != nil {
			err = result.ServerError
			return
		}
		if result.LimitError != nil {
			err = result.LimitError
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Dosa_MultiRead_Result represents the result of a Dosa.multiRead function call.
//
// The result of a multiRead execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Dosa_MultiRead_Result struct {
	// Value returned by multiRead after a successful execution.
	Success     *MultiReadResponse   `json:"success,omitempty"`
	ClientError *BadRequestError     `json:"clientError,omitempty"`
	ServerError *InternalServerError `json:"serverError,omitempty"`
	LimitError  *RateLimitError      `json:"limitError,omitempty"`
}

// ToWire translates a Dosa_MultiRead_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_MultiRead_Result) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.ClientError != nil {
		w, err = v.ClientError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ServerError != nil {
		w, err = v.ServerError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.LimitError != nil {
		w, err = v.LimitError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Dosa_MultiRead_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _MultiReadResponse_Read(w wire.Value) (*MultiReadResponse, error) {
	var v MultiReadResponse
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_MultiRead_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_MultiRead_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_MultiRead_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_MultiRead_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _MultiReadResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ClientError, err = _BadRequestError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ServerError, err = _InternalServerError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.LimitError, err = _RateLimitError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_MultiRead_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a Dosa_MultiRead_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_MultiRead_Result struct could not be encoded.
func (v *Dosa_MultiRead_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Success != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 0, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Success.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ClientError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ClientError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ServerError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ServerError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LimitError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.LimitError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}

	if count != 1 {
		return fmt.Errorf("Dosa_MultiRead_Result should have exactly one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

func _MultiReadResponse_Decode(sr stream.Reader) (*MultiReadResponse, error) {
	var v MultiReadResponse
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_MultiRead_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_MultiRead_Result struct could not be generated from the wire
// representation.
func (v *Dosa_MultiRead_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 0 && fh.Type == wire.TStruct:
			v.Success, err = _MultiReadResponse_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.ClientError, err = _BadRequestError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.ServerError, err = _InternalServerError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TStruct:
			v.LimitError, err = _RateLimitError_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_MultiRead_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Dosa_MultiRead_Result
// struct.
func (v *Dosa_MultiRead_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.ClientError != nil {
		fields[i] = fmt.Sprintf("ClientError: %v", v.ClientError)
		i++
	}
	if v.ServerError != nil {
		fields[i] = fmt.Sprintf("ServerError: %v", v.ServerError)
		i++
	}
	if v.LimitError != nil {
		fields[i] = fmt.Sprintf("LimitError: %v", v.LimitError)
		i++
	}

	return fmt.Sprintf("Dosa_MultiRead_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_MultiRead_Result match the
// provided Dosa_MultiRead_Result.
//
// This function performs a deep comparison.
func (v *Dosa_MultiRead_Result) Equals(rhs *Dosa_MultiRead_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.ClientError == nil && rhs.ClientError == nil) || (v.ClientError != nil && rhs.ClientError != nil && v.ClientError.Equals(rhs.ClientError))) {
		return false
	}
	if !((v.ServerError == nil && rhs.ServerError == nil) || (v.ServerError != nil && rhs.ServerError != nil && v.ServerError.Equals(rhs.ServerError))) {
		return false
	}
	if !((v.LimitError == nil && rhs.LimitError == nil) || (v.LimitError != nil && rhs.LimitError != nil && v.LimitError.Equals(rhs.LimitError))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_MultiRead_Result.
func (v *Dosa_MultiRead_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.ClientError != nil {
		err = multierr.Append(err, enc.AddObject("clientError", v.ClientError))
	}
	if v.ServerError != nil {
		err = multierr.Append(err, enc.AddObject("serverError", v.ServerError))
	}
	if v.LimitError != nil {
		err = multierr.Append(err, enc.AddObject("limitError", v.LimitError))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Dosa_MultiRead_Result) GetSuccess() (o *MultiReadResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Dosa_MultiRead_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetClientError returns the value of ClientError if it is set or its
// zero value if it is unset.
func (v *Dosa_MultiRead_Result) GetClientError() (o *BadRequestError) {
	if v != nil && v.ClientError != nil {
		return v.ClientError
	}

	return
}

// IsSetClientError returns true if ClientError is not nil.
func (v *Dosa_MultiRead_Result) IsSetClientError() bool {
	return v != nil && v.ClientError != nil
}

// GetServerError returns the value of ServerError if it is set or its
// zero value if it is unset.
func (v *Dosa_MultiRead_Result) GetServerError() (o *InternalServerError) {
	if v != nil && v.ServerError != nil {
		return v.ServerError
	}

	return
}

// IsSetServerError returns true if ServerError is not nil.
func (v *Dosa_MultiRead_Result) IsSetServerError() bool {
	return v != nil && v.ServerError != nil
}

// GetLimitError returns the value of LimitError if it is set or its
// zero value if it is unset.
func (v *Dosa_MultiRead_Result) GetLimitError() (o *RateLimitError) {
	if v != nil && v.LimitError != nil {
		return v.LimitError
	}

	return
}

// IsSetLimitError returns true if LimitError is not nil.
func (v *Dosa_MultiRead_Result) IsSetLimitError() bool {
	return v != nil && v.LimitError != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "multiRead" for this struct.
func (v *Dosa_MultiRead_Result) MethodName() string {
	return "multiRead"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Dosa_MultiRead_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Dosa_MultiRemove_Args represents the arguments for the Dosa.multiRemove function.
//
// The arguments for multiRemove are sent and received over the wire as this struct.
type Dosa_MultiRemove_Args struct {
	Request *MultiRemoveRequest `json:"request,omitempty"`
}

// ToWire translates a Dosa_MultiRemove_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_MultiRemove_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _MultiRemoveRequest_Read(w wire.Value) (*MultiRemoveRequest, error) {
	var v MultiRemoveRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_MultiRemove_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_MultiRemove_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_MultiRemove_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_MultiRemove_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _MultiRemoveRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Dosa_MultiRemove_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_MultiRemove_Args struct could not be encoded.
func (v *Dosa_MultiRemove_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Request != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Request.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _MultiRemoveRequest_Decode(sr stream.Reader) (*MultiRemoveRequest, error) {
	var v MultiRemoveRequest
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_MultiRemove_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_MultiRemove_Args struct could not be generated from the wire
// representation.
func (v *Dosa_MultiRemove_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Request, err = _MultiRemoveRequest_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Dosa_MultiRemove_Args
// struct.
func (v *Dosa_MultiRemove_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("Dosa_MultiRemove_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_MultiRemove_Args match the
// provided Dosa_MultiRemove_Args.
//
// This function performs a deep comparison.
func (v *Dosa_MultiRemove_Args) Equals(rhs *Dosa_MultiRemove_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_MultiRemove_Args.
func (v *Dosa_MultiRemove_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Dosa_MultiRemove_Args) GetRequest() (o *MultiRemoveRequest) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Dosa_MultiRemove_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "multiRemove" for this struct.
func (v *Dosa_MultiRemove_Args) MethodName() string {
	return "multiRemove"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Dosa_MultiRemove_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Dosa_MultiRemove_Helper provides functions that aid in handling the
// parameters and return values of the Dosa.multiRemove
// function.
var Dosa_MultiRemove_Helper = struct {
	// Args accepts the parameters of multiRemove in-order and returns
	// the arguments struct for the function.
	Args func(
		request *MultiRemoveRequest,
	) *Dosa_MultiRemove_Args

	// IsException returns true if the given error can be thrown
	// by multiRemove.
	//
	// An error can be thrown by multiRemove only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for multiRemove
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// multiRemove into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by multiRemove
	//
	//   value, err := multiRemove(args)
	//   result, err := Dosa_MultiRemove_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from multiRemove: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*MultiRemoveResponse, error) (*Dosa_MultiRemove_Result, error)

	// UnwrapResponse takes the result struct for multiRemove
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if multiRemove threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Dosa_MultiRemove_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Dosa_MultiRemove_Result) (*MultiRemoveResponse, error)
}{}

func init() {
	Dosa_MultiRemove_Helper.Args = func(
		request *MultiRemoveRequest,
	) *Dosa_MultiRemove_Args {
		return &Dosa_MultiRemove_Args{
			Request: request,
		}
	}

	Dosa_MultiRemove_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BadRequestError:
			return true
		case *InternalServerError:
			return true
		case *RateLimitError:
			return true
		default:
			return false
		}
	}

	Dosa_MultiRemove_Helper.WrapResponse = func(success *MultiRemoveResponse, err error) (*Dosa_MultiRemove_Result, error) {
		if err == nil {
			return &Dosa_MultiRemove_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *BadRequestError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_MultiRemove_Result.ClientError")
			}
			return &Dosa_MultiRemove_Result{ClientError: e}, nil
		case *InternalServerError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_MultiRemove_Result.ServerError")
			}
			return &Dosa_MultiRemove_Result{ServerError: e}, nil
		case *RateLimitError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_MultiRemove_Result.LimitError")
			}
			return &Dosa_MultiRemove_Result{LimitError: e}, nil
		}

		return nil, err
	}
	Dosa_MultiRemove_Helper.UnwrapResponse = func(result *Dosa_MultiRemove_Result) (success *MultiRemoveResponse, err error) {
		if result.ClientError != nil {
			err = result.ClientError
			return
		}
		if result.ServerError != nil {
			err = result.ServerError
			return
		}
		if result.LimitError != nil {
			err = result.LimitError
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Dosa_MultiRemove_Result represents the result of a Dosa.multiRemove function call.
//
// The result of a multiRemove execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Dosa_MultiRemove_Result struct {
	// Value returned by multiRemove after a successful execution.
	Success     *MultiRemoveResponse `json:"success,omitempty"`
	ClientError *BadRequestError     `json:"clientError,omitempty"`
	ServerError *InternalServerError `json:"serverError,omitempty"`
	LimitError  *RateLimitError      `json:"limitError,omitempty"`
}

// ToWire translates a Dosa_MultiRemove_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_MultiRemove_Result) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.ClientError != nil {
		w, err = v.ClientError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ServerError != nil {
		w, err = v.ServerError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.LimitError != nil {
		w, err = v.LimitError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Dosa_MultiRemove_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _MultiRemoveResponse_Read(w wire.Value) (*MultiRemoveResponse, error) {
	var v MultiRemoveResponse
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_MultiRemove_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_MultiRemove_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_MultiRemove_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_MultiRemove_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _MultiRemoveResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ClientError, err = _BadRequestError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ServerError, err = _InternalServerError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.LimitError, err = _RateLimitError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_MultiRemove_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a Dosa_MultiRemove_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_MultiRemove_Result struct could not be encoded.
func (v *Dosa_MultiRemove_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Success != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 0, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Success.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ClientError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ClientError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ServerError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ServerError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LimitError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.LimitError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}

	if count != 1 {
		return fmt.Errorf("Dosa_MultiRemove_Result should have exactly one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

func _MultiRemoveResponse_Decode(sr stream.Reader) (*MultiRemoveResponse, error) {
	var v MultiRemoveResponse
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_MultiRemove_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_MultiRemove_Result struct could not be generated from the wire
// representation.
func (v *Dosa_MultiRemove_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 0 && fh.Type == wire.TStruct:
			v.Success, err = _MultiRemoveResponse_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.ClientError, err = _BadRequestError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.ServerError, err = _InternalServerError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TStruct:
			v.LimitError, err = _RateLimitError_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_MultiRemove_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Dosa_MultiRemove_Result
// struct.
func (v *Dosa_MultiRemove_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.ClientError != nil {
		fields[i] = fmt.Sprintf("ClientError: %v", v.ClientError)
		i++
	}
	if v.ServerError != nil {
		fields[i] = fmt.Sprintf("ServerError: %v", v.ServerError)
		i++
	}
	if v.LimitError != nil {
		fields[i] = fmt.Sprintf("LimitError: %v", v.LimitError)
		i++
	}

	return fmt.Sprintf("Dosa_MultiRemove_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_MultiRemove_Result match the
// provided Dosa_MultiRemove_Result.
//
// This function performs a deep comparison.
func (v *Dosa_MultiRemove_Result) Equals(rhs *Dosa_MultiRemove_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.ClientError == nil && rhs.ClientError == nil) || (v.ClientError != nil && rhs.ClientError != nil && v.ClientError.Equals(rhs.ClientError))) {
		return false
	}
	if !((v.ServerError == nil && rhs.ServerError == nil) || (v.ServerError != nil && rhs.ServerError != nil && v.ServerError.Equals(rhs.ServerError))) {
		return false
	}
	if !((v.LimitError == nil && rhs.LimitError == nil) || (v.LimitError != nil && rhs.LimitError != nil && v.LimitError.Equals(rhs.LimitError))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_MultiRemove_Result.
func (v *Dosa_MultiRemove_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.ClientError != nil {
		err = multierr.Append(err, enc.AddObject("clientError", v.ClientError))
	}
	if v.ServerError != nil {
		err = multierr.Append(err, enc.AddObject("serverError", v.ServerError))
	}
	if v.LimitError != nil {
		err = multierr.Append(err, enc.AddObject("limitError", v.LimitError))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Dosa_MultiRemove_Result) GetSuccess() (o *MultiRemoveResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Dosa_MultiRemove_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetClientError returns the value of ClientError if it is set or its
// zero value if it is unset.
func (v *Dosa_MultiRemove_Result) GetClientError() (o *BadRequestError) {
	if v != nil && v.ClientError != nil {
		return v.ClientError
	}

	return
}

// IsSetClientError returns true if ClientError is not nil.
func (v *Dosa_MultiRemove_Result) IsSetClientError() bool {
	return v != nil && v.ClientError != nil
}

// GetServerError returns the value of ServerError if it is set or its
// zero value if it is unset.
func (v *Dosa_MultiRemove_Result) GetServerError() (o *InternalServerError) {
	if v != nil && v.ServerError != nil {
		return v.ServerError
	}

	return
}

// IsSetServerError returns true if ServerError is not nil.
func (v *Dosa_MultiRemove_Result) IsSetServerError() bool {
	return v != nil && v.ServerError != nil
}

// GetLimitError returns the value of LimitError if it is set or its
// zero value if it is unset.
func (v *Dosa_MultiRemove_Result) GetLimitError() (o *RateLimitError) {
	if v != nil && v.LimitError != nil {
		return v.LimitError
	}

	return
}

// IsSetLimitError returns true if LimitError is not nil.
func (v *Dosa_MultiRemove_Result) IsSetLimitError() bool {
	return v != nil && v.LimitError != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "multiRemove" for this struct.
func (v *Dosa_MultiRemove_Result) MethodName() string {
	return "multiRemove"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Dosa_MultiRemove_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Dosa_MultiUpsert_Args represents the arguments for the Dosa.multiUpsert function.
//
// The arguments for multiUpsert are sent and received over the wire as this struct.
type Dosa_MultiUpsert_Args struct {
	Request *MultiUpsertRequest `json:"request,omitempty"`
}

// ToWire translates a Dosa_MultiUpsert_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_MultiUpsert_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _MultiUpsertRequest_Read(w wire.Value) (*MultiUpsertRequest, error) {
	var v MultiUpsertRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_MultiUpsert_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_MultiUpsert_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_MultiUpsert_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_MultiUpsert_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _MultiUpsertRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Dosa_MultiUpsert_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_MultiUpsert_Args struct could not be encoded.
func (v *Dosa_MultiUpsert_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Request != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Request.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _MultiUpsertRequest_Decode(sr stream.Reader) (*MultiUpsertRequest, error) {
	var v MultiUpsertRequest
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_MultiUpsert_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_MultiUpsert_Args struct could not be generated from the wire
// representation.
func (v *Dosa_MultiUpsert_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Request, err = _MultiUpsertRequest_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Dosa_MultiUpsert_Args
// struct.
func (v *Dosa_MultiUpsert_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("Dosa_MultiUpsert_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_MultiUpsert_Args match the
// provided Dosa_MultiUpsert_Args.
//
// This function performs a deep comparison.
func (v *Dosa_MultiUpsert_Args) Equals(rhs *Dosa_MultiUpsert_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_MultiUpsert_Args.
func (v *Dosa_MultiUpsert_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Dosa_MultiUpsert_Args) GetRequest() (o *MultiUpsertRequest) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Dosa_MultiUpsert_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "multiUpsert" for this struct.
func (v *Dosa_MultiUpsert_Args) MethodName() string {
	return "multiUpsert"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Dosa_MultiUpsert_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Dosa_MultiUpsert_Helper provides functions that aid in handling the
// parameters and return values of the Dosa.multiUpsert
// function.
var Dosa_MultiUpsert_Helper = struct {
	// Args accepts the parameters of multiUpsert in-order and returns
	// the arguments struct for the function.
	Args func(
		request *MultiUpsertRequest,
	) *Dosa_MultiUpsert_Args

	// IsException returns true if the given error can be thrown
	// by multiUpsert.
	//
	// An error can be thrown by multiUpsert only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for multiUpsert
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// multiUpsert into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by multiUpsert
	//
	//   value, err := multiUpsert(args)
	//   result, err := Dosa_MultiUpsert_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from multiUpsert: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*MultiUpsertResponse, error) (*Dosa_MultiUpsert_Result, error)

	// UnwrapResponse takes the result struct for multiUpsert
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if multiUpsert threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Dosa_MultiUpsert_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Dosa_MultiUpsert_Result) (*MultiUpsertResponse, error)
}{}

func init() {
	Dosa_MultiUpsert_Helper.Args = func(
		request *MultiUpsertRequest,
	) *Dosa_MultiUpsert_Args {
		return &Dosa_MultiUpsert_Args{
			Request: request,
		}
	}

	Dosa_MultiUpsert_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BadRequestError:
			return true
		case *InternalServerError:
			return true
		case *RateLimitError:
			return true
		default:
			return false
		}
	}

	Dosa_MultiUpsert_Helper.WrapResponse = func(success *MultiUpsertResponse, err error) (*Dosa_MultiUpsert_Result, error) {
		if err == nil {
			return &Dosa_MultiUpsert_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *BadRequestError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_MultiUpsert_Result.ClientError")
			}
			return &Dosa_MultiUpsert_Result{ClientError: e}, nil
		case *InternalServerError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_MultiUpsert_Result.ServerError")
			}
			return &Dosa_MultiUpsert_Result{ServerError: e}, nil
		case *RateLimitError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_MultiUpsert_Result.LimitError")
			}
			return &Dosa_MultiUpsert_Result{LimitError: e}, nil
		}

		return nil, err
	}
	Dosa_MultiUpsert_Helper.UnwrapResponse = func(result *Dosa_MultiUpsert_Result) (success *MultiUpsertResponse, err error) {
		if result.ClientError != nil {
			err = result.ClientError
			return
		}
		if result.ServerError != nil {
			err = result.ServerError
			return
		}
		if result.LimitError != nil {
			err = result.LimitError
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Dosa_MultiUpsert_Result represents the result of a Dosa.multiUpsert function call.
//
// The result of a multiUpsert execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Dosa_MultiUpsert_Result struct {
	// Value returned by multiUpsert after a successful execution.
	Success     *MultiUpsertResponse `json:"success,omitempty"`
	ClientError *BadRequestError     `json:"clientError,omitempty"`
	ServerError *InternalServerError `json:"serverError,omitempty"`
	LimitError  *RateLimitError      `json:"limitError,omitempty"`
}

// ToWire translates a Dosa_MultiUpsert_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_MultiUpsert_Result) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.ClientError != nil {
		w, err = v.ClientError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ServerError != nil {
		w, err = v.ServerError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.LimitError != nil {
		w, err = v.LimitError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Dosa_MultiUpsert_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _MultiUpsertResponse_Read(w wire.Value) (*MultiUpsertResponse, error) {
	var v MultiUpsertResponse
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_MultiUpsert_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_MultiUpsert_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_MultiUpsert_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_MultiUpsert_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _MultiUpsertResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ClientError, err = _BadRequestError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ServerError, err = _InternalServerError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.LimitError, err = _RateLimitError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_MultiUpsert_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a Dosa_MultiUpsert_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_MultiUpsert_Result struct could not be encoded.
func (v *Dosa_MultiUpsert_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Success != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 0, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Success.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ClientError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ClientError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ServerError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ServerError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LimitError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.LimitError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}

	if count != 1 {
		return fmt.Errorf("Dosa_MultiUpsert_Result should have exactly one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

func _MultiUpsertResponse_Decode(sr stream.Reader) (*MultiUpsertResponse, error) {
	var v MultiUpsertResponse
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_MultiUpsert_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_MultiUpsert_Result struct could not be generated from the wire
// representation.
func (v *Dosa_MultiUpsert_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 0 && fh.Type == wire.TStruct:
			v.Success, err = _MultiUpsertResponse_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.ClientError, err = _BadRequestError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.ServerError, err = _InternalServerError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TStruct:
			v.LimitError, err = _RateLimitError_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_MultiUpsert_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Dosa_MultiUpsert_Result
// struct.
func (v *Dosa_MultiUpsert_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.ClientError != nil {
		fields[i] = fmt.Sprintf("ClientError: %v", v.ClientError)
		i++
	}
	if v.ServerError != nil {
		fields[i] = fmt.Sprintf("ServerError: %v", v.ServerError)
		i++
	}
	if v.LimitError != nil {
		fields[i] = fmt.Sprintf("LimitError: %v", v.LimitError)
		i++
	}

	return fmt.Sprintf("Dosa_MultiUpsert_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_MultiUpsert_Result match the
// provided Dosa_MultiUpsert_Result.
//
// This function performs a deep comparison.
func (v *Dosa_MultiUpsert_Result) Equals(rhs *Dosa_MultiUpsert_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.ClientError == nil && rhs.ClientError == nil) || (v.ClientError != nil && rhs.ClientError != nil && v.ClientError.Equals(rhs.ClientError))) {
		return false
	}
	if !((v.ServerError == nil && rhs.ServerError == nil) || (v.ServerError != nil && rhs.ServerError != nil && v.ServerError.Equals(rhs.ServerError))) {
		return false
	}
	if !((v.LimitError == nil && rhs.LimitError == nil) || (v.LimitError != nil && rhs.LimitError != nil && v.LimitError.Equals(rhs.LimitError))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_MultiUpsert_Result.
func (v *Dosa_MultiUpsert_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.ClientError != nil {
		err = multierr.Append(err, enc.AddObject("clientError", v.ClientError))
	}
	if v.ServerError != nil {
		err = multierr.Append(err, enc.AddObject("serverError", v.ServerError))
	}
	if v.LimitError != nil {
		err = multierr.Append(err, enc.AddObject("limitError", v.LimitError))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Dosa_MultiUpsert_Result) GetSuccess() (o *MultiUpsertResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Dosa_MultiUpsert_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetClientError returns the value of ClientError if it is set or its
// zero value if it is unset.
func (v *Dosa_MultiUpsert_Result) GetClientError() (o *BadRequestError) {
	if v != nil && v.ClientError != nil {
		return v.ClientError
	}

	return
}

// IsSetClientError returns true if ClientError is not nil.
func (v *Dosa_MultiUpsert_Result) IsSetClientError() bool {
	return v != nil && v.ClientError != nil
}

// GetServerError returns the value of ServerError if it is set or its
// zero value if it is unset.
func (v *Dosa_MultiUpsert_Result) GetServerError() (o *InternalServerError) {
	if v != nil && v.ServerError != nil {
		return v.ServerError
	}

	return
}

// IsSetServerError returns true if ServerError is not nil.
func (v *Dosa_MultiUpsert_Result) IsSetServerError() bool {
	return v != nil && v.ServerError != nil
}

// GetLimitError returns the value of LimitError if it is set or its
// zero value if it is unset.
func (v *Dosa_MultiUpsert_Result) GetLimitError() (o *RateLimitError) {
	if v != nil && v.LimitError != nil {
		return v.LimitError
	}

	return
}

// IsSetLimitError returns true if LimitError is not nil.
func (v *Dosa_MultiUpsert_Result) IsSetLimitError() bool {
	return v != nil && v.LimitError != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "multiUpsert" for this struct.
func (v *Dosa_MultiUpsert_Result) MethodName() string {
	return "multiUpsert"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Dosa_MultiUpsert_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Dosa_Range_Args represents the arguments for the Dosa.range function.
//
// The arguments for range are sent and received over the wire as this struct.
type Dosa_Range_Args struct {
	Request *RangeRequest `json:"request,omitempty"`
}

// ToWire translates a Dosa_Range_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_Range_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _RangeRequest_Read(w wire.Value) (*RangeRequest, error) {
	var v RangeRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_Range_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_Range_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_Range_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_Range_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _RangeRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Dosa_Range_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_Range_Args struct could not be encoded.
func (v *Dosa_Range_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Request != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Request.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _RangeRequest_Decode(sr stream.Reader) (*RangeRequest, error) {
	var v RangeRequest
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_Range_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_Range_Args struct could not be generated from the wire
// representation.
func (v *Dosa_Range_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Request, err = _RangeRequest_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Dosa_Range_Args
// struct.
func (v *Dosa_Range_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("Dosa_Range_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_Range_Args match the
// provided Dosa_Range_Args.
//
// This function performs a deep comparison.
func (v *Dosa_Range_Args) Equals(rhs *Dosa_Range_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_Range_Args.
func (v *Dosa_Range_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Dosa_Range_Args) GetRequest() (o *RangeRequest) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Dosa_Range_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "range" for this struct.
func (v *Dosa_Range_Args) MethodName() string {
	return "range"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Dosa_Range_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Dosa_Range_Helper provides functions that aid in handling the
// parameters and return values of the Dosa.range
// function.
var Dosa_Range_Helper = struct {
	// Args accepts the parameters of range in-order and returns
	// the arguments struct for the function.
	Args func(
		request *RangeRequest,
	) *Dosa_Range_Args

	// IsException returns true if the given error can be thrown
	// by range.
	//
	// An error can be thrown by range only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for range
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// range into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by range
	//
	//   value, err := range(args)
	//   result, err := Dosa_Range_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from range: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*RangeResponse, error) (*Dosa_Range_Result, error)

	// UnwrapResponse takes the result struct for range
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if range threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Dosa_Range_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Dosa_Range_Result) (*RangeResponse, error)
}{}

func init() {
	Dosa_Range_Helper.Args = func(
		request *RangeRequest,
	) *Dosa_Range_Args {
		return &Dosa_Range_Args{
			Request: request,
		}
	}

	Dosa_Range_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BadRequestError:
			return true
		case *InternalServerError:
			return true
		case *RateLimitError:
			return true
		default:
			return false
		}
	}

	Dosa_Range_Helper.WrapResponse = func(success *RangeResponse, err error) (*Dosa_Range_Result, error) {
		if err == nil {
			return &Dosa_Range_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *BadRequestError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_Range_Result.ClientError")
			}
			return &Dosa_Range_Result{ClientError: e}, nil
		case *InternalServerError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_Range_Result.ServerError")
			}
			return &Dosa_Range_Result{ServerError: e}, nil
		case *RateLimitError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_Range_Result.LimitError")
			}
			return &Dosa_Range_Result{LimitError: e}, nil
		}

		return nil, err
	}
	Dosa_Range_Helper.UnwrapResponse = func(result *Dosa_Range_Result) (success *RangeResponse, err error) {
		if result.ClientError != nil {
			err = result.ClientError
			return
		}
		if result.ServerError != nil {
			err = result.ServerError
			return
		}
		if result.LimitError != nil {
			err = result.LimitError
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Dosa_Range_Result represents the result of a Dosa.range function call.
//
// The result of a range execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Dosa_Range_Result struct {
	// Value returned by range after a successful execution.
	Success     *RangeResponse       `json:"success,omitempty"`
	ClientError *BadRequestError     `json:"clientError,omitempty"`
	ServerError *InternalServerError `json:"serverError,omitempty"`
	LimitError  *RateLimitError      `json:"limitError,omitempty"`
}

// ToWire translates a Dosa_Range_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_Range_Result) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.ClientError != nil {
		w, err = v.ClientError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ServerError != nil {
		w, err = v.ServerError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.LimitError != nil {
		w, err = v.LimitError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Dosa_Range_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _RangeResponse_Read(w wire.Value) (*RangeResponse, error) {
	var v RangeResponse
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_Range_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_Range_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_Range_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_Range_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _RangeResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ClientError, err = _BadRequestError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ServerError, err = _InternalServerError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.LimitError, err = _RateLimitError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_Range_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a Dosa_Range_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_Range_Result struct could not be encoded.
func (v *Dosa_Range_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Success != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 0, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Success.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ClientError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ClientError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ServerError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ServerError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LimitError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.LimitError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}

	if count != 1 {
		return fmt.Errorf("Dosa_Range_Result should have exactly one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

func _RangeResponse_Decode(sr stream.Reader) (*RangeResponse, error) {
	var v RangeResponse
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_Range_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_Range_Result struct could not be generated from the wire
// representation.
func (v *Dosa_Range_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 0 && fh.Type == wire.TStruct:
			v.Success, err = _RangeResponse_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.ClientError, err = _BadRequestError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.ServerError, err = _InternalServerError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TStruct:
			v.LimitError, err = _RateLimitError_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_Range_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Dosa_Range_Result
// struct.
func (v *Dosa_Range_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.ClientError != nil {
		fields[i] = fmt.Sprintf("ClientError: %v", v.ClientError)
		i++
	}
	if v.ServerError != nil {
		fields[i] = fmt.Sprintf("ServerError: %v", v.ServerError)
		i++
	}
	if v.LimitError != nil {
		fields[i] = fmt.Sprintf("LimitError: %v", v.LimitError)
		i++
	}

	return fmt.Sprintf("Dosa_Range_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_Range_Result match the
// provided Dosa_Range_Result.
//
// This function performs a deep comparison.
func (v *Dosa_Range_Result) Equals(rhs *Dosa_Range_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.ClientError == nil && rhs.ClientError == nil) || (v.ClientError != nil && rhs.ClientError != nil && v.ClientError.Equals(rhs.ClientError))) {
		return false
	}
	if !((v.ServerError == nil && rhs.ServerError == nil) || (v.ServerError != nil && rhs.ServerError != nil && v.ServerError.Equals(rhs.ServerError))) {
		return false
	}
	if !((v.LimitError == nil && rhs.LimitError == nil) || (v.LimitError != nil && rhs.LimitError != nil && v.LimitError.Equals(rhs.LimitError))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_Range_Result.
func (v *Dosa_Range_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.ClientError != nil {
		err = multierr.Append(err, enc.AddObject("clientError", v.ClientError))
	}
	if v.ServerError != nil {
		err = multierr.Append(err, enc.AddObject("serverError", v.ServerError))
	}
	if v.LimitError != nil {
		err = multierr.Append(err, enc.AddObject("limitError", v.LimitError))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Dosa_Range_Result) GetSuccess() (o *RangeResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Dosa_Range_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetClientError returns the value of ClientError if it is set or its
// zero value if it is unset.
func (v *Dosa_Range_Result) GetClientError() (o *BadRequestError) {
	if v != nil && v.ClientError != nil {
		return v.ClientError
	}

	return
}

// IsSetClientError returns true if ClientError is not nil.
func (v *Dosa_Range_Result) IsSetClientError() bool {
	return v != nil && v.ClientError != nil
}

// GetServerError returns the value of ServerError if it is set or its
// zero value if it is unset.
func (v *Dosa_Range_Result) GetServerError() (o *InternalServerError) {
	if v != nil && v.ServerError != nil {
		return v.ServerError
	}

	return
}

// IsSetServerError returns true if ServerError is not nil.
func (v *Dosa_Range_Result) IsSetServerError() bool {
	return v != nil && v.ServerError != nil
}

// GetLimitError returns the value of LimitError if it is set or its
// zero value if it is unset.
func (v *Dosa_Range_Result) GetLimitError() (o *RateLimitError) {
	if v != nil && v.LimitError != nil {
		return v.LimitError
	}

	return
}

// IsSetLimitError returns true if LimitError is not nil.
func (v *Dosa_Range_Result) IsSetLimitError() bool {
	return v != nil && v.LimitError != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "range" for this struct.
func (v *Dosa_Range_Result) MethodName() string {
	return "range"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Dosa_Range_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Dosa_Read_Args represents the arguments for the Dosa.read function.
//
// The arguments for read are sent and received over the wire as this struct.
type Dosa_Read_Args struct {
	Request *ReadRequest `json:"request,omitempty"`
}

// ToWire translates a Dosa_Read_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_Read_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ReadRequest_Read(w wire.Value) (*ReadRequest, error) {
	var v ReadRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_Read_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_Read_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_Read_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_Read_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _ReadRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Dosa_Read_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_Read_Args struct could not be encoded.
func (v *Dosa_Read_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Request != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Request.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _ReadRequest_Decode(sr stream.Reader) (*ReadRequest, error) {
	var v ReadRequest
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_Read_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_Read_Args struct could not be generated from the wire
// representation.
func (v *Dosa_Read_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Request, err = _ReadRequest_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Dosa_Read_Args
// struct.
func (v *Dosa_Read_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("Dosa_Read_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_Read_Args match the
// provided Dosa_Read_Args.
//
// This function performs a deep comparison.
func (v *Dosa_Read_Args) Equals(rhs *Dosa_Read_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_Read_Args.
func (v *Dosa_Read_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Dosa_Read_Args) GetRequest() (o *ReadRequest) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Dosa_Read_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "read" for this struct.
func (v *Dosa_Read_Args) MethodName() string {
	return "read"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Dosa_Read_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Dosa_Read_Helper provides functions that aid in handling the
// parameters and return values of the Dosa.read
// function.
var Dosa_Read_Helper = struct {
	// Args accepts the parameters of read in-order and returns
	// the arguments struct for the function.
	Args func(
		request *ReadRequest,
	) *Dosa_Read_Args

	// IsException returns true if the given error can be thrown
	// by read.
	//
	// An error can be thrown by read only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for read
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// read into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by read
	//
	//   value, err := read(args)
	//   result, err := Dosa_Read_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from read: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*ReadResponse, error) (*Dosa_Read_Result, error)

	// UnwrapResponse takes the result struct for read
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if read threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Dosa_Read_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Dosa_Read_Result) (*ReadResponse, error)
}{}

func init() {
	Dosa_Read_Helper.Args = func(
		request *ReadRequest,
	) *Dosa_Read_Args {
		return &Dosa_Read_Args{
			Request: request,
		}
	}

	Dosa_Read_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BadRequestError:
			return true
		case *InternalServerError:
			return true
		case *RateLimitError:
			return true
		default:
			return false
		}
	}

	Dosa_Read_Helper.WrapResponse = func(success *ReadResponse, err error) (*Dosa_Read_Result, error) {
		if err == nil {
			return &Dosa_Read_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *BadRequestError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_Read_Result.ClientError")
			}
			return &Dosa_Read_Result{ClientError: e}, nil
		case *InternalServerError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_Read_Result.ServerError")
			}
			return &Dosa_Read_Result{ServerError: e}, nil
		case *RateLimitError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_Read_Result.LimitError")
			}
			return &Dosa_Read_Result{LimitError: e}, nil
		}

		return nil, err
	}
	Dosa_Read_Helper.UnwrapResponse = func(result *Dosa_Read_Result) (success *ReadResponse, err error) {
		if result.ClientError != nil {
			err = result.ClientError
			return
		}
		if result.ServerError != nil {
			err = result.ServerError
			return
		}
		if result.LimitError != nil {
			err = result.LimitError
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Dosa_Read_Result represents the result of a Dosa.read function call.
//
// The result of a read execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Dosa_Read_Result struct {
	// Value returned by read after a successful execution.
	Success     *ReadResponse        `json:"success,omitempty"`
	ClientError *BadRequestError     `json:"clientError,omitempty"`
	ServerError *InternalServerError `json:"serverError,omitempty"`
	LimitError  *RateLimitError      `json:"limitError,omitempty"`
}

// ToWire translates a Dosa_Read_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_Read_Result) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.ClientError != nil {
		w, err = v.ClientError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ServerError != nil {
		w, err = v.ServerError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.LimitError != nil {
		w, err = v.LimitError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Dosa_Read_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ReadResponse_Read(w wire.Value) (*ReadResponse, error) {
	var v ReadResponse
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_Read_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_Read_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_Read_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_Read_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _ReadResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ClientError, err = _BadRequestError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ServerError, err = _InternalServerError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.LimitError, err = _RateLimitError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_Read_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a Dosa_Read_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_Read_Result struct could not be encoded.
func (v *Dosa_Read_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Success != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 0, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Success.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ClientError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ClientError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ServerError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ServerError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LimitError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.LimitError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}

	if count != 1 {
		return fmt.Errorf("Dosa_Read_Result should have exactly one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

func _ReadResponse_Decode(sr stream.Reader) (*ReadResponse, error) {
	var v ReadResponse
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_Read_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_Read_Result struct could not be generated from the wire
// representation.
func (v *Dosa_Read_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 0 && fh.Type == wire.TStruct:
			v.Success, err = _ReadResponse_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.ClientError, err = _BadRequestError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.ServerError, err = _InternalServerError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TStruct:
			v.LimitError, err = _RateLimitError_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_Read_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Dosa_Read_Result
// struct.
func (v *Dosa_Read_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.ClientError != nil {
		fields[i] = fmt.Sprintf("ClientError: %v", v.ClientError)
		i++
	}
	if v.ServerError != nil {
		fields[i] = fmt.Sprintf("ServerError: %v", v.ServerError)
		i++
	}
	if v.LimitError != nil {
		fields[i] = fmt.Sprintf("LimitError: %v", v.LimitError)
		i++
	}

	return fmt.Sprintf("Dosa_Read_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_Read_Result match the
// provided Dosa_Read_Result.
//
// This function performs a deep comparison.
func (v *Dosa_Read_Result) Equals(rhs *Dosa_Read_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.ClientError == nil && rhs.ClientError == nil) || (v.ClientError != nil && rhs.ClientError != nil && v.ClientError.Equals(rhs.ClientError))) {
		return false
	}
	if !((v.ServerError == nil && rhs.ServerError == nil) || (v.ServerError != nil && rhs.ServerError != nil && v.ServerError.Equals(rhs.ServerError))) {
		return false
	}
	if !((v.LimitError == nil && rhs.LimitError == nil) || (v.LimitError != nil && rhs.LimitError != nil && v.LimitError.Equals(rhs.LimitError))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_Read_Result.
func (v *Dosa_Read_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.ClientError != nil {
		err = multierr.Append(err, enc.AddObject("clientError", v.ClientError))
	}
	if v.ServerError != nil {
		err = multierr.Append(err, enc.AddObject("serverError", v.ServerError))
	}
	if v.LimitError != nil {
		err = multierr.Append(err, enc.AddObject("limitError", v.LimitError))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Dosa_Read_Result) GetSuccess() (o *ReadResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Dosa_Read_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetClientError returns the value of ClientError if it is set or its
// zero value if it is unset.
func (v *Dosa_Read_Result) GetClientError() (o *BadRequestError) {
	if v != nil && v.ClientError != nil {
		return v.ClientError
	}

	return
}

// IsSetClientError returns true if ClientError is not nil.
func (v *Dosa_Read_Result) IsSetClientError() bool {
	return v != nil && v.ClientError != nil
}

// GetServerError returns the value of ServerError if it is set or its
// zero value if it is unset.
func (v *Dosa_Read_Result) GetServerError() (o *InternalServerError) {
	if v != nil && v.ServerError != nil {
		return v.ServerError
	}

	return
}

// IsSetServerError returns true if ServerError is not nil.
func (v *Dosa_Read_Result) IsSetServerError() bool {
	return v != nil && v.ServerError != nil
}

// GetLimitError returns the value of LimitError if it is set or its
// zero value if it is unset.
func (v *Dosa_Read_Result) GetLimitError() (o *RateLimitError) {
	if v != nil && v.LimitError != nil {
		return v.LimitError
	}

	return
}

// IsSetLimitError returns true if LimitError is not nil.
func (v *Dosa_Read_Result) IsSetLimitError() bool {
	return v != nil && v.LimitError != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "read" for this struct.
func (v *Dosa_Read_Result) MethodName() string {
	return "read"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Dosa_Read_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Dosa_Remove_Args represents the arguments for the Dosa.remove function.
//
// The arguments for remove are sent and received over the wire as this struct.
type Dosa_Remove_Args struct {
	Request *RemoveRequest `json:"request,omitempty"`
}

// ToWire translates a Dosa_Remove_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_Remove_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _RemoveRequest_Read(w wire.Value) (*RemoveRequest, error) {
	var v RemoveRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_Remove_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_Remove_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_Remove_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_Remove_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _RemoveRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Dosa_Remove_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_Remove_Args struct could not be encoded.
func (v *Dosa_Remove_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Request != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Request.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _RemoveRequest_Decode(sr stream.Reader) (*RemoveRequest, error) {
	var v RemoveRequest
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_Remove_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_Remove_Args struct could not be generated from the wire
// representation.
func (v *Dosa_Remove_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Request, err = _RemoveRequest_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Dosa_Remove_Args
// struct.
func (v *Dosa_Remove_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("Dosa_Remove_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_Remove_Args match the
// provided Dosa_Remove_Args.
//
// This function performs a deep comparison.
func (v *Dosa_Remove_Args) Equals(rhs *Dosa_Remove_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_Remove_Args.
func (v *Dosa_Remove_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Dosa_Remove_Args) GetRequest() (o *RemoveRequest) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Dosa_Remove_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "remove" for this struct.
func (v *Dosa_Remove_Args) MethodName() string {
	return "remove"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Dosa_Remove_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Dosa_Remove_Helper provides functions that aid in handling the
// parameters and return values of the Dosa.remove
// function.
var Dosa_Remove_Helper = struct {
	// Args accepts the parameters of remove in-order and returns
	// the arguments struct for the function.
	Args func(
		request *RemoveRequest,
	) *Dosa_Remove_Args

	// IsException returns true if the given error can be thrown
	// by remove.
	//
	// An error can be thrown by remove only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for remove
	// given the error returned by it. The provided error may
	// be nil if remove did not fail.
	//
	// This allows mapping errors returned by remove into a
	// serializable result struct. WrapResponse returns a
	// non-nil error if the provided error cannot be thrown by
	// remove
	//
	//   err := remove(args)
	//   result, err := Dosa_Remove_Helper.WrapResponse(err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from remove: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(error) (*Dosa_Remove_Result, error)

	// UnwrapResponse takes the result struct for remove
	// and returns the erorr returned by it (if any).
	//
	// The error is non-nil only if remove threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   err := Dosa_Remove_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Dosa_Remove_Result) error
}{}

func init() {
	Dosa_Remove_Helper.Args = func(
		request *RemoveRequest,
	) *Dosa_Remove_Args {
		return &Dosa_Remove_Args{
			Request: request,
		}
	}

	Dosa_Remove_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BadRequestError:
			return true
		case *InternalServerError:
			return true
		case *RateLimitError:
			return true
		default:
			return false
		}
	}

	Dosa_Remove_Helper.WrapResponse = func(err error) (*Dosa_Remove_Result, error) {
		if err == nil {
			return &Dosa_Remove_Result{}, nil
		}

		switch e := err.(type) {
		case *BadRequestError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_Remove_Result.ClientError")
			}
			return &Dosa_Remove_Result{ClientError: e}, nil
		case *InternalServerError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_Remove_Result.ServerError")
			}
			return &Dosa_Remove_Result{ServerError: e}, nil
		case *RateLimitError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_Remove_Result.LimitError")
			}
			return &Dosa_Remove_Result{LimitError: e}, nil
		}

		return nil, err
	}
	Dosa_Remove_Helper.UnwrapResponse = func(result *Dosa_Remove_Result) (err error) {
		if result.ClientError != nil {
			err = result.ClientError
			return
		}
		if result.ServerError != nil {
			err = result.ServerError
			return
		}
		if result.LimitError != nil {
			err = result.LimitError
			return
		}
		return
	}

}

// Dosa_Remove_Result represents the result of a Dosa.remove function call.
//
// The result of a remove execution is sent and received over the wire as this struct.
type Dosa_Remove_Result struct {
	ClientError *BadRequestError     `json:"clientError,omitempty"`
	ServerError *InternalServerError `json:"serverError,omitempty"`
	LimitError  *RateLimitError      `json:"limitError,omitempty"`
}

// ToWire translates a Dosa_Remove_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_Remove_Result) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ClientError != nil {
		w, err = v.ClientError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ServerError != nil {
		w, err = v.ServerError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.LimitError != nil {
		w, err = v.LimitError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	if i > 1 {
		return wire.Value{}, fmt.Errorf("Dosa_Remove_Result should have at most one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Dosa_Remove_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_Remove_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_Remove_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_Remove_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ClientError, err = _BadRequestError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ServerError, err = _InternalServerError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.LimitError, err = _RateLimitError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count > 1 {
		return fmt.Errorf("Dosa_Remove_Result should have at most one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a Dosa_Remove_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_Remove_Result struct could not be encoded.
func (v *Dosa_Remove_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.ClientError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ClientError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ServerError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ServerError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LimitError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.LimitError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}

	if count > 1 {
		return fmt.Errorf("Dosa_Remove_Result should have at most one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a Dosa_Remove_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_Remove_Result struct could not be generated from the wire
// representation.
func (v *Dosa_Remove_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.ClientError, err = _BadRequestError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.ServerError, err = _InternalServerError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TStruct:
			v.LimitError, err = _RateLimitError_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count > 1 {
		return fmt.Errorf("Dosa_Remove_Result should have at most one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Dosa_Remove_Result
// struct.
func (v *Dosa_Remove_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.ClientError != nil {
		fields[i] = fmt.Sprintf("ClientError: %v", v.ClientError)
		i++
	}
	if v.ServerError != nil {
		fields[i] = fmt.Sprintf("ServerError: %v", v.ServerError)
		i++
	}
	if v.LimitError != nil {
		fields[i] = fmt.Sprintf("LimitError: %v", v.LimitError)
		i++
	}

	return fmt.Sprintf("Dosa_Remove_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_Remove_Result match the
// provided Dosa_Remove_Result.
//
// This function performs a deep comparison.
func (v *Dosa_Remove_Result) Equals(rhs *Dosa_Remove_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.ClientError == nil && rhs.ClientError == nil) || (v.ClientError != nil && rhs.ClientError != nil && v.ClientError.Equals(rhs.ClientError))) {
		return false
	}
	if !((v.ServerError == nil && rhs.ServerError == nil) || (v.ServerError != nil && rhs.ServerError != nil && v.ServerError.Equals(rhs.ServerError))) {
		return false
	}
	if !((v.LimitError == nil && rhs.LimitError == nil) || (v.LimitError != nil && rhs.LimitError != nil && v.LimitError.Equals(rhs.LimitError))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_Remove_Result.
func (v *Dosa_Remove_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ClientError != nil {
		err = multierr.Append(err, enc.AddObject("clientError", v.ClientError))
	}
	if v.ServerError != nil {
		err = multierr.Append(err, enc.AddObject("serverError", v.ServerError))
	}
	if v.LimitError != nil {
		err = multierr.Append(err, enc.AddObject("limitError", v.LimitError))
	}
	return err
}

// GetClientError returns the value of ClientError if it is set or its
// zero value if it is unset.
func (v *Dosa_Remove_Result) GetClientError() (o *BadRequestError) {
	if v != nil && v.ClientError != nil {
		return v.ClientError
	}

	return
}

// IsSetClientError returns true if ClientError is not nil.
func (v *Dosa_Remove_Result) IsSetClientError() bool {
	return v != nil && v.ClientError != nil
}

// GetServerError returns the value of ServerError if it is set or its
// zero value if it is unset.
func (v *Dosa_Remove_Result) GetServerError() (o *InternalServerError) {
	if v != nil && v.ServerError != nil {
		return v.ServerError
	}

	return
}

// IsSetServerError returns true if ServerError is not nil.
func (v *Dosa_Remove_Result) IsSetServerError() bool {
	return v != nil && v.ServerError != nil
}

// GetLimitError returns the value of LimitError if it is set or its
// zero value if it is unset.
func (v *Dosa_Remove_Result) GetLimitError() (o *RateLimitError) {
	if v != nil && v.LimitError != nil {
		return v.LimitError
	}

	return
}

// IsSetLimitError returns true if LimitError is not nil.
func (v *Dosa_Remove_Result) IsSetLimitError() bool {
	return v != nil && v.LimitError != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "remove" for this struct.
func (v *Dosa_Remove_Result) MethodName() string {
	return "remove"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Dosa_Remove_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Dosa_RemoveRange_Args represents the arguments for the Dosa.removeRange function.
//
// The arguments for removeRange are sent and received over the wire as this struct.
type Dosa_RemoveRange_Args struct {
	Request *RemoveRangeRequest `json:"request,omitempty"`
}

// ToWire translates a Dosa_RemoveRange_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_RemoveRange_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _RemoveRangeRequest_Read(w wire.Value) (*RemoveRangeRequest, error) {
	var v RemoveRangeRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_RemoveRange_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_RemoveRange_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_RemoveRange_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_RemoveRange_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _RemoveRangeRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Dosa_RemoveRange_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_RemoveRange_Args struct could not be encoded.
func (v *Dosa_RemoveRange_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Request != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Request.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _RemoveRangeRequest_Decode(sr stream.Reader) (*RemoveRangeRequest, error) {
	var v RemoveRangeRequest
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_RemoveRange_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_RemoveRange_Args struct could not be generated from the wire
// representation.
func (v *Dosa_RemoveRange_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Request, err = _RemoveRangeRequest_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Dosa_RemoveRange_Args
// struct.
func (v *Dosa_RemoveRange_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("Dosa_RemoveRange_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_RemoveRange_Args match the
// provided Dosa_RemoveRange_Args.
//
// This function performs a deep comparison.
func (v *Dosa_RemoveRange_Args) Equals(rhs *Dosa_RemoveRange_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_RemoveRange_Args.
func (v *Dosa_RemoveRange_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Dosa_RemoveRange_Args) GetRequest() (o *RemoveRangeRequest) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Dosa_RemoveRange_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "removeRange" for this struct.
func (v *Dosa_RemoveRange_Args) MethodName() string {
	return "removeRange"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Dosa_RemoveRange_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Dosa_RemoveRange_Helper provides functions that aid in handling the
// parameters and return values of the Dosa.removeRange
// function.
var Dosa_RemoveRange_Helper = struct {
	// Args accepts the parameters of removeRange in-order and returns
	// the arguments struct for the function.
	Args func(
		request *RemoveRangeRequest,
	) *Dosa_RemoveRange_Args

	// IsException returns true if the given error can be thrown
	// by removeRange.
	//
	// An error can be thrown by removeRange only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for removeRange
	// given the error returned by it. The provided error may
	// be nil if removeRange did not fail.
	//
	// This allows mapping errors returned by removeRange into a
	// serializable result struct. WrapResponse returns a
	// non-nil error if the provided error cannot be thrown by
	// removeRange
	//
	//   err := removeRange(args)
	//   result, err := Dosa_RemoveRange_Helper.WrapResponse(err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from removeRange: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(error) (*Dosa_RemoveRange_Result, error)

	// UnwrapResponse takes the result struct for removeRange
	// and returns the erorr returned by it (if any).
	//
	// The error is non-nil only if removeRange threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   err := Dosa_RemoveRange_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Dosa_RemoveRange_Result) error
}{}

func init() {
	Dosa_RemoveRange_Helper.Args = func(
		request *RemoveRangeRequest,
	) *Dosa_RemoveRange_Args {
		return &Dosa_RemoveRange_Args{
			Request: request,
		}
	}

	Dosa_RemoveRange_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BadRequestError:
			return true
		case *InternalServerError:
			return true
		case *RateLimitError:
			return true
		default:
			return false
		}
	}

	Dosa_RemoveRange_Helper.WrapResponse = func(err error) (*Dosa_RemoveRange_Result, error) {
		if err == nil {
			return &Dosa_RemoveRange_Result{}, nil
		}

		switch e := err.(type) {
		case *BadRequestError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_RemoveRange_Result.ClientError")
			}
			return &Dosa_RemoveRange_Result{ClientError: e}, nil
		case *InternalServerError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_RemoveRange_Result.ServerError")
			}
			return &Dosa_RemoveRange_Result{ServerError: e}, nil
		case *RateLimitError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_RemoveRange_Result.LimitError")
			}
			return &Dosa_RemoveRange_Result{LimitError: e}, nil
		}

		return nil, err
	}
	Dosa_RemoveRange_Helper.UnwrapResponse = func(result *Dosa_RemoveRange_Result) (err error) {
		if result.ClientError != nil {
			err = result.ClientError
			return
		}
		if result.ServerError != nil {
			err = result.ServerError
			return
		}
		if result.LimitError != nil {
			err = result.LimitError
			return
		}
		return
	}

}

// Dosa_RemoveRange_Result represents the result of a Dosa.removeRange function call.
//
// The result of a removeRange execution is sent and received over the wire as this struct.
type Dosa_RemoveRange_Result struct {
	ClientError *BadRequestError     `json:"clientError,omitempty"`
	ServerError *InternalServerError `json:"serverError,omitempty"`
	LimitError  *RateLimitError      `json:"limitError,omitempty"`
}

// ToWire translates a Dosa_RemoveRange_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_RemoveRange_Result) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ClientError != nil {
		w, err = v.ClientError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ServerError != nil {
		w, err = v.ServerError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.LimitError != nil {
		w, err = v.LimitError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	if i > 1 {
		return wire.Value{}, fmt.Errorf("Dosa_RemoveRange_Result should have at most one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Dosa_RemoveRange_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_RemoveRange_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_RemoveRange_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_RemoveRange_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ClientError, err = _BadRequestError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ServerError, err = _InternalServerError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.LimitError, err = _RateLimitError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count > 1 {
		return fmt.Errorf("Dosa_RemoveRange_Result should have at most one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a Dosa_RemoveRange_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_RemoveRange_Result struct could not be encoded.
func (v *Dosa_RemoveRange_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.ClientError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ClientError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ServerError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ServerError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LimitError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.LimitError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}

	if count > 1 {
		return fmt.Errorf("Dosa_RemoveRange_Result should have at most one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a Dosa_RemoveRange_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_RemoveRange_Result struct could not be generated from the wire
// representation.
func (v *Dosa_RemoveRange_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.ClientError, err = _BadRequestError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.ServerError, err = _InternalServerError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TStruct:
			v.LimitError, err = _RateLimitError_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count > 1 {
		return fmt.Errorf("Dosa_RemoveRange_Result should have at most one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Dosa_RemoveRange_Result
// struct.
func (v *Dosa_RemoveRange_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.ClientError != nil {
		fields[i] = fmt.Sprintf("ClientError: %v", v.ClientError)
		i++
	}
	if v.ServerError != nil {
		fields[i] = fmt.Sprintf("ServerError: %v", v.ServerError)
		i++
	}
	if v.LimitError != nil {
		fields[i] = fmt.Sprintf("LimitError: %v", v.LimitError)
		i++
	}

	return fmt.Sprintf("Dosa_RemoveRange_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_RemoveRange_Result match the
// provided Dosa_RemoveRange_Result.
//
// This function performs a deep comparison.
func (v *Dosa_RemoveRange_Result) Equals(rhs *Dosa_RemoveRange_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.ClientError == nil && rhs.ClientError == nil) || (v.ClientError != nil && rhs.ClientError != nil && v.ClientError.Equals(rhs.ClientError))) {
		return false
	}
	if !((v.ServerError == nil && rhs.ServerError == nil) || (v.ServerError != nil && rhs.ServerError != nil && v.ServerError.Equals(rhs.ServerError))) {
		return false
	}
	if !((v.LimitError == nil && rhs.LimitError == nil) || (v.LimitError != nil && rhs.LimitError != nil && v.LimitError.Equals(rhs.LimitError))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_RemoveRange_Result.
func (v *Dosa_RemoveRange_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ClientError != nil {
		err = multierr.Append(err, enc.AddObject("clientError", v.ClientError))
	}
	if v.ServerError != nil {
		err = multierr.Append(err, enc.AddObject("serverError", v.ServerError))
	}
	if v.LimitError != nil {
		err = multierr.Append(err, enc.AddObject("limitError", v.LimitError))
	}
	return err
}

// GetClientError returns the value of ClientError if it is set or its
// zero value if it is unset.
func (v *Dosa_RemoveRange_Result) GetClientError() (o *BadRequestError) {
	if v != nil && v.ClientError != nil {
		return v.ClientError
	}

	return
}

// IsSetClientError returns true if ClientError is not nil.
func (v *Dosa_RemoveRange_Result) IsSetClientError() bool {
	return v != nil && v.ClientError != nil
}

// GetServerError returns the value of ServerError if it is set or its
// zero value if it is unset.
func (v *Dosa_RemoveRange_Result) GetServerError() (o *InternalServerError) {
	if v != nil && v.ServerError != nil {
		return v.ServerError
	}

	return
}

// IsSetServerError returns true if ServerError is not nil.
func (v *Dosa_RemoveRange_Result) IsSetServerError() bool {
	return v != nil && v.ServerError != nil
}

// GetLimitError returns the value of LimitError if it is set or its
// zero value if it is unset.
func (v *Dosa_RemoveRange_Result) GetLimitError() (o *RateLimitError) {
	if v != nil && v.LimitError != nil {
		return v.LimitError
	}

	return
}

// IsSetLimitError returns true if LimitError is not nil.
func (v *Dosa_RemoveRange_Result) IsSetLimitError() bool {
	return v != nil && v.LimitError != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "removeRange" for this struct.
func (v *Dosa_RemoveRange_Result) MethodName() string {
	return "removeRange"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Dosa_RemoveRange_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Dosa_Scan_Args represents the arguments for the Dosa.scan function.
//
// The arguments for scan are sent and received over the wire as this struct.
type Dosa_Scan_Args struct {
	Request *ScanRequest `json:"request,omitempty"`
}

// ToWire translates a Dosa_Scan_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_Scan_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ScanRequest_Read(w wire.Value) (*ScanRequest, error) {
	var v ScanRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_Scan_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_Scan_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_Scan_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_Scan_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _ScanRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Dosa_Scan_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_Scan_Args struct could not be encoded.
func (v *Dosa_Scan_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Request != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Request.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _ScanRequest_Decode(sr stream.Reader) (*ScanRequest, error) {
	var v ScanRequest
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_Scan_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_Scan_Args struct could not be generated from the wire
// representation.
func (v *Dosa_Scan_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Request, err = _ScanRequest_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Dosa_Scan_Args
// struct.
func (v *Dosa_Scan_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("Dosa_Scan_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_Scan_Args match the
// provided Dosa_Scan_Args.
//
// This function performs a deep comparison.
func (v *Dosa_Scan_Args) Equals(rhs *Dosa_Scan_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_Scan_Args.
func (v *Dosa_Scan_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Dosa_Scan_Args) GetRequest() (o *ScanRequest) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Dosa_Scan_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "scan" for this struct.
func (v *Dosa_Scan_Args) MethodName() string {
	return "scan"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Dosa_Scan_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Dosa_Scan_Helper provides functions that aid in handling the
// parameters and return values of the Dosa.scan
// function.
var Dosa_Scan_Helper = struct {
	// Args accepts the parameters of scan in-order and returns
	// the arguments struct for the function.
	Args func(
		request *ScanRequest,
	) *Dosa_Scan_Args

	// IsException returns true if the given error can be thrown
	// by scan.
	//
	// An error can be thrown by scan only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for scan
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// scan into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by scan
	//
	//   value, err := scan(args)
	//   result, err := Dosa_Scan_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from scan: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*ScanResponse, error) (*Dosa_Scan_Result, error)

	// UnwrapResponse takes the result struct for scan
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if scan threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Dosa_Scan_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Dosa_Scan_Result) (*ScanResponse, error)
}{}

func init() {
	Dosa_Scan_Helper.Args = func(
		request *ScanRequest,
	) *Dosa_Scan_Args {
		return &Dosa_Scan_Args{
			Request: request,
		}
	}

	Dosa_Scan_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BadRequestError:
			return true
		case *InternalServerError:
			return true
		case *RateLimitError:
			return true
		default:
			return false
		}
	}

	Dosa_Scan_Helper.WrapResponse = func(success *ScanResponse, err error) (*Dosa_Scan_Result, error) {
		if err == nil {
			return &Dosa_Scan_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *BadRequestError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_Scan_Result.ClientError")
			}
			return &Dosa_Scan_Result{ClientError: e}, nil
		case *InternalServerError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_Scan_Result.ServerError")
			}
			return &Dosa_Scan_Result{ServerError: e}, nil
		case *RateLimitError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_Scan_Result.LimitError")
			}
			return &Dosa_Scan_Result{LimitError: e}, nil
		}

		return nil, err
	}
	Dosa_Scan_Helper.UnwrapResponse = func(result *Dosa_Scan_Result) (success *ScanResponse, err error) {
		if result.ClientError != nil {
			err = result.ClientError
			return
		}
		if result.ServerError != nil {
			err = result.ServerError
			return
		}
		if result.LimitError != nil {
			err = result.LimitError
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Dosa_Scan_Result represents the result of a Dosa.scan function call.
//
// The result of a scan execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Dosa_Scan_Result struct {
	// Value returned by scan after a successful execution.
	Success     *ScanResponse        `json:"success,omitempty"`
	ClientError *BadRequestError     `json:"clientError,omitempty"`
	ServerError *InternalServerError `json:"serverError,omitempty"`
	LimitError  *RateLimitError      `json:"limitError,omitempty"`
}

// ToWire translates a Dosa_Scan_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_Scan_Result) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.ClientError != nil {
		w, err = v.ClientError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ServerError != nil {
		w, err = v.ServerError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.LimitError != nil {
		w, err = v.LimitError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Dosa_Scan_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ScanResponse_Read(w wire.Value) (*ScanResponse, error) {
	var v ScanResponse
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_Scan_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_Scan_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_Scan_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_Scan_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _ScanResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ClientError, err = _BadRequestError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ServerError, err = _InternalServerError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.LimitError, err = _RateLimitError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_Scan_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a Dosa_Scan_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_Scan_Result struct could not be encoded.
func (v *Dosa_Scan_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Success != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 0, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Success.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ClientError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ClientError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ServerError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ServerError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LimitError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.LimitError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}

	if count != 1 {
		return fmt.Errorf("Dosa_Scan_Result should have exactly one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

func _ScanResponse_Decode(sr stream.Reader) (*ScanResponse, error) {
	var v ScanResponse
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_Scan_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_Scan_Result struct could not be generated from the wire
// representation.
func (v *Dosa_Scan_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 0 && fh.Type == wire.TStruct:
			v.Success, err = _ScanResponse_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.ClientError, err = _BadRequestError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.ServerError, err = _InternalServerError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TStruct:
			v.LimitError, err = _RateLimitError_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_Scan_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Dosa_Scan_Result
// struct.
func (v *Dosa_Scan_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.ClientError != nil {
		fields[i] = fmt.Sprintf("ClientError: %v", v.ClientError)
		i++
	}
	if v.ServerError != nil {
		fields[i] = fmt.Sprintf("ServerError: %v", v.ServerError)
		i++
	}
	if v.LimitError != nil {
		fields[i] = fmt.Sprintf("LimitError: %v", v.LimitError)
		i++
	}

	return fmt.Sprintf("Dosa_Scan_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_Scan_Result match the
// provided Dosa_Scan_Result.
//
// This function performs a deep comparison.
func (v *Dosa_Scan_Result) Equals(rhs *Dosa_Scan_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.ClientError == nil && rhs.ClientError == nil) || (v.ClientError != nil && rhs.ClientError != nil && v.ClientError.Equals(rhs.ClientError))) {
		return false
	}
	if !((v.ServerError == nil && rhs.ServerError == nil) || (v.ServerError != nil && rhs.ServerError != nil && v.ServerError.Equals(rhs.ServerError))) {
		return false
	}
	if !((v.LimitError == nil && rhs.LimitError == nil) || (v.LimitError != nil && rhs.LimitError != nil && v.LimitError.Equals(rhs.LimitError))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_Scan_Result.
func (v *Dosa_Scan_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.ClientError != nil {
		err = multierr.Append(err, enc.AddObject("clientError", v.ClientError))
	}
	if v.ServerError != nil {
		err = multierr.Append(err, enc.AddObject("serverError", v.ServerError))
	}
	if v.LimitError != nil {
		err = multierr.Append(err, enc.AddObject("limitError", v.LimitError))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Dosa_Scan_Result) GetSuccess() (o *ScanResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Dosa_Scan_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetClientError returns the value of ClientError if it is set or its
// zero value if it is unset.
func (v *Dosa_Scan_Result) GetClientError() (o *BadRequestError) {
	if v != nil && v.ClientError != nil {
		return v.ClientError
	}

	return
}

// IsSetClientError returns true if ClientError is not nil.
func (v *Dosa_Scan_Result) IsSetClientError() bool {
	return v != nil && v.ClientError != nil
}

// GetServerError returns the value of ServerError if it is set or its
// zero value if it is unset.
func (v *Dosa_Scan_Result) GetServerError() (o *InternalServerError) {
	if v != nil && v.ServerError != nil {
		return v.ServerError
	}

	return
}

// IsSetServerError returns true if ServerError is not nil.
func (v *Dosa_Scan_Result) IsSetServerError() bool {
	return v != nil && v.ServerError != nil
}

// GetLimitError returns the value of LimitError if it is set or its
// zero value if it is unset.
func (v *Dosa_Scan_Result) GetLimitError() (o *RateLimitError) {
	if v != nil && v.LimitError != nil {
		return v.LimitError
	}

	return
}

// IsSetLimitError returns true if LimitError is not nil.
func (v *Dosa_Scan_Result) IsSetLimitError() bool {
	return v != nil && v.LimitError != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "scan" for this struct.
func (v *Dosa_Scan_Result) MethodName() string {
	return "scan"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Dosa_Scan_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Dosa_ScopeExists_Args represents the arguments for the Dosa.scopeExists function.
//
// The arguments for scopeExists are sent and received over the wire as this struct.
type Dosa_ScopeExists_Args struct {
	Request *ScopeExistsRequest `json:"request,omitempty"`
}

// ToWire translates a Dosa_ScopeExists_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_ScopeExists_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ScopeExistsRequest_Read(w wire.Value) (*ScopeExistsRequest, error) {
	var v ScopeExistsRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_ScopeExists_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_ScopeExists_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_ScopeExists_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_ScopeExists_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _ScopeExistsRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Dosa_ScopeExists_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_ScopeExists_Args struct could not be encoded.
func (v *Dosa_ScopeExists_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Request != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Request.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _ScopeExistsRequest_Decode(sr stream.Reader) (*ScopeExistsRequest, error) {
	var v ScopeExistsRequest
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_ScopeExists_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_ScopeExists_Args struct could not be generated from the wire
// representation.
func (v *Dosa_ScopeExists_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Request, err = _ScopeExistsRequest_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Dosa_ScopeExists_Args
// struct.
func (v *Dosa_ScopeExists_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("Dosa_ScopeExists_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_ScopeExists_Args match the
// provided Dosa_ScopeExists_Args.
//
// This function performs a deep comparison.
func (v *Dosa_ScopeExists_Args) Equals(rhs *Dosa_ScopeExists_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_ScopeExists_Args.
func (v *Dosa_ScopeExists_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Dosa_ScopeExists_Args) GetRequest() (o *ScopeExistsRequest) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Dosa_ScopeExists_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "scopeExists" for this struct.
func (v *Dosa_ScopeExists_Args) MethodName() string {
	return "scopeExists"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Dosa_ScopeExists_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Dosa_ScopeExists_Helper provides functions that aid in handling the
// parameters and return values of the Dosa.scopeExists
// function.
var Dosa_ScopeExists_Helper = struct {
	// Args accepts the parameters of scopeExists in-order and returns
	// the arguments struct for the function.
	Args func(
		request *ScopeExistsRequest,
	) *Dosa_ScopeExists_Args

	// IsException returns true if the given error can be thrown
	// by scopeExists.
	//
	// An error can be thrown by scopeExists only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for scopeExists
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// scopeExists into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by scopeExists
	//
	//   value, err := scopeExists(args)
	//   result, err := Dosa_ScopeExists_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from scopeExists: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*ScopeExistsResponse, error) (*Dosa_ScopeExists_Result, error)

	// UnwrapResponse takes the result struct for scopeExists
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if scopeExists threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Dosa_ScopeExists_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Dosa_ScopeExists_Result) (*ScopeExistsResponse, error)
}{}

func init() {
	Dosa_ScopeExists_Helper.Args = func(
		request *ScopeExistsRequest,
	) *Dosa_ScopeExists_Args {
		return &Dosa_ScopeExists_Args{
			Request: request,
		}
	}

	Dosa_ScopeExists_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BadRequestError:
			return true
		case *InternalServerError:
			return true
		case *RateLimitError:
			return true
		default:
			return false
		}
	}

	Dosa_ScopeExists_Helper.WrapResponse = func(success *ScopeExistsResponse, err error) (*Dosa_ScopeExists_Result, error) {
		if err == nil {
			return &Dosa_ScopeExists_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *BadRequestError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_ScopeExists_Result.ClientError")
			}
			return &Dosa_ScopeExists_Result{ClientError: e}, nil
		case *InternalServerError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_ScopeExists_Result.ServerError")
			}
			return &Dosa_ScopeExists_Result{ServerError: e}, nil
		case *RateLimitError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_ScopeExists_Result.LimitError")
			}
			return &Dosa_ScopeExists_Result{LimitError: e}, nil
		}

		return nil, err
	}
	Dosa_ScopeExists_Helper.UnwrapResponse = func(result *Dosa_ScopeExists_Result) (success *ScopeExistsResponse, err error) {
		if result.ClientError != nil {
			err = result.ClientError
			return
		}
		if result.ServerError != nil {
			err = result.ServerError
			return
		}
		if result.LimitError != nil {
			err = result.LimitError
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Dosa_ScopeExists_Result represents the result of a Dosa.scopeExists function call.
//
// The result of a scopeExists execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Dosa_ScopeExists_Result struct {
	// Value returned by scopeExists after a successful execution.
	Success     *ScopeExistsResponse `json:"success,omitempty"`
	ClientError *BadRequestError     `json:"clientError,omitempty"`
	ServerError *InternalServerError `json:"serverError,omitempty"`
	LimitError  *RateLimitError      `json:"limitError,omitempty"`
}

// ToWire translates a Dosa_ScopeExists_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_ScopeExists_Result) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.ClientError != nil {
		w, err = v.ClientError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ServerError != nil {
		w, err = v.ServerError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.LimitError != nil {
		w, err = v.LimitError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Dosa_ScopeExists_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ScopeExistsResponse_Read(w wire.Value) (*ScopeExistsResponse, error) {
	var v ScopeExistsResponse
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_ScopeExists_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_ScopeExists_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_ScopeExists_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_ScopeExists_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _ScopeExistsResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ClientError, err = _BadRequestError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ServerError, err = _InternalServerError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.LimitError, err = _RateLimitError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_ScopeExists_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a Dosa_ScopeExists_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_ScopeExists_Result struct could not be encoded.
func (v *Dosa_ScopeExists_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Success != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 0, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Success.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ClientError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ClientError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ServerError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ServerError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LimitError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.LimitError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}

	if count != 1 {
		return fmt.Errorf("Dosa_ScopeExists_Result should have exactly one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

func _ScopeExistsResponse_Decode(sr stream.Reader) (*ScopeExistsResponse, error) {
	var v ScopeExistsResponse
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_ScopeExists_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_ScopeExists_Result struct could not be generated from the wire
// representation.
func (v *Dosa_ScopeExists_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 0 && fh.Type == wire.TStruct:
			v.Success, err = _ScopeExistsResponse_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.ClientError, err = _BadRequestError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.ServerError, err = _InternalServerError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TStruct:
			v.LimitError, err = _RateLimitError_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_ScopeExists_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Dosa_ScopeExists_Result
// struct.
func (v *Dosa_ScopeExists_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.ClientError != nil {
		fields[i] = fmt.Sprintf("ClientError: %v", v.ClientError)
		i++
	}
	if v.ServerError != nil {
		fields[i] = fmt.Sprintf("ServerError: %v", v.ServerError)
		i++
	}
	if v.LimitError != nil {
		fields[i] = fmt.Sprintf("LimitError: %v", v.LimitError)
		i++
	}

	return fmt.Sprintf("Dosa_ScopeExists_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_ScopeExists_Result match the
// provided Dosa_ScopeExists_Result.
//
// This function performs a deep comparison.
func (v *Dosa_ScopeExists_Result) Equals(rhs *Dosa_ScopeExists_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.ClientError == nil && rhs.ClientError == nil) || (v.ClientError != nil && rhs.ClientError != nil && v.ClientError.Equals(rhs.ClientError))) {
		return false
	}
	if !((v.ServerError == nil && rhs.ServerError == nil) || (v.ServerError != nil && rhs.ServerError != nil && v.ServerError.Equals(rhs.ServerError))) {
		return false
	}
	if !((v.LimitError == nil && rhs.LimitError == nil) || (v.LimitError != nil && rhs.LimitError != nil && v.LimitError.Equals(rhs.LimitError))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_ScopeExists_Result.
func (v *Dosa_ScopeExists_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.ClientError != nil {
		err = multierr.Append(err, enc.AddObject("clientError", v.ClientError))
	}
	if v.ServerError != nil {
		err = multierr.Append(err, enc.AddObject("serverError", v.ServerError))
	}
	if v.LimitError != nil {
		err = multierr.Append(err, enc.AddObject("limitError", v.LimitError))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Dosa_ScopeExists_Result) GetSuccess() (o *ScopeExistsResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Dosa_ScopeExists_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetClientError returns the value of ClientError if it is set or its
// zero value if it is unset.
func (v *Dosa_ScopeExists_Result) GetClientError() (o *BadRequestError) {
	if v != nil && v.ClientError != nil {
		return v.ClientError
	}

	return
}

// IsSetClientError returns true if ClientError is not nil.
func (v *Dosa_ScopeExists_Result) IsSetClientError() bool {
	return v != nil && v.ClientError != nil
}

// GetServerError returns the value of ServerError if it is set or its
// zero value if it is unset.
func (v *Dosa_ScopeExists_Result) GetServerError() (o *InternalServerError) {
	if v != nil && v.ServerError != nil {
		return v.ServerError
	}

	return
}

// IsSetServerError returns true if ServerError is not nil.
func (v *Dosa_ScopeExists_Result) IsSetServerError() bool {
	return v != nil && v.ServerError != nil
}

// GetLimitError returns the value of LimitError if it is set or its
// zero value if it is unset.
func (v *Dosa_ScopeExists_Result) GetLimitError() (o *RateLimitError) {
	if v != nil && v.LimitError != nil {
		return v.LimitError
	}

	return
}

// IsSetLimitError returns true if LimitError is not nil.
func (v *Dosa_ScopeExists_Result) IsSetLimitError() bool {
	return v != nil && v.LimitError != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "scopeExists" for this struct.
func (v *Dosa_ScopeExists_Result) MethodName() string {
	return "scopeExists"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Dosa_ScopeExists_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Dosa_Search_Args represents the arguments for the Dosa.search function.
//
// The arguments for search are sent and received over the wire as this struct.
type Dosa_Search_Args struct {
	Request *SearchRequest `json:"request,omitempty"`
}

// ToWire translates a Dosa_Search_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_Search_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _SearchRequest_Read(w wire.Value) (*SearchRequest, error) {
	var v SearchRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_Search_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_Search_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_Search_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_Search_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _SearchRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Dosa_Search_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_Search_Args struct could not be encoded.
func (v *Dosa_Search_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Request != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Request.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _SearchRequest_Decode(sr stream.Reader) (*SearchRequest, error) {
	var v SearchRequest
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_Search_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_Search_Args struct could not be generated from the wire
// representation.
func (v *Dosa_Search_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Request, err = _SearchRequest_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Dosa_Search_Args
// struct.
func (v *Dosa_Search_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("Dosa_Search_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_Search_Args match the
// provided Dosa_Search_Args.
//
// This function performs a deep comparison.
func (v *Dosa_Search_Args) Equals(rhs *Dosa_Search_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_Search_Args.
func (v *Dosa_Search_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Dosa_Search_Args) GetRequest() (o *SearchRequest) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Dosa_Search_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "search" for this struct.
func (v *Dosa_Search_Args) MethodName() string {
	return "search"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Dosa_Search_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Dosa_Search_Helper provides functions that aid in handling the
// parameters and return values of the Dosa.search
// function.
var Dosa_Search_Helper = struct {
	// Args accepts the parameters of search in-order and returns
	// the arguments struct for the function.
	Args func(
		request *SearchRequest,
	) *Dosa_Search_Args

	// IsException returns true if the given error can be thrown
	// by search.
	//
	// An error can be thrown by search only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for search
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// search into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by search
	//
	//   value, err := search(args)
	//   result, err := Dosa_Search_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from search: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*SearchResponse, error) (*Dosa_Search_Result, error)

	// UnwrapResponse takes the result struct for search
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if search threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Dosa_Search_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Dosa_Search_Result) (*SearchResponse, error)
}{}

func init() {
	Dosa_Search_Helper.Args = func(
		request *SearchRequest,
	) *Dosa_Search_Args {
		return &Dosa_Search_Args{
			Request: request,
		}
	}

	Dosa_Search_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BadRequestError:
			return true
		case *InternalServerError:
			return true
		case *RateLimitError:
			return true
		default:
			return false
		}
	}

	Dosa_Search_Helper.WrapResponse = func(success *SearchResponse, err error) (*Dosa_Search_Result, error) {
		if err == nil {
			return &Dosa_Search_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *BadRequestError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_Search_Result.ClientError")
			}
			return &Dosa_Search_Result{ClientError: e}, nil
		case *InternalServerError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_Search_Result.ServerError")
			}
			return &Dosa_Search_Result{ServerError: e}, nil
		case *RateLimitError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_Search_Result.LimitError")
			}
			return &Dosa_Search_Result{LimitError: e}, nil
		}

		return nil, err
	}
	Dosa_Search_Helper.UnwrapResponse = func(result *Dosa_Search_Result) (success *SearchResponse, err error) {
		if result.ClientError != nil {
			err = result.ClientError
			return
		}
		if result.ServerError != nil {
			err = result.ServerError
			return
		}
		if result.LimitError != nil {
			err = result.LimitError
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Dosa_Search_Result represents the result of a Dosa.search function call.
//
// The result of a search execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Dosa_Search_Result struct {
	// Value returned by search after a successful execution.
	Success     *SearchResponse      `json:"success,omitempty"`
	ClientError *BadRequestError     `json:"clientError,omitempty"`
	ServerError *InternalServerError `json:"serverError,omitempty"`
	LimitError  *RateLimitError      `json:"limitError,omitempty"`
}

// ToWire translates a Dosa_Search_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_Search_Result) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.ClientError != nil {
		w, err = v.ClientError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ServerError != nil {
		w, err = v.ServerError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.LimitError != nil {
		w, err = v.LimitError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Dosa_Search_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _SearchResponse_Read(w wire.Value) (*SearchResponse, error) {
	var v SearchResponse
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_Search_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_Search_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_Search_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_Search_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _SearchResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ClientError, err = _BadRequestError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ServerError, err = _InternalServerError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.LimitError, err = _RateLimitError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_Search_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a Dosa_Search_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_Search_Result struct could not be encoded.
func (v *Dosa_Search_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Success != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 0, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Success.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ClientError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ClientError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ServerError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ServerError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LimitError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.LimitError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}

	if count != 1 {
		return fmt.Errorf("Dosa_Search_Result should have exactly one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

func _SearchResponse_Decode(sr stream.Reader) (*SearchResponse, error) {
	var v SearchResponse
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_Search_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_Search_Result struct could not be generated from the wire
// representation.
func (v *Dosa_Search_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 0 && fh.Type == wire.TStruct:
			v.Success, err = _SearchResponse_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.ClientError, err = _BadRequestError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.ServerError, err = _InternalServerError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TStruct:
			v.LimitError, err = _RateLimitError_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_Search_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Dosa_Search_Result
// struct.
func (v *Dosa_Search_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.ClientError != nil {
		fields[i] = fmt.Sprintf("ClientError: %v", v.ClientError)
		i++
	}
	if v.ServerError != nil {
		fields[i] = fmt.Sprintf("ServerError: %v", v.ServerError)
		i++
	}
	if v.LimitError != nil {
		fields[i] = fmt.Sprintf("LimitError: %v", v.LimitError)
		i++
	}

	return fmt.Sprintf("Dosa_Search_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_Search_Result match the
// provided Dosa_Search_Result.
//
// This function performs a deep comparison.
func (v *Dosa_Search_Result) Equals(rhs *Dosa_Search_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.ClientError == nil && rhs.ClientError == nil) || (v.ClientError != nil && rhs.ClientError != nil && v.ClientError.Equals(rhs.ClientError))) {
		return false
	}
	if !((v.ServerError == nil && rhs.ServerError == nil) || (v.ServerError != nil && rhs.ServerError != nil && v.ServerError.Equals(rhs.ServerError))) {
		return false
	}
	if !((v.LimitError == nil && rhs.LimitError == nil) || (v.LimitError != nil && rhs.LimitError != nil && v.LimitError.Equals(rhs.LimitError))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_Search_Result.
func (v *Dosa_Search_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.ClientError != nil {
		err = multierr.Append(err, enc.AddObject("clientError", v.ClientError))
	}
	if v.ServerError != nil {
		err = multierr.Append(err, enc.AddObject("serverError", v.ServerError))
	}
	if v.LimitError != nil {
		err = multierr.Append(err, enc.AddObject("limitError", v.LimitError))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Dosa_Search_Result) GetSuccess() (o *SearchResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Dosa_Search_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetClientError returns the value of ClientError if it is set or its
// zero value if it is unset.
func (v *Dosa_Search_Result) GetClientError() (o *BadRequestError) {
	if v != nil && v.ClientError != nil {
		return v.ClientError
	}

	return
}

// IsSetClientError returns true if ClientError is not nil.
func (v *Dosa_Search_Result) IsSetClientError() bool {
	return v != nil && v.ClientError != nil
}

// GetServerError returns the value of ServerError if it is set or its
// zero value if it is unset.
func (v *Dosa_Search_Result) GetServerError() (o *InternalServerError) {
	if v != nil && v.ServerError != nil {
		return v.ServerError
	}

	return
}

// IsSetServerError returns true if ServerError is not nil.
func (v *Dosa_Search_Result) IsSetServerError() bool {
	return v != nil && v.ServerError != nil
}

// GetLimitError returns the value of LimitError if it is set or its
// zero value if it is unset.
func (v *Dosa_Search_Result) GetLimitError() (o *RateLimitError) {
	if v != nil && v.LimitError != nil {
		return v.LimitError
	}

	return
}

// IsSetLimitError returns true if LimitError is not nil.
func (v *Dosa_Search_Result) IsSetLimitError() bool {
	return v != nil && v.LimitError != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "search" for this struct.
func (v *Dosa_Search_Result) MethodName() string {
	return "search"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Dosa_Search_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Dosa_TruncateScope_Args represents the arguments for the Dosa.truncateScope function.
//
// The arguments for truncateScope are sent and received over the wire as this struct.
type Dosa_TruncateScope_Args struct {
	Request *TruncateScopeRequest `json:"request,omitempty"`
}

// ToWire translates a Dosa_TruncateScope_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_TruncateScope_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _TruncateScopeRequest_Read(w wire.Value) (*TruncateScopeRequest, error) {
	var v TruncateScopeRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_TruncateScope_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_TruncateScope_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_TruncateScope_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_TruncateScope_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _TruncateScopeRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Dosa_TruncateScope_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_TruncateScope_Args struct could not be encoded.
func (v *Dosa_TruncateScope_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Request != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Request.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _TruncateScopeRequest_Decode(sr stream.Reader) (*TruncateScopeRequest, error) {
	var v TruncateScopeRequest
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_TruncateScope_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_TruncateScope_Args struct could not be generated from the wire
// representation.
func (v *Dosa_TruncateScope_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Request, err = _TruncateScopeRequest_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Dosa_TruncateScope_Args
// struct.
func (v *Dosa_TruncateScope_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("Dosa_TruncateScope_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_TruncateScope_Args match the
// provided Dosa_TruncateScope_Args.
//
// This function performs a deep comparison.
func (v *Dosa_TruncateScope_Args) Equals(rhs *Dosa_TruncateScope_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_TruncateScope_Args.
func (v *Dosa_TruncateScope_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Dosa_TruncateScope_Args) GetRequest() (o *TruncateScopeRequest) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Dosa_TruncateScope_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "truncateScope" for this struct.
func (v *Dosa_TruncateScope_Args) MethodName() string {
	return "truncateScope"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Dosa_TruncateScope_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Dosa_TruncateScope_Helper provides functions that aid in handling the
// parameters and return values of the Dosa.truncateScope
// function.
var Dosa_TruncateScope_Helper = struct {
	// Args accepts the parameters of truncateScope in-order and returns
	// the arguments struct for the function.
	Args func(
		request *TruncateScopeRequest,
	) *Dosa_TruncateScope_Args

	// IsException returns true if the given error can be thrown
	// by truncateScope.
	//
	// An error can be thrown by truncateScope only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for truncateScope
	// given the error returned by it. The provided error may
	// be nil if truncateScope did not fail.
	//
	// This allows mapping errors returned by truncateScope into a
	// serializable result struct. WrapResponse returns a
	// non-nil error if the provided error cannot be thrown by
	// truncateScope
	//
	//   err := truncateScope(args)
	//   result, err := Dosa_TruncateScope_Helper.WrapResponse(err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from truncateScope: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(error) (*Dosa_TruncateScope_Result, error)

	// UnwrapResponse takes the result struct for truncateScope
	// and returns the erorr returned by it (if any).
	//
	// The error is non-nil only if truncateScope threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   err := Dosa_TruncateScope_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Dosa_TruncateScope_Result) error
}{}

func init() {
	Dosa_TruncateScope_Helper.Args = func(
		request *TruncateScopeRequest,
	) *Dosa_TruncateScope_Args {
		return &Dosa_TruncateScope_Args{
			Request: request,
		}
	}

	Dosa_TruncateScope_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BadRequestError:
			return true
		case *InternalServerError:
			return true
		case *RateLimitError:
			return true
		default:
			return false
		}
	}

	Dosa_TruncateScope_Helper.WrapResponse = func(err error) (*Dosa_TruncateScope_Result, error) {
		if err == nil {
			return &Dosa_TruncateScope_Result{}, nil
		}

		switch e := err.(type) {
		case *BadRequestError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_TruncateScope_Result.ClientError")
			}
			return &Dosa_TruncateScope_Result{ClientError: e}, nil
		case *InternalServerError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_TruncateScope_Result.ServerError")
			}
			return &Dosa_TruncateScope_Result{ServerError: e}, nil
		case *RateLimitError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_TruncateScope_Result.LimitError")
			}
			return &Dosa_TruncateScope_Result{LimitError: e}, nil
		}

		return nil, err
	}
	Dosa_TruncateScope_Helper.UnwrapResponse = func(result *Dosa_TruncateScope_Result) (err error) {
		if result.ClientError != nil {
			err = result.ClientError
			return
		}
		if result.ServerError != nil {
			err = result.ServerError
			return
		}
		if result.LimitError != nil {
			err = result.LimitError
			return
		}
		return
	}

}

// Dosa_TruncateScope_Result represents the result of a Dosa.truncateScope function call.
//
// The result of a truncateScope execution is sent and received over the wire as this struct.
type Dosa_TruncateScope_Result struct {
	ClientError *BadRequestError     `json:"clientError,omitempty"`
	ServerError *InternalServerError `json:"serverError,omitempty"`
	LimitError  *RateLimitError      `json:"limitError,omitempty"`
}

// ToWire translates a Dosa_TruncateScope_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_TruncateScope_Result) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ClientError != nil {
		w, err = v.ClientError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ServerError != nil {
		w, err = v.ServerError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.LimitError != nil {
		w, err = v.LimitError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	if i > 1 {
		return wire.Value{}, fmt.Errorf("Dosa_TruncateScope_Result should have at most one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Dosa_TruncateScope_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_TruncateScope_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_TruncateScope_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_TruncateScope_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ClientError, err = _BadRequestError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ServerError, err = _InternalServerError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.LimitError, err = _RateLimitError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count > 1 {
		return fmt.Errorf("Dosa_TruncateScope_Result should have at most one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a Dosa_TruncateScope_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_TruncateScope_Result struct could not be encoded.
func (v *Dosa_TruncateScope_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.ClientError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ClientError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ServerError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ServerError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LimitError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.LimitError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}

	if count > 1 {
		return fmt.Errorf("Dosa_TruncateScope_Result should have at most one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a Dosa_TruncateScope_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_TruncateScope_Result struct could not be generated from the wire
// representation.
func (v *Dosa_TruncateScope_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.ClientError, err = _BadRequestError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.ServerError, err = _InternalServerError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TStruct:
			v.LimitError, err = _RateLimitError_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count > 1 {
		return fmt.Errorf("Dosa_TruncateScope_Result should have at most one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Dosa_TruncateScope_Result
// struct.
func (v *Dosa_TruncateScope_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.ClientError != nil {
		fields[i] = fmt.Sprintf("ClientError: %v", v.ClientError)
		i++
	}
	if v.ServerError != nil {
		fields[i] = fmt.Sprintf("ServerError: %v", v.ServerError)
		i++
	}
	if v.LimitError != nil {
		fields[i] = fmt.Sprintf("LimitError: %v", v.LimitError)
		i++
	}

	return fmt.Sprintf("Dosa_TruncateScope_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_TruncateScope_Result match the
// provided Dosa_TruncateScope_Result.
//
// This function performs a deep comparison.
func (v *Dosa_TruncateScope_Result) Equals(rhs *Dosa_TruncateScope_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.ClientError == nil && rhs.ClientError == nil) || (v.ClientError != nil && rhs.ClientError != nil && v.ClientError.Equals(rhs.ClientError))) {
		return false
	}
	if !((v.ServerError == nil && rhs.ServerError == nil) || (v.ServerError != nil && rhs.ServerError != nil && v.ServerError.Equals(rhs.ServerError))) {
		return false
	}
	if !((v.LimitError == nil && rhs.LimitError == nil) || (v.LimitError != nil && rhs.LimitError != nil && v.LimitError.Equals(rhs.LimitError))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_TruncateScope_Result.
func (v *Dosa_TruncateScope_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ClientError != nil {
		err = multierr.Append(err, enc.AddObject("clientError", v.ClientError))
	}
	if v.ServerError != nil {
		err = multierr.Append(err, enc.AddObject("serverError", v.ServerError))
	}
	if v.LimitError != nil {
		err = multierr.Append(err, enc.AddObject("limitError", v.LimitError))
	}
	return err
}

// GetClientError returns the value of ClientError if it is set or its
// zero value if it is unset.
func (v *Dosa_TruncateScope_Result) GetClientError() (o *BadRequestError) {
	if v != nil && v.ClientError != nil {
		return v.ClientError
	}

	return
}

// IsSetClientError returns true if ClientError is not nil.
func (v *Dosa_TruncateScope_Result) IsSetClientError() bool {
	return v != nil && v.ClientError != nil
}

// GetServerError returns the value of ServerError if it is set or its
// zero value if it is unset.
func (v *Dosa_TruncateScope_Result) GetServerError() (o *InternalServerError) {
	if v != nil && v.ServerError != nil {
		return v.ServerError
	}

	return
}

// IsSetServerError returns true if ServerError is not nil.
func (v *Dosa_TruncateScope_Result) IsSetServerError() bool {
	return v != nil && v.ServerError != nil
}

// GetLimitError returns the value of LimitError if it is set or its
// zero value if it is unset.
func (v *Dosa_TruncateScope_Result) GetLimitError() (o *RateLimitError) {
	if v != nil && v.LimitError != nil {
		return v.LimitError
	}

	return
}

// IsSetLimitError returns true if LimitError is not nil.
func (v *Dosa_TruncateScope_Result) IsSetLimitError() bool {
	return v != nil && v.LimitError != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "truncateScope" for this struct.
func (v *Dosa_TruncateScope_Result) MethodName() string {
	return "truncateScope"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Dosa_TruncateScope_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Dosa_Upsert_Args represents the arguments for the Dosa.upsert function.
//
// The arguments for upsert are sent and received over the wire as this struct.
type Dosa_Upsert_Args struct {
	Request *UpsertRequest `json:"request,omitempty"`
}

// ToWire translates a Dosa_Upsert_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_Upsert_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _UpsertRequest_Read(w wire.Value) (*UpsertRequest, error) {
	var v UpsertRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_Upsert_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_Upsert_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_Upsert_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_Upsert_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _UpsertRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Dosa_Upsert_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_Upsert_Args struct could not be encoded.
func (v *Dosa_Upsert_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Request != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Request.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _UpsertRequest_Decode(sr stream.Reader) (*UpsertRequest, error) {
	var v UpsertRequest
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_Upsert_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_Upsert_Args struct could not be generated from the wire
// representation.
func (v *Dosa_Upsert_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Request, err = _UpsertRequest_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Dosa_Upsert_Args
// struct.
func (v *Dosa_Upsert_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("Dosa_Upsert_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_Upsert_Args match the
// provided Dosa_Upsert_Args.
//
// This function performs a deep comparison.
func (v *Dosa_Upsert_Args) Equals(rhs *Dosa_Upsert_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_Upsert_Args.
func (v *Dosa_Upsert_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Dosa_Upsert_Args) GetRequest() (o *UpsertRequest) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Dosa_Upsert_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "upsert" for this struct.
func (v *Dosa_Upsert_Args) MethodName() string {
	return "upsert"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Dosa_Upsert_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Dosa_Upsert_Helper provides functions that aid in handling the
// parameters and return values of the Dosa.upsert
// function.
var Dosa_Upsert_Helper = struct {
	// Args accepts the parameters of upsert in-order and returns
	// the arguments struct for the function.
	Args func(
		request *UpsertRequest,
	) *Dosa_Upsert_Args

	// IsException returns true if the given error can be thrown
	// by upsert.
	//
	// An error can be thrown by upsert only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for upsert
	// given the error returned by it. The provided error may
	// be nil if upsert did not fail.
	//
	// This allows mapping errors returned by upsert into a
	// serializable result struct. WrapResponse returns a
	// non-nil error if the provided error cannot be thrown by
	// upsert
	//
	//   err := upsert(args)
	//   result, err := Dosa_Upsert_Helper.WrapResponse(err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from upsert: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(error) (*Dosa_Upsert_Result, error)

	// UnwrapResponse takes the result struct for upsert
	// and returns the erorr returned by it (if any).
	//
	// The error is non-nil only if upsert threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   err := Dosa_Upsert_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Dosa_Upsert_Result) error
}{}

func init() {
	Dosa_Upsert_Helper.Args = func(
		request *UpsertRequest,
	) *Dosa_Upsert_Args {
		return &Dosa_Upsert_Args{
			Request: request,
		}
	}

	Dosa_Upsert_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BadRequestError:
			return true
		case *InternalServerError:
			return true
		case *RateLimitError:
			return true
		default:
			return false
		}
	}

	Dosa_Upsert_Helper.WrapResponse = func(err error) (*Dosa_Upsert_Result, error) {
		if err == nil {
			return &Dosa_Upsert_Result{}, nil
		}

		switch e := err.(type) {
		case *BadRequestError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_Upsert_Result.ClientError")
			}
			return &Dosa_Upsert_Result{ClientError: e}, nil
		case *InternalServerError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_Upsert_Result.ServerError")
			}
			return &Dosa_Upsert_Result{ServerError: e}, nil
		case *RateLimitError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_Upsert_Result.LimitError")
			}
			return &Dosa_Upsert_Result{LimitError: e}, nil
		}

		return nil, err
	}
	Dosa_Upsert_Helper.UnwrapResponse = func(result *Dosa_Upsert_Result) (err error) {
		if result.ClientError != nil {
			err = result.ClientError
			return
		}
		if result.ServerError != nil {
			err = result.ServerError
			return
		}
		if result.LimitError != nil {
			err = result.LimitError
			return
		}
		return
	}

}

// Dosa_Upsert_Result represents the result of a Dosa.upsert function call.
//
// The result of a upsert execution is sent and received over the wire as this struct.
type Dosa_Upsert_Result struct {
	ClientError *BadRequestError     `json:"clientError,omitempty"`
	ServerError *InternalServerError `json:"serverError,omitempty"`
	LimitError  *RateLimitError      `json:"limitError,omitempty"`
}

// ToWire translates a Dosa_Upsert_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_Upsert_Result) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ClientError != nil {
		w, err = v.ClientError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ServerError != nil {
		w, err = v.ServerError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.LimitError != nil {
		w, err = v.LimitError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	if i > 1 {
		return wire.Value{}, fmt.Errorf("Dosa_Upsert_Result should have at most one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Dosa_Upsert_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_Upsert_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_Upsert_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_Upsert_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ClientError, err = _BadRequestError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ServerError, err = _InternalServerError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.LimitError, err = _RateLimitError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count > 1 {
		return fmt.Errorf("Dosa_Upsert_Result should have at most one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a Dosa_Upsert_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_Upsert_Result struct could not be encoded.
func (v *Dosa_Upsert_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.ClientError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ClientError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ServerError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ServerError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LimitError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.LimitError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}

	if count > 1 {
		return fmt.Errorf("Dosa_Upsert_Result should have at most one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a Dosa_Upsert_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_Upsert_Result struct could not be generated from the wire
// representation.
func (v *Dosa_Upsert_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.ClientError, err = _BadRequestError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.ServerError, err = _InternalServerError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TStruct:
			v.LimitError, err = _RateLimitError_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count > 1 {
		return fmt.Errorf("Dosa_Upsert_Result should have at most one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Dosa_Upsert_Result
// struct.
func (v *Dosa_Upsert_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.ClientError != nil {
		fields[i] = fmt.Sprintf("ClientError: %v", v.ClientError)
		i++
	}
	if v.ServerError != nil {
		fields[i] = fmt.Sprintf("ServerError: %v", v.ServerError)
		i++
	}
	if v.LimitError != nil {
		fields[i] = fmt.Sprintf("LimitError: %v", v.LimitError)
		i++
	}

	return fmt.Sprintf("Dosa_Upsert_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_Upsert_Result match the
// provided Dosa_Upsert_Result.
//
// This function performs a deep comparison.
func (v *Dosa_Upsert_Result) Equals(rhs *Dosa_Upsert_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.ClientError == nil && rhs.ClientError == nil) || (v.ClientError != nil && rhs.ClientError != nil && v.ClientError.Equals(rhs.ClientError))) {
		return false
	}
	if !((v.ServerError == nil && rhs.ServerError == nil) || (v.ServerError != nil && rhs.ServerError != nil && v.ServerError.Equals(rhs.ServerError))) {
		return false
	}
	if !((v.LimitError == nil && rhs.LimitError == nil) || (v.LimitError != nil && rhs.LimitError != nil && v.LimitError.Equals(rhs.LimitError))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_Upsert_Result.
func (v *Dosa_Upsert_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ClientError != nil {
		err = multierr.Append(err, enc.AddObject("clientError", v.ClientError))
	}
	if v.ServerError != nil {
		err = multierr.Append(err, enc.AddObject("serverError", v.ServerError))
	}
	if v.LimitError != nil {
		err = multierr.Append(err, enc.AddObject("limitError", v.LimitError))
	}
	return err
}

// GetClientError returns the value of ClientError if it is set or its
// zero value if it is unset.
func (v *Dosa_Upsert_Result) GetClientError() (o *BadRequestError) {
	if v != nil && v.ClientError != nil {
		return v.ClientError
	}

	return
}

// IsSetClientError returns true if ClientError is not nil.
func (v *Dosa_Upsert_Result) IsSetClientError() bool {
	return v != nil && v.ClientError != nil
}

// GetServerError returns the value of ServerError if it is set or its
// zero value if it is unset.
func (v *Dosa_Upsert_Result) GetServerError() (o *InternalServerError) {
	if v != nil && v.ServerError != nil {
		return v.ServerError
	}

	return
}

// IsSetServerError returns true if ServerError is not nil.
func (v *Dosa_Upsert_Result) IsSetServerError() bool {
	return v != nil && v.ServerError != nil
}

// GetLimitError returns the value of LimitError if it is set or its
// zero value if it is unset.
func (v *Dosa_Upsert_Result) GetLimitError() (o *RateLimitError) {
	if v != nil && v.LimitError != nil {
		return v.LimitError
	}

	return
}

// IsSetLimitError returns true if LimitError is not nil.
func (v *Dosa_Upsert_Result) IsSetLimitError() bool {
	return v != nil && v.LimitError != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "upsert" for this struct.
func (v *Dosa_Upsert_Result) MethodName() string {
	return "upsert"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Dosa_Upsert_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Dosa_UpsertSchema_Args represents the arguments for the Dosa.upsertSchema function.
//
// The arguments for upsertSchema are sent and received over the wire as this struct.
type Dosa_UpsertSchema_Args struct {
	Request *UpsertSchemaRequest `json:"request,omitempty"`
}

// ToWire translates a Dosa_UpsertSchema_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_UpsertSchema_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _UpsertSchemaRequest_Read(w wire.Value) (*UpsertSchemaRequest, error) {
	var v UpsertSchemaRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_UpsertSchema_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_UpsertSchema_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_UpsertSchema_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_UpsertSchema_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _UpsertSchemaRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Dosa_UpsertSchema_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_UpsertSchema_Args struct could not be encoded.
func (v *Dosa_UpsertSchema_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Request != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Request.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _UpsertSchemaRequest_Decode(sr stream.Reader) (*UpsertSchemaRequest, error) {
	var v UpsertSchemaRequest
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_UpsertSchema_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_UpsertSchema_Args struct could not be generated from the wire
// representation.
func (v *Dosa_UpsertSchema_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.Request, err = _UpsertSchemaRequest_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Dosa_UpsertSchema_Args
// struct.
func (v *Dosa_UpsertSchema_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("Dosa_UpsertSchema_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_UpsertSchema_Args match the
// provided Dosa_UpsertSchema_Args.
//
// This function performs a deep comparison.
func (v *Dosa_UpsertSchema_Args) Equals(rhs *Dosa_UpsertSchema_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_UpsertSchema_Args.
func (v *Dosa_UpsertSchema_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Dosa_UpsertSchema_Args) GetRequest() (o *UpsertSchemaRequest) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Dosa_UpsertSchema_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "upsertSchema" for this struct.
func (v *Dosa_UpsertSchema_Args) MethodName() string {
	return "upsertSchema"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Dosa_UpsertSchema_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Dosa_UpsertSchema_Helper provides functions that aid in handling the
// parameters and return values of the Dosa.upsertSchema
// function.
var Dosa_UpsertSchema_Helper = struct {
	// Args accepts the parameters of upsertSchema in-order and returns
	// the arguments struct for the function.
	Args func(
		request *UpsertSchemaRequest,
	) *Dosa_UpsertSchema_Args

	// IsException returns true if the given error can be thrown
	// by upsertSchema.
	//
	// An error can be thrown by upsertSchema only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for upsertSchema
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// upsertSchema into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by upsertSchema
	//
	//   value, err := upsertSchema(args)
	//   result, err := Dosa_UpsertSchema_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from upsertSchema: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*UpsertSchemaResponse, error) (*Dosa_UpsertSchema_Result, error)

	// UnwrapResponse takes the result struct for upsertSchema
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if upsertSchema threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Dosa_UpsertSchema_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Dosa_UpsertSchema_Result) (*UpsertSchemaResponse, error)
}{}

func init() {
	Dosa_UpsertSchema_Helper.Args = func(
		request *UpsertSchemaRequest,
	) *Dosa_UpsertSchema_Args {
		return &Dosa_UpsertSchema_Args{
			Request: request,
		}
	}

	Dosa_UpsertSchema_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BadRequestError:
			return true
		case *InternalServerError:
			return true
		case *BadSchemaError:
			return true
		case *RateLimitError:
			return true
		default:
			return false
		}
	}

	Dosa_UpsertSchema_Helper.WrapResponse = func(success *UpsertSchemaResponse, err error) (*Dosa_UpsertSchema_Result, error) {
		if err == nil {
			return &Dosa_UpsertSchema_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *BadRequestError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_UpsertSchema_Result.ClientError")
			}
			return &Dosa_UpsertSchema_Result{ClientError: e}, nil
		case *InternalServerError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_UpsertSchema_Result.ServerError")
			}
			return &Dosa_UpsertSchema_Result{ServerError: e}, nil
		case *BadSchemaError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_UpsertSchema_Result.SchemaError")
			}
			return &Dosa_UpsertSchema_Result{SchemaError: e}, nil
		case *RateLimitError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Dosa_UpsertSchema_Result.LimitError")
			}
			return &Dosa_UpsertSchema_Result{LimitError: e}, nil
		}

		return nil, err
	}
	Dosa_UpsertSchema_Helper.UnwrapResponse = func(result *Dosa_UpsertSchema_Result) (success *UpsertSchemaResponse, err error) {
		if result.ClientError != nil {
			err = result.ClientError
			return
		}
		if result.ServerError != nil {
			err = result.ServerError
			return
		}
		if result.SchemaError != nil {
			err = result.SchemaError
			return
		}
		if result.LimitError != nil {
			err = result.LimitError
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Dosa_UpsertSchema_Result represents the result of a Dosa.upsertSchema function call.
//
// The result of a upsertSchema execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Dosa_UpsertSchema_Result struct {
	// Value returned by upsertSchema after a successful execution.
	Success     *UpsertSchemaResponse `json:"success,omitempty"`
	ClientError *BadRequestError      `json:"clientError,omitempty"`
	ServerError *InternalServerError  `json:"serverError,omitempty"`
	SchemaError *BadSchemaError       `json:"schemaError,omitempty"`
	LimitError  *RateLimitError       `json:"limitError,omitempty"`
}

// ToWire translates a Dosa_UpsertSchema_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Dosa_UpsertSchema_Result) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.ClientError != nil {
		w, err = v.ClientError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ServerError != nil {
		w, err = v.ServerError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.SchemaError != nil {
		w, err = v.SchemaError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.LimitError != nil {
		w, err = v.LimitError.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Dosa_UpsertSchema_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _UpsertSchemaResponse_Read(w wire.Value) (*UpsertSchemaResponse, error) {
	var v UpsertSchemaResponse
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Dosa_UpsertSchema_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Dosa_UpsertSchema_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Dosa_UpsertSchema_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Dosa_UpsertSchema_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _UpsertSchemaResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.ClientError, err = _BadRequestError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.ServerError, err = _InternalServerError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.SchemaError, err = _BadSchemaError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TStruct {
				v.LimitError, err = _RateLimitError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.SchemaError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_UpsertSchema_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a Dosa_UpsertSchema_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Dosa_UpsertSchema_Result struct could not be encoded.
func (v *Dosa_UpsertSchema_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Success != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 0, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Success.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ClientError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ClientError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.ServerError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.ServerError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.SchemaError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.SchemaError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.LimitError != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 4, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.LimitError.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.SchemaError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}

	if count != 1 {
		return fmt.Errorf("Dosa_UpsertSchema_Result should have exactly one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

func _UpsertSchemaResponse_Decode(sr stream.Reader) (*UpsertSchemaResponse, error) {
	var v UpsertSchemaResponse
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Dosa_UpsertSchema_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Dosa_UpsertSchema_Result struct could not be generated from the wire
// representation.
func (v *Dosa_UpsertSchema_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch {
		case fh.ID == 0 && fh.Type == wire.TStruct:
			v.Success, err = _UpsertSchemaResponse_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 1 && fh.Type == wire.TStruct:
			v.ClientError, err = _BadRequestError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 2 && fh.Type == wire.TStruct:
			v.ServerError, err = _InternalServerError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 3 && fh.Type == wire.TStruct:
			v.SchemaError, err = _BadSchemaError_Decode(sr)
			if err != nil {
				return err
			}

		case fh.ID == 4 && fh.Type == wire.TStruct:
			v.LimitError, err = _RateLimitError_Decode(sr)
			if err != nil {
				return err
			}

		default:
			if err := sr.Skip(fh.Type); err != nil {
				return err
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.ClientError != nil {
		count++
	}
	if v.ServerError != nil {
		count++
	}
	if v.SchemaError != nil {
		count++
	}
	if v.LimitError != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Dosa_UpsertSchema_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Dosa_UpsertSchema_Result
// struct.
func (v *Dosa_UpsertSchema_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [5]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.ClientError != nil {
		fields[i] = fmt.Sprintf("ClientError: %v", v.ClientError)
		i++
	}
	if v.ServerError != nil {
		fields[i] = fmt.Sprintf("ServerError: %v", v.ServerError)
		i++
	}
	if v.SchemaError != nil {
		fields[i] = fmt.Sprintf("SchemaError: %v", v.SchemaError)
		i++
	}
	if v.LimitError != nil {
		fields[i] = fmt.Sprintf("LimitError: %v", v.LimitError)
		i++
	}

	return fmt.Sprintf("Dosa_UpsertSchema_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Dosa_UpsertSchema_Result match the
// provided Dosa_UpsertSchema_Result.
//
// This function performs a deep comparison.
func (v *Dosa_UpsertSchema_Result) Equals(rhs *Dosa_UpsertSchema_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.ClientError == nil && rhs.ClientError == nil) || (v.ClientError != nil && rhs.ClientError != nil && v.ClientError.Equals(rhs.ClientError))) {
		return false
	}
	if !((v.ServerError == nil && rhs.ServerError == nil) || (v.ServerError != nil && rhs.ServerError != nil && v.ServerError.Equals(rhs.ServerError))) {
		return false
	}
	if !((v.SchemaError == nil && rhs.SchemaError == nil) || (v.SchemaError != nil && rhs.SchemaError != nil && v.SchemaError.Equals(rhs.SchemaError))) {
		return false
	}
	if !((v.LimitError == nil && rhs.LimitError == nil) || (v.LimitError != nil && rhs.LimitError != nil && v.LimitError.Equals(rhs.LimitError))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Dosa_UpsertSchema_Result.
func (v *Dosa_UpsertSchema_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.ClientError != nil {
		err = multierr.Append(err, enc.AddObject("clientError", v.ClientError))
	}
	if v.ServerError != nil {
		err = multierr.Append(err, enc.AddObject("serverError", v.ServerError))
	}
	if v.SchemaError != nil {
		err = multierr.Append(err, enc.AddObject("schemaError", v.SchemaError))
	}
	if v.LimitError != nil {
		err = multierr.Append(err, enc.AddObject("limitError", v.LimitError))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Dosa_UpsertSchema_Result) GetSuccess() (o *UpsertSchemaResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Dosa_UpsertSchema_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetClientError returns the value of ClientError if it is set or its
// zero value if it is unset.
func (v *Dosa_UpsertSchema_Result) GetClientError() (o *BadRequestError) {
	if v != nil && v.ClientError != nil {
		return v.ClientError
	}

	return
}

// IsSetClientError returns true if ClientError is not nil.
func (v *Dosa_UpsertSchema_Result) IsSetClientError() bool {
	return v != nil && v.ClientError != nil
}

// GetServerError returns the value of ServerError if it is set or its
// zero value if it is unset.
func (v *Dosa_UpsertSchema_Result) GetServerError() (o *InternalServerError) {
	if v != nil && v.ServerError != nil {
		return v.ServerError
	}

	return
}

// IsSetServerError returns true if ServerError is not nil.
func (v *Dosa_UpsertSchema_Result) IsSetServerError() bool {
	return v != nil && v.ServerError != nil
}

// GetSchemaError returns the value of SchemaError if it is set or its
// zero value if it is unset.
func (v *Dosa_UpsertSchema_Result) GetSchemaError() (o *BadSchemaError) {
	if v != nil && v.SchemaError != nil {
		return v.SchemaError
	}

	return
}

// IsSetSchemaError returns true if SchemaError is not nil.
func (v *Dosa_UpsertSchema_Result) IsSetSchemaError() bool {
	return v != nil && v.SchemaError != nil
}

// GetLimitError returns the value of LimitError if it is set or its
// zero value if it is unset.
func (v *Dosa_UpsertSchema_Result) GetLimitError() (o *RateLimitError) {
	if v != nil && v.LimitError != nil {
		return v.LimitError
	}

	return
}

// IsSetLimitError returns true if LimitError is not nil.
func (v *Dosa_UpsertSchema_Result) IsSetLimitError() bool {
	return v != nil && v.LimitError != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "upsertSchema" for this struct.
func (v *Dosa_UpsertSchema_Result) MethodName() string {
	return "upsertSchema"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Dosa_UpsertSchema_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}
